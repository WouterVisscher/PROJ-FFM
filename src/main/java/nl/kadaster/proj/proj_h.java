// Generated by jextract

package nl.kadaster.proj;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

public class proj_h extends proj_h$shared {

    proj_h() {
        // Should not be called directly
    }

    static final Arena LIBRARY_ARENA = Arena.ofAuto();

    static final SymbolLookup SYMBOL_LOOKUP = SymbolLookup.libraryLookup(System.mapLibraryName("proj"), LIBRARY_ARENA)
            .or(SymbolLookup.loaderLookup())
            .or(Linker.nativeLinker().defaultLookup());

    private static final int PROJ_VERSION_MAJOR = (int)9L;
    /**
     * {@snippet lang=c :
     * #define PROJ_VERSION_MAJOR 9
     * }
     */
    public static int PROJ_VERSION_MAJOR() {
        return PROJ_VERSION_MAJOR;
    }
    private static final int PROJ_VERSION_MINOR = (int)6L;
    /**
     * {@snippet lang=c :
     * #define PROJ_VERSION_MINOR 6
     * }
     */
    public static int PROJ_VERSION_MINOR() {
        return PROJ_VERSION_MINOR;
    }
    private static final int PROJ_VERSION_PATCH = (int)2L;
    /**
     * {@snippet lang=c :
     * #define PROJ_VERSION_PATCH 2
     * }
     */
    public static int PROJ_VERSION_PATCH() {
        return PROJ_VERSION_PATCH;
    }
    private static final int PJ_DEFAULT_CTX = (int)0L;
    /**
     * {@snippet lang=c :
     * #define PJ_DEFAULT_CTX 0
     * }
     */
    public static int PJ_DEFAULT_CTX() {
        return PJ_DEFAULT_CTX;
    }
    private static final int PROJ_ERR_INVALID_OP = (int)1024L;
    /**
     * {@snippet lang=c :
     * #define PROJ_ERR_INVALID_OP 1024
     * }
     */
    public static int PROJ_ERR_INVALID_OP() {
        return PROJ_ERR_INVALID_OP;
    }
    private static final int PROJ_ERR_COORD_TRANSFM = (int)2048L;
    /**
     * {@snippet lang=c :
     * #define PROJ_ERR_COORD_TRANSFM 2048
     * }
     */
    public static int PROJ_ERR_COORD_TRANSFM() {
        return PROJ_ERR_COORD_TRANSFM;
    }
    private static final int PROJ_ERR_OTHER = (int)4096L;
    /**
     * {@snippet lang=c :
     * #define PROJ_ERR_OTHER 4096
     * }
     */
    public static int PROJ_ERR_OTHER() {
        return PROJ_ERR_OTHER;
    }
    /**
     * {@snippet lang=c :
     * typedef long ptrdiff_t
     * }
     */
    public static final OfLong ptrdiff_t = proj_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long size_t
     * }
     */
    public static final OfLong size_t = proj_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef int wchar_t
     * }
     */
    public static final OfInt wchar_t = proj_h.C_INT;

    private static class pj_release$constants {
        public static final SequenceLayout LAYOUT = MemoryLayout.sequenceLayout(0, proj_h.C_CHAR);
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("pj_release").reinterpret(LAYOUT.byteSize());
    public static final VarHandle HANDLE = LAYOUT.varHandle();

        public static final long[] DIMS = {  };
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const char pj_release[]
     * }
     */
    public static SequenceLayout pj_release$layout() {
        return pj_release$constants.LAYOUT;
    }

    /**
     * Dimensions for array variable:
     * {@snippet lang=c :
     * extern const char pj_release[]
     * }
     */
    public static long[] pj_release$dimensions() {
        return pj_release$constants.DIMS;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const char pj_release[]
     * }
     */
    public static MemorySegment pj_release() {
        return pj_release$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const char pj_release[]
     * }
     */
    public static void pj_release(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, pj_release$constants.SEGMENT, 0L, pj_release$constants.LAYOUT.byteSize());
    }
    private static final int PJ_LOG_NONE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum PJ_LOG_LEVEL.PJ_LOG_NONE = 0
     * }
     */
    public static int PJ_LOG_NONE() {
        return PJ_LOG_NONE;
    }
    private static final int PJ_LOG_ERROR = (int)1L;
    /**
     * {@snippet lang=c :
     * enum PJ_LOG_LEVEL.PJ_LOG_ERROR = 1
     * }
     */
    public static int PJ_LOG_ERROR() {
        return PJ_LOG_ERROR;
    }
    private static final int PJ_LOG_DEBUG = (int)2L;
    /**
     * {@snippet lang=c :
     * enum PJ_LOG_LEVEL.PJ_LOG_DEBUG = 2
     * }
     */
    public static int PJ_LOG_DEBUG() {
        return PJ_LOG_DEBUG;
    }
    private static final int PJ_LOG_TRACE = (int)3L;
    /**
     * {@snippet lang=c :
     * enum PJ_LOG_LEVEL.PJ_LOG_TRACE = 3
     * }
     */
    public static int PJ_LOG_TRACE() {
        return PJ_LOG_TRACE;
    }
    private static final int PJ_LOG_TELL = (int)4L;
    /**
     * {@snippet lang=c :
     * enum PJ_LOG_LEVEL.PJ_LOG_TELL = 4
     * }
     */
    public static int PJ_LOG_TELL() {
        return PJ_LOG_TELL;
    }
    private static final int PJ_LOG_DEBUG_MAJOR = (int)2L;
    /**
     * {@snippet lang=c :
     * enum PJ_LOG_LEVEL.PJ_LOG_DEBUG_MAJOR = 2
     * }
     */
    public static int PJ_LOG_DEBUG_MAJOR() {
        return PJ_LOG_DEBUG_MAJOR;
    }
    private static final int PJ_LOG_DEBUG_MINOR = (int)3L;
    /**
     * {@snippet lang=c :
     * enum PJ_LOG_LEVEL.PJ_LOG_DEBUG_MINOR = 3
     * }
     */
    public static int PJ_LOG_DEBUG_MINOR() {
        return PJ_LOG_DEBUG_MINOR;
    }

    private static class proj_context_create {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_context_create");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ_CONTEXT *proj_context_create()
     * }
     */
    public static FunctionDescriptor proj_context_create$descriptor() {
        return proj_context_create.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ_CONTEXT *proj_context_create()
     * }
     */
    public static MethodHandle proj_context_create$handle() {
        return proj_context_create.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ_CONTEXT *proj_context_create()
     * }
     */
    public static MemorySegment proj_context_create$address() {
        return proj_context_create.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ_CONTEXT *proj_context_create()
     * }
     */
    public static MemorySegment proj_context_create() {
        var mh$ = proj_context_create.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_context_create");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_context_destroy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_context_destroy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ_CONTEXT *proj_context_destroy(PJ_CONTEXT *ctx)
     * }
     */
    public static FunctionDescriptor proj_context_destroy$descriptor() {
        return proj_context_destroy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ_CONTEXT *proj_context_destroy(PJ_CONTEXT *ctx)
     * }
     */
    public static MethodHandle proj_context_destroy$handle() {
        return proj_context_destroy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ_CONTEXT *proj_context_destroy(PJ_CONTEXT *ctx)
     * }
     */
    public static MemorySegment proj_context_destroy$address() {
        return proj_context_destroy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ_CONTEXT *proj_context_destroy(PJ_CONTEXT *ctx)
     * }
     */
    public static MemorySegment proj_context_destroy(MemorySegment ctx) {
        var mh$ = proj_context_destroy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_context_destroy", ctx);
            }
            return (MemorySegment)mh$.invokeExact(ctx);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_context_clone {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_context_clone");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ_CONTEXT *proj_context_clone(PJ_CONTEXT *ctx)
     * }
     */
    public static FunctionDescriptor proj_context_clone$descriptor() {
        return proj_context_clone.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ_CONTEXT *proj_context_clone(PJ_CONTEXT *ctx)
     * }
     */
    public static MethodHandle proj_context_clone$handle() {
        return proj_context_clone.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ_CONTEXT *proj_context_clone(PJ_CONTEXT *ctx)
     * }
     */
    public static MemorySegment proj_context_clone$address() {
        return proj_context_clone.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ_CONTEXT *proj_context_clone(PJ_CONTEXT *ctx)
     * }
     */
    public static MemorySegment proj_context_clone(MemorySegment ctx) {
        var mh$ = proj_context_clone.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_context_clone", ctx);
            }
            return (MemorySegment)mh$.invokeExact(ctx);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_context_set_file_finder {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_context_set_file_finder");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void proj_context_set_file_finder(PJ_CONTEXT *ctx, proj_file_finder finder, void *user_data)
     * }
     */
    public static FunctionDescriptor proj_context_set_file_finder$descriptor() {
        return proj_context_set_file_finder.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void proj_context_set_file_finder(PJ_CONTEXT *ctx, proj_file_finder finder, void *user_data)
     * }
     */
    public static MethodHandle proj_context_set_file_finder$handle() {
        return proj_context_set_file_finder.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void proj_context_set_file_finder(PJ_CONTEXT *ctx, proj_file_finder finder, void *user_data)
     * }
     */
    public static MemorySegment proj_context_set_file_finder$address() {
        return proj_context_set_file_finder.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void proj_context_set_file_finder(PJ_CONTEXT *ctx, proj_file_finder finder, void *user_data)
     * }
     */
    public static void proj_context_set_file_finder(MemorySegment ctx, MemorySegment finder, MemorySegment user_data) {
        var mh$ = proj_context_set_file_finder.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_context_set_file_finder", ctx, finder, user_data);
            }
            mh$.invokeExact(ctx, finder, user_data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_context_set_search_paths {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            proj_h.C_POINTER,
            proj_h.C_INT,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_context_set_search_paths");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void proj_context_set_search_paths(PJ_CONTEXT *ctx, int count_paths, const char *const *paths)
     * }
     */
    public static FunctionDescriptor proj_context_set_search_paths$descriptor() {
        return proj_context_set_search_paths.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void proj_context_set_search_paths(PJ_CONTEXT *ctx, int count_paths, const char *const *paths)
     * }
     */
    public static MethodHandle proj_context_set_search_paths$handle() {
        return proj_context_set_search_paths.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void proj_context_set_search_paths(PJ_CONTEXT *ctx, int count_paths, const char *const *paths)
     * }
     */
    public static MemorySegment proj_context_set_search_paths$address() {
        return proj_context_set_search_paths.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void proj_context_set_search_paths(PJ_CONTEXT *ctx, int count_paths, const char *const *paths)
     * }
     */
    public static void proj_context_set_search_paths(MemorySegment ctx, int count_paths, MemorySegment paths) {
        var mh$ = proj_context_set_search_paths.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_context_set_search_paths", ctx, count_paths, paths);
            }
            mh$.invokeExact(ctx, count_paths, paths);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_context_set_ca_bundle_path {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_context_set_ca_bundle_path");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void proj_context_set_ca_bundle_path(PJ_CONTEXT *ctx, const char *path)
     * }
     */
    public static FunctionDescriptor proj_context_set_ca_bundle_path$descriptor() {
        return proj_context_set_ca_bundle_path.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void proj_context_set_ca_bundle_path(PJ_CONTEXT *ctx, const char *path)
     * }
     */
    public static MethodHandle proj_context_set_ca_bundle_path$handle() {
        return proj_context_set_ca_bundle_path.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void proj_context_set_ca_bundle_path(PJ_CONTEXT *ctx, const char *path)
     * }
     */
    public static MemorySegment proj_context_set_ca_bundle_path$address() {
        return proj_context_set_ca_bundle_path.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void proj_context_set_ca_bundle_path(PJ_CONTEXT *ctx, const char *path)
     * }
     */
    public static void proj_context_set_ca_bundle_path(MemorySegment ctx, MemorySegment path) {
        var mh$ = proj_context_set_ca_bundle_path.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_context_set_ca_bundle_path", ctx, path);
            }
            mh$.invokeExact(ctx, path);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_context_use_proj4_init_rules {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            proj_h.C_POINTER,
            proj_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_context_use_proj4_init_rules");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void proj_context_use_proj4_init_rules(PJ_CONTEXT *ctx, int enable)
     * }
     */
    public static FunctionDescriptor proj_context_use_proj4_init_rules$descriptor() {
        return proj_context_use_proj4_init_rules.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void proj_context_use_proj4_init_rules(PJ_CONTEXT *ctx, int enable)
     * }
     */
    public static MethodHandle proj_context_use_proj4_init_rules$handle() {
        return proj_context_use_proj4_init_rules.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void proj_context_use_proj4_init_rules(PJ_CONTEXT *ctx, int enable)
     * }
     */
    public static MemorySegment proj_context_use_proj4_init_rules$address() {
        return proj_context_use_proj4_init_rules.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void proj_context_use_proj4_init_rules(PJ_CONTEXT *ctx, int enable)
     * }
     */
    public static void proj_context_use_proj4_init_rules(MemorySegment ctx, int enable) {
        var mh$ = proj_context_use_proj4_init_rules.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_context_use_proj4_init_rules", ctx, enable);
            }
            mh$.invokeExact(ctx, enable);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_context_get_use_proj4_init_rules {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_INT,
            proj_h.C_POINTER,
            proj_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_context_get_use_proj4_init_rules");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int proj_context_get_use_proj4_init_rules(PJ_CONTEXT *ctx, int from_legacy_code_path)
     * }
     */
    public static FunctionDescriptor proj_context_get_use_proj4_init_rules$descriptor() {
        return proj_context_get_use_proj4_init_rules.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int proj_context_get_use_proj4_init_rules(PJ_CONTEXT *ctx, int from_legacy_code_path)
     * }
     */
    public static MethodHandle proj_context_get_use_proj4_init_rules$handle() {
        return proj_context_get_use_proj4_init_rules.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int proj_context_get_use_proj4_init_rules(PJ_CONTEXT *ctx, int from_legacy_code_path)
     * }
     */
    public static MemorySegment proj_context_get_use_proj4_init_rules$address() {
        return proj_context_get_use_proj4_init_rules.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int proj_context_get_use_proj4_init_rules(PJ_CONTEXT *ctx, int from_legacy_code_path)
     * }
     */
    public static int proj_context_get_use_proj4_init_rules(MemorySegment ctx, int from_legacy_code_path) {
        var mh$ = proj_context_get_use_proj4_init_rules.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_context_get_use_proj4_init_rules", ctx, from_legacy_code_path);
            }
            return (int)mh$.invokeExact(ctx, from_legacy_code_path);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int PROJ_OPEN_ACCESS_READ_ONLY = (int)0L;
    /**
     * {@snippet lang=c :
     * enum PROJ_OPEN_ACCESS.PROJ_OPEN_ACCESS_READ_ONLY = 0
     * }
     */
    public static int PROJ_OPEN_ACCESS_READ_ONLY() {
        return PROJ_OPEN_ACCESS_READ_ONLY;
    }
    private static final int PROJ_OPEN_ACCESS_READ_UPDATE = (int)1L;
    /**
     * {@snippet lang=c :
     * enum PROJ_OPEN_ACCESS.PROJ_OPEN_ACCESS_READ_UPDATE = 1
     * }
     */
    public static int PROJ_OPEN_ACCESS_READ_UPDATE() {
        return PROJ_OPEN_ACCESS_READ_UPDATE;
    }
    private static final int PROJ_OPEN_ACCESS_CREATE = (int)2L;
    /**
     * {@snippet lang=c :
     * enum PROJ_OPEN_ACCESS.PROJ_OPEN_ACCESS_CREATE = 2
     * }
     */
    public static int PROJ_OPEN_ACCESS_CREATE() {
        return PROJ_OPEN_ACCESS_CREATE;
    }

    private static class proj_context_set_fileapi {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_INT,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_context_set_fileapi");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int proj_context_set_fileapi(PJ_CONTEXT *ctx, const PROJ_FILE_API *fileapi, void *user_data)
     * }
     */
    public static FunctionDescriptor proj_context_set_fileapi$descriptor() {
        return proj_context_set_fileapi.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int proj_context_set_fileapi(PJ_CONTEXT *ctx, const PROJ_FILE_API *fileapi, void *user_data)
     * }
     */
    public static MethodHandle proj_context_set_fileapi$handle() {
        return proj_context_set_fileapi.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int proj_context_set_fileapi(PJ_CONTEXT *ctx, const PROJ_FILE_API *fileapi, void *user_data)
     * }
     */
    public static MemorySegment proj_context_set_fileapi$address() {
        return proj_context_set_fileapi.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int proj_context_set_fileapi(PJ_CONTEXT *ctx, const PROJ_FILE_API *fileapi, void *user_data)
     * }
     */
    public static int proj_context_set_fileapi(MemorySegment ctx, MemorySegment fileapi, MemorySegment user_data) {
        var mh$ = proj_context_set_fileapi.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_context_set_fileapi", ctx, fileapi, user_data);
            }
            return (int)mh$.invokeExact(ctx, fileapi, user_data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_context_set_sqlite3_vfs_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_context_set_sqlite3_vfs_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void proj_context_set_sqlite3_vfs_name(PJ_CONTEXT *ctx, const char *name)
     * }
     */
    public static FunctionDescriptor proj_context_set_sqlite3_vfs_name$descriptor() {
        return proj_context_set_sqlite3_vfs_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void proj_context_set_sqlite3_vfs_name(PJ_CONTEXT *ctx, const char *name)
     * }
     */
    public static MethodHandle proj_context_set_sqlite3_vfs_name$handle() {
        return proj_context_set_sqlite3_vfs_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void proj_context_set_sqlite3_vfs_name(PJ_CONTEXT *ctx, const char *name)
     * }
     */
    public static MemorySegment proj_context_set_sqlite3_vfs_name$address() {
        return proj_context_set_sqlite3_vfs_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void proj_context_set_sqlite3_vfs_name(PJ_CONTEXT *ctx, const char *name)
     * }
     */
    public static void proj_context_set_sqlite3_vfs_name(MemorySegment ctx, MemorySegment name) {
        var mh$ = proj_context_set_sqlite3_vfs_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_context_set_sqlite3_vfs_name", ctx, name);
            }
            mh$.invokeExact(ctx, name);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_context_set_network_callbacks {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_INT,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_context_set_network_callbacks");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int proj_context_set_network_callbacks(PJ_CONTEXT *ctx, proj_network_open_cbk_type open_cbk, proj_network_close_cbk_type close_cbk, proj_network_get_header_value_cbk_type get_header_value_cbk, proj_network_read_range_type read_range_cbk, void *user_data)
     * }
     */
    public static FunctionDescriptor proj_context_set_network_callbacks$descriptor() {
        return proj_context_set_network_callbacks.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int proj_context_set_network_callbacks(PJ_CONTEXT *ctx, proj_network_open_cbk_type open_cbk, proj_network_close_cbk_type close_cbk, proj_network_get_header_value_cbk_type get_header_value_cbk, proj_network_read_range_type read_range_cbk, void *user_data)
     * }
     */
    public static MethodHandle proj_context_set_network_callbacks$handle() {
        return proj_context_set_network_callbacks.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int proj_context_set_network_callbacks(PJ_CONTEXT *ctx, proj_network_open_cbk_type open_cbk, proj_network_close_cbk_type close_cbk, proj_network_get_header_value_cbk_type get_header_value_cbk, proj_network_read_range_type read_range_cbk, void *user_data)
     * }
     */
    public static MemorySegment proj_context_set_network_callbacks$address() {
        return proj_context_set_network_callbacks.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int proj_context_set_network_callbacks(PJ_CONTEXT *ctx, proj_network_open_cbk_type open_cbk, proj_network_close_cbk_type close_cbk, proj_network_get_header_value_cbk_type get_header_value_cbk, proj_network_read_range_type read_range_cbk, void *user_data)
     * }
     */
    public static int proj_context_set_network_callbacks(MemorySegment ctx, MemorySegment open_cbk, MemorySegment close_cbk, MemorySegment get_header_value_cbk, MemorySegment read_range_cbk, MemorySegment user_data) {
        var mh$ = proj_context_set_network_callbacks.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_context_set_network_callbacks", ctx, open_cbk, close_cbk, get_header_value_cbk, read_range_cbk, user_data);
            }
            return (int)mh$.invokeExact(ctx, open_cbk, close_cbk, get_header_value_cbk, read_range_cbk, user_data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_context_set_enable_network {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_INT,
            proj_h.C_POINTER,
            proj_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_context_set_enable_network");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int proj_context_set_enable_network(PJ_CONTEXT *ctx, int enabled)
     * }
     */
    public static FunctionDescriptor proj_context_set_enable_network$descriptor() {
        return proj_context_set_enable_network.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int proj_context_set_enable_network(PJ_CONTEXT *ctx, int enabled)
     * }
     */
    public static MethodHandle proj_context_set_enable_network$handle() {
        return proj_context_set_enable_network.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int proj_context_set_enable_network(PJ_CONTEXT *ctx, int enabled)
     * }
     */
    public static MemorySegment proj_context_set_enable_network$address() {
        return proj_context_set_enable_network.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int proj_context_set_enable_network(PJ_CONTEXT *ctx, int enabled)
     * }
     */
    public static int proj_context_set_enable_network(MemorySegment ctx, int enabled) {
        var mh$ = proj_context_set_enable_network.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_context_set_enable_network", ctx, enabled);
            }
            return (int)mh$.invokeExact(ctx, enabled);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_context_is_network_enabled {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_INT,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_context_is_network_enabled");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int proj_context_is_network_enabled(PJ_CONTEXT *ctx)
     * }
     */
    public static FunctionDescriptor proj_context_is_network_enabled$descriptor() {
        return proj_context_is_network_enabled.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int proj_context_is_network_enabled(PJ_CONTEXT *ctx)
     * }
     */
    public static MethodHandle proj_context_is_network_enabled$handle() {
        return proj_context_is_network_enabled.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int proj_context_is_network_enabled(PJ_CONTEXT *ctx)
     * }
     */
    public static MemorySegment proj_context_is_network_enabled$address() {
        return proj_context_is_network_enabled.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int proj_context_is_network_enabled(PJ_CONTEXT *ctx)
     * }
     */
    public static int proj_context_is_network_enabled(MemorySegment ctx) {
        var mh$ = proj_context_is_network_enabled.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_context_is_network_enabled", ctx);
            }
            return (int)mh$.invokeExact(ctx);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_context_set_url_endpoint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_context_set_url_endpoint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void proj_context_set_url_endpoint(PJ_CONTEXT *ctx, const char *url)
     * }
     */
    public static FunctionDescriptor proj_context_set_url_endpoint$descriptor() {
        return proj_context_set_url_endpoint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void proj_context_set_url_endpoint(PJ_CONTEXT *ctx, const char *url)
     * }
     */
    public static MethodHandle proj_context_set_url_endpoint$handle() {
        return proj_context_set_url_endpoint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void proj_context_set_url_endpoint(PJ_CONTEXT *ctx, const char *url)
     * }
     */
    public static MemorySegment proj_context_set_url_endpoint$address() {
        return proj_context_set_url_endpoint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void proj_context_set_url_endpoint(PJ_CONTEXT *ctx, const char *url)
     * }
     */
    public static void proj_context_set_url_endpoint(MemorySegment ctx, MemorySegment url) {
        var mh$ = proj_context_set_url_endpoint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_context_set_url_endpoint", ctx, url);
            }
            mh$.invokeExact(ctx, url);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_context_get_url_endpoint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_context_get_url_endpoint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *proj_context_get_url_endpoint(PJ_CONTEXT *ctx)
     * }
     */
    public static FunctionDescriptor proj_context_get_url_endpoint$descriptor() {
        return proj_context_get_url_endpoint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *proj_context_get_url_endpoint(PJ_CONTEXT *ctx)
     * }
     */
    public static MethodHandle proj_context_get_url_endpoint$handle() {
        return proj_context_get_url_endpoint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *proj_context_get_url_endpoint(PJ_CONTEXT *ctx)
     * }
     */
    public static MemorySegment proj_context_get_url_endpoint$address() {
        return proj_context_get_url_endpoint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *proj_context_get_url_endpoint(PJ_CONTEXT *ctx)
     * }
     */
    public static MemorySegment proj_context_get_url_endpoint(MemorySegment ctx) {
        var mh$ = proj_context_get_url_endpoint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_context_get_url_endpoint", ctx);
            }
            return (MemorySegment)mh$.invokeExact(ctx);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_context_get_user_writable_directory {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_context_get_user_writable_directory");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *proj_context_get_user_writable_directory(PJ_CONTEXT *ctx, int create)
     * }
     */
    public static FunctionDescriptor proj_context_get_user_writable_directory$descriptor() {
        return proj_context_get_user_writable_directory.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *proj_context_get_user_writable_directory(PJ_CONTEXT *ctx, int create)
     * }
     */
    public static MethodHandle proj_context_get_user_writable_directory$handle() {
        return proj_context_get_user_writable_directory.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *proj_context_get_user_writable_directory(PJ_CONTEXT *ctx, int create)
     * }
     */
    public static MemorySegment proj_context_get_user_writable_directory$address() {
        return proj_context_get_user_writable_directory.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *proj_context_get_user_writable_directory(PJ_CONTEXT *ctx, int create)
     * }
     */
    public static MemorySegment proj_context_get_user_writable_directory(MemorySegment ctx, int create) {
        var mh$ = proj_context_get_user_writable_directory.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_context_get_user_writable_directory", ctx, create);
            }
            return (MemorySegment)mh$.invokeExact(ctx, create);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_context_set_user_writable_directory {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_context_set_user_writable_directory");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void proj_context_set_user_writable_directory(PJ_CONTEXT *ctx, const char *path, int create)
     * }
     */
    public static FunctionDescriptor proj_context_set_user_writable_directory$descriptor() {
        return proj_context_set_user_writable_directory.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void proj_context_set_user_writable_directory(PJ_CONTEXT *ctx, const char *path, int create)
     * }
     */
    public static MethodHandle proj_context_set_user_writable_directory$handle() {
        return proj_context_set_user_writable_directory.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void proj_context_set_user_writable_directory(PJ_CONTEXT *ctx, const char *path, int create)
     * }
     */
    public static MemorySegment proj_context_set_user_writable_directory$address() {
        return proj_context_set_user_writable_directory.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void proj_context_set_user_writable_directory(PJ_CONTEXT *ctx, const char *path, int create)
     * }
     */
    public static void proj_context_set_user_writable_directory(MemorySegment ctx, MemorySegment path, int create) {
        var mh$ = proj_context_set_user_writable_directory.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_context_set_user_writable_directory", ctx, path, create);
            }
            mh$.invokeExact(ctx, path, create);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_grid_cache_set_enable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            proj_h.C_POINTER,
            proj_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_grid_cache_set_enable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void proj_grid_cache_set_enable(PJ_CONTEXT *ctx, int enabled)
     * }
     */
    public static FunctionDescriptor proj_grid_cache_set_enable$descriptor() {
        return proj_grid_cache_set_enable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void proj_grid_cache_set_enable(PJ_CONTEXT *ctx, int enabled)
     * }
     */
    public static MethodHandle proj_grid_cache_set_enable$handle() {
        return proj_grid_cache_set_enable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void proj_grid_cache_set_enable(PJ_CONTEXT *ctx, int enabled)
     * }
     */
    public static MemorySegment proj_grid_cache_set_enable$address() {
        return proj_grid_cache_set_enable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void proj_grid_cache_set_enable(PJ_CONTEXT *ctx, int enabled)
     * }
     */
    public static void proj_grid_cache_set_enable(MemorySegment ctx, int enabled) {
        var mh$ = proj_grid_cache_set_enable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_grid_cache_set_enable", ctx, enabled);
            }
            mh$.invokeExact(ctx, enabled);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_grid_cache_set_filename {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_grid_cache_set_filename");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void proj_grid_cache_set_filename(PJ_CONTEXT *ctx, const char *fullname)
     * }
     */
    public static FunctionDescriptor proj_grid_cache_set_filename$descriptor() {
        return proj_grid_cache_set_filename.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void proj_grid_cache_set_filename(PJ_CONTEXT *ctx, const char *fullname)
     * }
     */
    public static MethodHandle proj_grid_cache_set_filename$handle() {
        return proj_grid_cache_set_filename.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void proj_grid_cache_set_filename(PJ_CONTEXT *ctx, const char *fullname)
     * }
     */
    public static MemorySegment proj_grid_cache_set_filename$address() {
        return proj_grid_cache_set_filename.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void proj_grid_cache_set_filename(PJ_CONTEXT *ctx, const char *fullname)
     * }
     */
    public static void proj_grid_cache_set_filename(MemorySegment ctx, MemorySegment fullname) {
        var mh$ = proj_grid_cache_set_filename.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_grid_cache_set_filename", ctx, fullname);
            }
            mh$.invokeExact(ctx, fullname);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_grid_cache_set_max_size {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            proj_h.C_POINTER,
            proj_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_grid_cache_set_max_size");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void proj_grid_cache_set_max_size(PJ_CONTEXT *ctx, int max_size_MB)
     * }
     */
    public static FunctionDescriptor proj_grid_cache_set_max_size$descriptor() {
        return proj_grid_cache_set_max_size.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void proj_grid_cache_set_max_size(PJ_CONTEXT *ctx, int max_size_MB)
     * }
     */
    public static MethodHandle proj_grid_cache_set_max_size$handle() {
        return proj_grid_cache_set_max_size.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void proj_grid_cache_set_max_size(PJ_CONTEXT *ctx, int max_size_MB)
     * }
     */
    public static MemorySegment proj_grid_cache_set_max_size$address() {
        return proj_grid_cache_set_max_size.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void proj_grid_cache_set_max_size(PJ_CONTEXT *ctx, int max_size_MB)
     * }
     */
    public static void proj_grid_cache_set_max_size(MemorySegment ctx, int max_size_MB) {
        var mh$ = proj_grid_cache_set_max_size.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_grid_cache_set_max_size", ctx, max_size_MB);
            }
            mh$.invokeExact(ctx, max_size_MB);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_grid_cache_set_ttl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            proj_h.C_POINTER,
            proj_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_grid_cache_set_ttl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void proj_grid_cache_set_ttl(PJ_CONTEXT *ctx, int ttl_seconds)
     * }
     */
    public static FunctionDescriptor proj_grid_cache_set_ttl$descriptor() {
        return proj_grid_cache_set_ttl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void proj_grid_cache_set_ttl(PJ_CONTEXT *ctx, int ttl_seconds)
     * }
     */
    public static MethodHandle proj_grid_cache_set_ttl$handle() {
        return proj_grid_cache_set_ttl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void proj_grid_cache_set_ttl(PJ_CONTEXT *ctx, int ttl_seconds)
     * }
     */
    public static MemorySegment proj_grid_cache_set_ttl$address() {
        return proj_grid_cache_set_ttl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void proj_grid_cache_set_ttl(PJ_CONTEXT *ctx, int ttl_seconds)
     * }
     */
    public static void proj_grid_cache_set_ttl(MemorySegment ctx, int ttl_seconds) {
        var mh$ = proj_grid_cache_set_ttl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_grid_cache_set_ttl", ctx, ttl_seconds);
            }
            mh$.invokeExact(ctx, ttl_seconds);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_grid_cache_clear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_grid_cache_clear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void proj_grid_cache_clear(PJ_CONTEXT *ctx)
     * }
     */
    public static FunctionDescriptor proj_grid_cache_clear$descriptor() {
        return proj_grid_cache_clear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void proj_grid_cache_clear(PJ_CONTEXT *ctx)
     * }
     */
    public static MethodHandle proj_grid_cache_clear$handle() {
        return proj_grid_cache_clear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void proj_grid_cache_clear(PJ_CONTEXT *ctx)
     * }
     */
    public static MemorySegment proj_grid_cache_clear$address() {
        return proj_grid_cache_clear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void proj_grid_cache_clear(PJ_CONTEXT *ctx)
     * }
     */
    public static void proj_grid_cache_clear(MemorySegment ctx) {
        var mh$ = proj_grid_cache_clear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_grid_cache_clear", ctx);
            }
            mh$.invokeExact(ctx);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_is_download_needed {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_INT,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_is_download_needed");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int proj_is_download_needed(PJ_CONTEXT *ctx, const char *url_or_filename, int ignore_ttl_setting)
     * }
     */
    public static FunctionDescriptor proj_is_download_needed$descriptor() {
        return proj_is_download_needed.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int proj_is_download_needed(PJ_CONTEXT *ctx, const char *url_or_filename, int ignore_ttl_setting)
     * }
     */
    public static MethodHandle proj_is_download_needed$handle() {
        return proj_is_download_needed.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int proj_is_download_needed(PJ_CONTEXT *ctx, const char *url_or_filename, int ignore_ttl_setting)
     * }
     */
    public static MemorySegment proj_is_download_needed$address() {
        return proj_is_download_needed.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int proj_is_download_needed(PJ_CONTEXT *ctx, const char *url_or_filename, int ignore_ttl_setting)
     * }
     */
    public static int proj_is_download_needed(MemorySegment ctx, MemorySegment url_or_filename, int ignore_ttl_setting) {
        var mh$ = proj_is_download_needed.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_is_download_needed", ctx, url_or_filename, ignore_ttl_setting);
            }
            return (int)mh$.invokeExact(ctx, url_or_filename, ignore_ttl_setting);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_download_file {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_INT,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_INT,
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_download_file");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int proj_download_file(PJ_CONTEXT *ctx, const char *url_or_filename, int ignore_ttl_setting, int (*progress_cbk)(PJ_CONTEXT *, double, void *), void *user_data)
     * }
     */
    public static FunctionDescriptor proj_download_file$descriptor() {
        return proj_download_file.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int proj_download_file(PJ_CONTEXT *ctx, const char *url_or_filename, int ignore_ttl_setting, int (*progress_cbk)(PJ_CONTEXT *, double, void *), void *user_data)
     * }
     */
    public static MethodHandle proj_download_file$handle() {
        return proj_download_file.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int proj_download_file(PJ_CONTEXT *ctx, const char *url_or_filename, int ignore_ttl_setting, int (*progress_cbk)(PJ_CONTEXT *, double, void *), void *user_data)
     * }
     */
    public static MemorySegment proj_download_file$address() {
        return proj_download_file.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int proj_download_file(PJ_CONTEXT *ctx, const char *url_or_filename, int ignore_ttl_setting, int (*progress_cbk)(PJ_CONTEXT *, double, void *), void *user_data)
     * }
     */
    public static int proj_download_file(MemorySegment ctx, MemorySegment url_or_filename, int ignore_ttl_setting, MemorySegment progress_cbk, MemorySegment user_data) {
        var mh$ = proj_download_file.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_download_file", ctx, url_or_filename, ignore_ttl_setting, progress_cbk, user_data);
            }
            return (int)mh$.invokeExact(ctx, url_or_filename, ignore_ttl_setting, progress_cbk, user_data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_create {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_create");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ *proj_create(PJ_CONTEXT *ctx, const char *definition)
     * }
     */
    public static FunctionDescriptor proj_create$descriptor() {
        return proj_create.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ *proj_create(PJ_CONTEXT *ctx, const char *definition)
     * }
     */
    public static MethodHandle proj_create$handle() {
        return proj_create.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ *proj_create(PJ_CONTEXT *ctx, const char *definition)
     * }
     */
    public static MemorySegment proj_create$address() {
        return proj_create.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ *proj_create(PJ_CONTEXT *ctx, const char *definition)
     * }
     */
    public static MemorySegment proj_create(MemorySegment ctx, MemorySegment definition) {
        var mh$ = proj_create.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_create", ctx, definition);
            }
            return (MemorySegment)mh$.invokeExact(ctx, definition);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_create_argv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_INT,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_create_argv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ *proj_create_argv(PJ_CONTEXT *ctx, int argc, char **argv)
     * }
     */
    public static FunctionDescriptor proj_create_argv$descriptor() {
        return proj_create_argv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ *proj_create_argv(PJ_CONTEXT *ctx, int argc, char **argv)
     * }
     */
    public static MethodHandle proj_create_argv$handle() {
        return proj_create_argv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ *proj_create_argv(PJ_CONTEXT *ctx, int argc, char **argv)
     * }
     */
    public static MemorySegment proj_create_argv$address() {
        return proj_create_argv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ *proj_create_argv(PJ_CONTEXT *ctx, int argc, char **argv)
     * }
     */
    public static MemorySegment proj_create_argv(MemorySegment ctx, int argc, MemorySegment argv) {
        var mh$ = proj_create_argv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_create_argv", ctx, argc, argv);
            }
            return (MemorySegment)mh$.invokeExact(ctx, argc, argv);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_create_crs_to_crs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_create_crs_to_crs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ *proj_create_crs_to_crs(PJ_CONTEXT *ctx, const char *source_crs, const char *target_crs, PJ_AREA *area)
     * }
     */
    public static FunctionDescriptor proj_create_crs_to_crs$descriptor() {
        return proj_create_crs_to_crs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ *proj_create_crs_to_crs(PJ_CONTEXT *ctx, const char *source_crs, const char *target_crs, PJ_AREA *area)
     * }
     */
    public static MethodHandle proj_create_crs_to_crs$handle() {
        return proj_create_crs_to_crs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ *proj_create_crs_to_crs(PJ_CONTEXT *ctx, const char *source_crs, const char *target_crs, PJ_AREA *area)
     * }
     */
    public static MemorySegment proj_create_crs_to_crs$address() {
        return proj_create_crs_to_crs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ *proj_create_crs_to_crs(PJ_CONTEXT *ctx, const char *source_crs, const char *target_crs, PJ_AREA *area)
     * }
     */
    public static MemorySegment proj_create_crs_to_crs(MemorySegment ctx, MemorySegment source_crs, MemorySegment target_crs, MemorySegment area) {
        var mh$ = proj_create_crs_to_crs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_create_crs_to_crs", ctx, source_crs, target_crs, area);
            }
            return (MemorySegment)mh$.invokeExact(ctx, source_crs, target_crs, area);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_create_crs_to_crs_from_pj {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_create_crs_to_crs_from_pj");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ *proj_create_crs_to_crs_from_pj(PJ_CONTEXT *ctx, const PJ *source_crs, const PJ *target_crs, PJ_AREA *area, const char *const *options)
     * }
     */
    public static FunctionDescriptor proj_create_crs_to_crs_from_pj$descriptor() {
        return proj_create_crs_to_crs_from_pj.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ *proj_create_crs_to_crs_from_pj(PJ_CONTEXT *ctx, const PJ *source_crs, const PJ *target_crs, PJ_AREA *area, const char *const *options)
     * }
     */
    public static MethodHandle proj_create_crs_to_crs_from_pj$handle() {
        return proj_create_crs_to_crs_from_pj.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ *proj_create_crs_to_crs_from_pj(PJ_CONTEXT *ctx, const PJ *source_crs, const PJ *target_crs, PJ_AREA *area, const char *const *options)
     * }
     */
    public static MemorySegment proj_create_crs_to_crs_from_pj$address() {
        return proj_create_crs_to_crs_from_pj.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ *proj_create_crs_to_crs_from_pj(PJ_CONTEXT *ctx, const PJ *source_crs, const PJ *target_crs, PJ_AREA *area, const char *const *options)
     * }
     */
    public static MemorySegment proj_create_crs_to_crs_from_pj(MemorySegment ctx, MemorySegment source_crs, MemorySegment target_crs, MemorySegment area, MemorySegment options) {
        var mh$ = proj_create_crs_to_crs_from_pj.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_create_crs_to_crs_from_pj", ctx, source_crs, target_crs, area, options);
            }
            return (MemorySegment)mh$.invokeExact(ctx, source_crs, target_crs, area, options);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_normalize_for_visualization {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_normalize_for_visualization");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ *proj_normalize_for_visualization(PJ_CONTEXT *ctx, const PJ *obj)
     * }
     */
    public static FunctionDescriptor proj_normalize_for_visualization$descriptor() {
        return proj_normalize_for_visualization.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ *proj_normalize_for_visualization(PJ_CONTEXT *ctx, const PJ *obj)
     * }
     */
    public static MethodHandle proj_normalize_for_visualization$handle() {
        return proj_normalize_for_visualization.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ *proj_normalize_for_visualization(PJ_CONTEXT *ctx, const PJ *obj)
     * }
     */
    public static MemorySegment proj_normalize_for_visualization$address() {
        return proj_normalize_for_visualization.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ *proj_normalize_for_visualization(PJ_CONTEXT *ctx, const PJ *obj)
     * }
     */
    public static MemorySegment proj_normalize_for_visualization(MemorySegment ctx, MemorySegment obj) {
        var mh$ = proj_normalize_for_visualization.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_normalize_for_visualization", ctx, obj);
            }
            return (MemorySegment)mh$.invokeExact(ctx, obj);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_assign_context {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_assign_context");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void proj_assign_context(PJ *pj, PJ_CONTEXT *ctx)
     * }
     */
    public static FunctionDescriptor proj_assign_context$descriptor() {
        return proj_assign_context.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void proj_assign_context(PJ *pj, PJ_CONTEXT *ctx)
     * }
     */
    public static MethodHandle proj_assign_context$handle() {
        return proj_assign_context.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void proj_assign_context(PJ *pj, PJ_CONTEXT *ctx)
     * }
     */
    public static MemorySegment proj_assign_context$address() {
        return proj_assign_context.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void proj_assign_context(PJ *pj, PJ_CONTEXT *ctx)
     * }
     */
    public static void proj_assign_context(MemorySegment pj, MemorySegment ctx) {
        var mh$ = proj_assign_context.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_assign_context", pj, ctx);
            }
            mh$.invokeExact(pj, ctx);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_destroy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_destroy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ *proj_destroy(PJ *P)
     * }
     */
    public static FunctionDescriptor proj_destroy$descriptor() {
        return proj_destroy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ *proj_destroy(PJ *P)
     * }
     */
    public static MethodHandle proj_destroy$handle() {
        return proj_destroy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ *proj_destroy(PJ *P)
     * }
     */
    public static MemorySegment proj_destroy$address() {
        return proj_destroy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ *proj_destroy(PJ *P)
     * }
     */
    public static MemorySegment proj_destroy(MemorySegment P) {
        var mh$ = proj_destroy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_destroy", P);
            }
            return (MemorySegment)mh$.invokeExact(P);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_area_create {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_area_create");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ_AREA *proj_area_create()
     * }
     */
    public static FunctionDescriptor proj_area_create$descriptor() {
        return proj_area_create.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ_AREA *proj_area_create()
     * }
     */
    public static MethodHandle proj_area_create$handle() {
        return proj_area_create.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ_AREA *proj_area_create()
     * }
     */
    public static MemorySegment proj_area_create$address() {
        return proj_area_create.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ_AREA *proj_area_create()
     * }
     */
    public static MemorySegment proj_area_create() {
        var mh$ = proj_area_create.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_area_create");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_area_set_bbox {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            proj_h.C_POINTER,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_area_set_bbox");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void proj_area_set_bbox(PJ_AREA *area, double west_lon_degree, double south_lat_degree, double east_lon_degree, double north_lat_degree)
     * }
     */
    public static FunctionDescriptor proj_area_set_bbox$descriptor() {
        return proj_area_set_bbox.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void proj_area_set_bbox(PJ_AREA *area, double west_lon_degree, double south_lat_degree, double east_lon_degree, double north_lat_degree)
     * }
     */
    public static MethodHandle proj_area_set_bbox$handle() {
        return proj_area_set_bbox.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void proj_area_set_bbox(PJ_AREA *area, double west_lon_degree, double south_lat_degree, double east_lon_degree, double north_lat_degree)
     * }
     */
    public static MemorySegment proj_area_set_bbox$address() {
        return proj_area_set_bbox.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void proj_area_set_bbox(PJ_AREA *area, double west_lon_degree, double south_lat_degree, double east_lon_degree, double north_lat_degree)
     * }
     */
    public static void proj_area_set_bbox(MemorySegment area, double west_lon_degree, double south_lat_degree, double east_lon_degree, double north_lat_degree) {
        var mh$ = proj_area_set_bbox.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_area_set_bbox", area, west_lon_degree, south_lat_degree, east_lon_degree, north_lat_degree);
            }
            mh$.invokeExact(area, west_lon_degree, south_lat_degree, east_lon_degree, north_lat_degree);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_area_set_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_area_set_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void proj_area_set_name(PJ_AREA *area, const char *name)
     * }
     */
    public static FunctionDescriptor proj_area_set_name$descriptor() {
        return proj_area_set_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void proj_area_set_name(PJ_AREA *area, const char *name)
     * }
     */
    public static MethodHandle proj_area_set_name$handle() {
        return proj_area_set_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void proj_area_set_name(PJ_AREA *area, const char *name)
     * }
     */
    public static MemorySegment proj_area_set_name$address() {
        return proj_area_set_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void proj_area_set_name(PJ_AREA *area, const char *name)
     * }
     */
    public static void proj_area_set_name(MemorySegment area, MemorySegment name) {
        var mh$ = proj_area_set_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_area_set_name", area, name);
            }
            mh$.invokeExact(area, name);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_area_destroy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_area_destroy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void proj_area_destroy(PJ_AREA *area)
     * }
     */
    public static FunctionDescriptor proj_area_destroy$descriptor() {
        return proj_area_destroy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void proj_area_destroy(PJ_AREA *area)
     * }
     */
    public static MethodHandle proj_area_destroy$handle() {
        return proj_area_destroy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void proj_area_destroy(PJ_AREA *area)
     * }
     */
    public static MemorySegment proj_area_destroy$address() {
        return proj_area_destroy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void proj_area_destroy(PJ_AREA *area)
     * }
     */
    public static void proj_area_destroy(MemorySegment area) {
        var mh$ = proj_area_destroy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_area_destroy", area);
            }
            mh$.invokeExact(area);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int PJ_FWD = (int)1L;
    /**
     * {@snippet lang=c :
     * enum PJ_DIRECTION.PJ_FWD = 1
     * }
     */
    public static int PJ_FWD() {
        return PJ_FWD;
    }
    private static final int PJ_IDENT = (int)0L;
    /**
     * {@snippet lang=c :
     * enum PJ_DIRECTION.PJ_IDENT = 0
     * }
     */
    public static int PJ_IDENT() {
        return PJ_IDENT;
    }
    private static final int PJ_INV = (int)-1L;
    /**
     * {@snippet lang=c :
     * enum PJ_DIRECTION.PJ_INV = -1
     * }
     */
    public static int PJ_INV() {
        return PJ_INV;
    }

    private static class proj_angular_input {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_INT,
            proj_h.C_POINTER,
            proj_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_angular_input");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int proj_angular_input(PJ *P, enum PJ_DIRECTION dir)
     * }
     */
    public static FunctionDescriptor proj_angular_input$descriptor() {
        return proj_angular_input.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int proj_angular_input(PJ *P, enum PJ_DIRECTION dir)
     * }
     */
    public static MethodHandle proj_angular_input$handle() {
        return proj_angular_input.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int proj_angular_input(PJ *P, enum PJ_DIRECTION dir)
     * }
     */
    public static MemorySegment proj_angular_input$address() {
        return proj_angular_input.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int proj_angular_input(PJ *P, enum PJ_DIRECTION dir)
     * }
     */
    public static int proj_angular_input(MemorySegment P, int dir) {
        var mh$ = proj_angular_input.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_angular_input", P, dir);
            }
            return (int)mh$.invokeExact(P, dir);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_angular_output {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_INT,
            proj_h.C_POINTER,
            proj_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_angular_output");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int proj_angular_output(PJ *P, enum PJ_DIRECTION dir)
     * }
     */
    public static FunctionDescriptor proj_angular_output$descriptor() {
        return proj_angular_output.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int proj_angular_output(PJ *P, enum PJ_DIRECTION dir)
     * }
     */
    public static MethodHandle proj_angular_output$handle() {
        return proj_angular_output.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int proj_angular_output(PJ *P, enum PJ_DIRECTION dir)
     * }
     */
    public static MemorySegment proj_angular_output$address() {
        return proj_angular_output.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int proj_angular_output(PJ *P, enum PJ_DIRECTION dir)
     * }
     */
    public static int proj_angular_output(MemorySegment P, int dir) {
        var mh$ = proj_angular_output.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_angular_output", P, dir);
            }
            return (int)mh$.invokeExact(P, dir);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_degree_input {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_INT,
            proj_h.C_POINTER,
            proj_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_degree_input");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int proj_degree_input(PJ *P, enum PJ_DIRECTION dir)
     * }
     */
    public static FunctionDescriptor proj_degree_input$descriptor() {
        return proj_degree_input.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int proj_degree_input(PJ *P, enum PJ_DIRECTION dir)
     * }
     */
    public static MethodHandle proj_degree_input$handle() {
        return proj_degree_input.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int proj_degree_input(PJ *P, enum PJ_DIRECTION dir)
     * }
     */
    public static MemorySegment proj_degree_input$address() {
        return proj_degree_input.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int proj_degree_input(PJ *P, enum PJ_DIRECTION dir)
     * }
     */
    public static int proj_degree_input(MemorySegment P, int dir) {
        var mh$ = proj_degree_input.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_degree_input", P, dir);
            }
            return (int)mh$.invokeExact(P, dir);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_degree_output {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_INT,
            proj_h.C_POINTER,
            proj_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_degree_output");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int proj_degree_output(PJ *P, enum PJ_DIRECTION dir)
     * }
     */
    public static FunctionDescriptor proj_degree_output$descriptor() {
        return proj_degree_output.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int proj_degree_output(PJ *P, enum PJ_DIRECTION dir)
     * }
     */
    public static MethodHandle proj_degree_output$handle() {
        return proj_degree_output.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int proj_degree_output(PJ *P, enum PJ_DIRECTION dir)
     * }
     */
    public static MemorySegment proj_degree_output$address() {
        return proj_degree_output.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int proj_degree_output(PJ *P, enum PJ_DIRECTION dir)
     * }
     */
    public static int proj_degree_output(MemorySegment P, int dir) {
        var mh$ = proj_degree_output.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_degree_output", P, dir);
            }
            return (int)mh$.invokeExact(P, dir);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_trans {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            PJ_COORD.layout(),
            proj_h.C_POINTER,
            proj_h.C_INT,
            PJ_COORD.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_trans");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ_COORD proj_trans(PJ *P, PJ_DIRECTION direction, PJ_COORD coord)
     * }
     */
    public static FunctionDescriptor proj_trans$descriptor() {
        return proj_trans.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ_COORD proj_trans(PJ *P, PJ_DIRECTION direction, PJ_COORD coord)
     * }
     */
    public static MethodHandle proj_trans$handle() {
        return proj_trans.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ_COORD proj_trans(PJ *P, PJ_DIRECTION direction, PJ_COORD coord)
     * }
     */
    public static MemorySegment proj_trans$address() {
        return proj_trans.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ_COORD proj_trans(PJ *P, PJ_DIRECTION direction, PJ_COORD coord)
     * }
     */
    public static MemorySegment proj_trans(SegmentAllocator allocator, MemorySegment P, int direction, MemorySegment coord) {
        var mh$ = proj_trans.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_trans", allocator, P, direction, coord);
            }
            return (MemorySegment)mh$.invokeExact(allocator, P, direction, coord);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_trans_get_last_used_operation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_trans_get_last_used_operation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ *proj_trans_get_last_used_operation(PJ *P)
     * }
     */
    public static FunctionDescriptor proj_trans_get_last_used_operation$descriptor() {
        return proj_trans_get_last_used_operation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ *proj_trans_get_last_used_operation(PJ *P)
     * }
     */
    public static MethodHandle proj_trans_get_last_used_operation$handle() {
        return proj_trans_get_last_used_operation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ *proj_trans_get_last_used_operation(PJ *P)
     * }
     */
    public static MemorySegment proj_trans_get_last_used_operation$address() {
        return proj_trans_get_last_used_operation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ *proj_trans_get_last_used_operation(PJ *P)
     * }
     */
    public static MemorySegment proj_trans_get_last_used_operation(MemorySegment P) {
        var mh$ = proj_trans_get_last_used_operation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_trans_get_last_used_operation", P);
            }
            return (MemorySegment)mh$.invokeExact(P);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_trans_array {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_INT,
            proj_h.C_POINTER,
            proj_h.C_INT,
            proj_h.C_LONG,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_trans_array");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int proj_trans_array(PJ *P, PJ_DIRECTION direction, size_t n, PJ_COORD *coord)
     * }
     */
    public static FunctionDescriptor proj_trans_array$descriptor() {
        return proj_trans_array.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int proj_trans_array(PJ *P, PJ_DIRECTION direction, size_t n, PJ_COORD *coord)
     * }
     */
    public static MethodHandle proj_trans_array$handle() {
        return proj_trans_array.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int proj_trans_array(PJ *P, PJ_DIRECTION direction, size_t n, PJ_COORD *coord)
     * }
     */
    public static MemorySegment proj_trans_array$address() {
        return proj_trans_array.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int proj_trans_array(PJ *P, PJ_DIRECTION direction, size_t n, PJ_COORD *coord)
     * }
     */
    public static int proj_trans_array(MemorySegment P, int direction, long n, MemorySegment coord) {
        var mh$ = proj_trans_array.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_trans_array", P, direction, n, coord);
            }
            return (int)mh$.invokeExact(P, direction, n, coord);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_trans_generic {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_LONG,
            proj_h.C_POINTER,
            proj_h.C_INT,
            proj_h.C_POINTER,
            proj_h.C_LONG,
            proj_h.C_LONG,
            proj_h.C_POINTER,
            proj_h.C_LONG,
            proj_h.C_LONG,
            proj_h.C_POINTER,
            proj_h.C_LONG,
            proj_h.C_LONG,
            proj_h.C_POINTER,
            proj_h.C_LONG,
            proj_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_trans_generic");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t proj_trans_generic(PJ *P, PJ_DIRECTION direction, double *x, size_t sx, size_t nx, double *y, size_t sy, size_t ny, double *z, size_t sz, size_t nz, double *t, size_t st, size_t nt)
     * }
     */
    public static FunctionDescriptor proj_trans_generic$descriptor() {
        return proj_trans_generic.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t proj_trans_generic(PJ *P, PJ_DIRECTION direction, double *x, size_t sx, size_t nx, double *y, size_t sy, size_t ny, double *z, size_t sz, size_t nz, double *t, size_t st, size_t nt)
     * }
     */
    public static MethodHandle proj_trans_generic$handle() {
        return proj_trans_generic.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t proj_trans_generic(PJ *P, PJ_DIRECTION direction, double *x, size_t sx, size_t nx, double *y, size_t sy, size_t ny, double *z, size_t sz, size_t nz, double *t, size_t st, size_t nt)
     * }
     */
    public static MemorySegment proj_trans_generic$address() {
        return proj_trans_generic.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t proj_trans_generic(PJ *P, PJ_DIRECTION direction, double *x, size_t sx, size_t nx, double *y, size_t sy, size_t ny, double *z, size_t sz, size_t nz, double *t, size_t st, size_t nt)
     * }
     */
    public static long proj_trans_generic(MemorySegment P, int direction, MemorySegment x, long sx, long nx, MemorySegment y, long sy, long ny, MemorySegment z, long sz, long nz, MemorySegment t, long st, long nt) {
        var mh$ = proj_trans_generic.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_trans_generic", P, direction, x, sx, nx, y, sy, ny, z, sz, nz, t, st, nt);
            }
            return (long)mh$.invokeExact(P, direction, x, sx, nx, y, sy, ny, z, sz, nz, t, st, nt);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_trans_bounds {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_INT,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_INT,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_trans_bounds");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int proj_trans_bounds(PJ_CONTEXT *context, PJ *P, PJ_DIRECTION direction, double xmin, double ymin, double xmax, double ymax, double *out_xmin, double *out_ymin, double *out_xmax, double *out_ymax, int densify_pts)
     * }
     */
    public static FunctionDescriptor proj_trans_bounds$descriptor() {
        return proj_trans_bounds.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int proj_trans_bounds(PJ_CONTEXT *context, PJ *P, PJ_DIRECTION direction, double xmin, double ymin, double xmax, double ymax, double *out_xmin, double *out_ymin, double *out_xmax, double *out_ymax, int densify_pts)
     * }
     */
    public static MethodHandle proj_trans_bounds$handle() {
        return proj_trans_bounds.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int proj_trans_bounds(PJ_CONTEXT *context, PJ *P, PJ_DIRECTION direction, double xmin, double ymin, double xmax, double ymax, double *out_xmin, double *out_ymin, double *out_xmax, double *out_ymax, int densify_pts)
     * }
     */
    public static MemorySegment proj_trans_bounds$address() {
        return proj_trans_bounds.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int proj_trans_bounds(PJ_CONTEXT *context, PJ *P, PJ_DIRECTION direction, double xmin, double ymin, double xmax, double ymax, double *out_xmin, double *out_ymin, double *out_xmax, double *out_ymax, int densify_pts)
     * }
     */
    public static int proj_trans_bounds(MemorySegment context, MemorySegment P, int direction, double xmin, double ymin, double xmax, double ymax, MemorySegment out_xmin, MemorySegment out_ymin, MemorySegment out_xmax, MemorySegment out_ymax, int densify_pts) {
        var mh$ = proj_trans_bounds.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_trans_bounds", context, P, direction, xmin, ymin, xmax, ymax, out_xmin, out_ymin, out_xmax, out_ymax, densify_pts);
            }
            return (int)mh$.invokeExact(context, P, direction, xmin, ymin, xmax, ymax, out_xmin, out_ymin, out_xmax, out_ymax, densify_pts);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_trans_bounds_3D {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_INT,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_INT,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_trans_bounds_3D");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int proj_trans_bounds_3D(PJ_CONTEXT *context, PJ *P, PJ_DIRECTION direction, const double xmin, const double ymin, const double zmin, const double xmax, const double ymax, const double zmax, double *out_xmin, double *out_ymin, double *out_zmin, double *out_xmax, double *out_ymax, double *out_zmax, const int densify_pts)
     * }
     */
    public static FunctionDescriptor proj_trans_bounds_3D$descriptor() {
        return proj_trans_bounds_3D.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int proj_trans_bounds_3D(PJ_CONTEXT *context, PJ *P, PJ_DIRECTION direction, const double xmin, const double ymin, const double zmin, const double xmax, const double ymax, const double zmax, double *out_xmin, double *out_ymin, double *out_zmin, double *out_xmax, double *out_ymax, double *out_zmax, const int densify_pts)
     * }
     */
    public static MethodHandle proj_trans_bounds_3D$handle() {
        return proj_trans_bounds_3D.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int proj_trans_bounds_3D(PJ_CONTEXT *context, PJ *P, PJ_DIRECTION direction, const double xmin, const double ymin, const double zmin, const double xmax, const double ymax, const double zmax, double *out_xmin, double *out_ymin, double *out_zmin, double *out_xmax, double *out_ymax, double *out_zmax, const int densify_pts)
     * }
     */
    public static MemorySegment proj_trans_bounds_3D$address() {
        return proj_trans_bounds_3D.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int proj_trans_bounds_3D(PJ_CONTEXT *context, PJ *P, PJ_DIRECTION direction, const double xmin, const double ymin, const double zmin, const double xmax, const double ymax, const double zmax, double *out_xmin, double *out_ymin, double *out_zmin, double *out_xmax, double *out_ymax, double *out_zmax, const int densify_pts)
     * }
     */
    public static int proj_trans_bounds_3D(MemorySegment context, MemorySegment P, int direction, double xmin, double ymin, double zmin, double xmax, double ymax, double zmax, MemorySegment out_xmin, MemorySegment out_ymin, MemorySegment out_zmin, MemorySegment out_xmax, MemorySegment out_ymax, MemorySegment out_zmax, int densify_pts) {
        var mh$ = proj_trans_bounds_3D.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_trans_bounds_3D", context, P, direction, xmin, ymin, zmin, xmax, ymax, zmax, out_xmin, out_ymin, out_zmin, out_xmax, out_ymax, out_zmax, densify_pts);
            }
            return (int)mh$.invokeExact(context, P, direction, xmin, ymin, zmin, xmax, ymax, zmax, out_xmin, out_ymin, out_zmin, out_xmax, out_ymax, out_zmax, densify_pts);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_coord {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            PJ_COORD.layout(),
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_coord");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ_COORD proj_coord(double x, double y, double z, double t)
     * }
     */
    public static FunctionDescriptor proj_coord$descriptor() {
        return proj_coord.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ_COORD proj_coord(double x, double y, double z, double t)
     * }
     */
    public static MethodHandle proj_coord$handle() {
        return proj_coord.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ_COORD proj_coord(double x, double y, double z, double t)
     * }
     */
    public static MemorySegment proj_coord$address() {
        return proj_coord.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ_COORD proj_coord(double x, double y, double z, double t)
     * }
     */
    public static MemorySegment proj_coord(SegmentAllocator allocator, double x, double y, double z, double t) {
        var mh$ = proj_coord.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_coord", allocator, x, y, z, t);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x, y, z, t);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_roundtrip {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            proj_h.C_INT,
            proj_h.C_INT,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_roundtrip");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double proj_roundtrip(PJ *P, PJ_DIRECTION direction, int n, PJ_COORD *coord)
     * }
     */
    public static FunctionDescriptor proj_roundtrip$descriptor() {
        return proj_roundtrip.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double proj_roundtrip(PJ *P, PJ_DIRECTION direction, int n, PJ_COORD *coord)
     * }
     */
    public static MethodHandle proj_roundtrip$handle() {
        return proj_roundtrip.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double proj_roundtrip(PJ *P, PJ_DIRECTION direction, int n, PJ_COORD *coord)
     * }
     */
    public static MemorySegment proj_roundtrip$address() {
        return proj_roundtrip.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double proj_roundtrip(PJ *P, PJ_DIRECTION direction, int n, PJ_COORD *coord)
     * }
     */
    public static double proj_roundtrip(MemorySegment P, int direction, int n, MemorySegment coord) {
        var mh$ = proj_roundtrip.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_roundtrip", P, direction, n, coord);
            }
            return (double)mh$.invokeExact(P, direction, n, coord);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_lp_dist {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            PJ_COORD.layout(),
            PJ_COORD.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_lp_dist");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double proj_lp_dist(const PJ *P, PJ_COORD a, PJ_COORD b)
     * }
     */
    public static FunctionDescriptor proj_lp_dist$descriptor() {
        return proj_lp_dist.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double proj_lp_dist(const PJ *P, PJ_COORD a, PJ_COORD b)
     * }
     */
    public static MethodHandle proj_lp_dist$handle() {
        return proj_lp_dist.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double proj_lp_dist(const PJ *P, PJ_COORD a, PJ_COORD b)
     * }
     */
    public static MemorySegment proj_lp_dist$address() {
        return proj_lp_dist.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double proj_lp_dist(const PJ *P, PJ_COORD a, PJ_COORD b)
     * }
     */
    public static double proj_lp_dist(MemorySegment P, MemorySegment a, MemorySegment b) {
        var mh$ = proj_lp_dist.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_lp_dist", P, a, b);
            }
            return (double)mh$.invokeExact(P, a, b);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_lpz_dist {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            PJ_COORD.layout(),
            PJ_COORD.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_lpz_dist");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double proj_lpz_dist(const PJ *P, PJ_COORD a, PJ_COORD b)
     * }
     */
    public static FunctionDescriptor proj_lpz_dist$descriptor() {
        return proj_lpz_dist.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double proj_lpz_dist(const PJ *P, PJ_COORD a, PJ_COORD b)
     * }
     */
    public static MethodHandle proj_lpz_dist$handle() {
        return proj_lpz_dist.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double proj_lpz_dist(const PJ *P, PJ_COORD a, PJ_COORD b)
     * }
     */
    public static MemorySegment proj_lpz_dist$address() {
        return proj_lpz_dist.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double proj_lpz_dist(const PJ *P, PJ_COORD a, PJ_COORD b)
     * }
     */
    public static double proj_lpz_dist(MemorySegment P, MemorySegment a, MemorySegment b) {
        var mh$ = proj_lpz_dist.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_lpz_dist", P, a, b);
            }
            return (double)mh$.invokeExact(P, a, b);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_xy_dist {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_DOUBLE,
            PJ_COORD.layout(),
            PJ_COORD.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_xy_dist");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double proj_xy_dist(PJ_COORD a, PJ_COORD b)
     * }
     */
    public static FunctionDescriptor proj_xy_dist$descriptor() {
        return proj_xy_dist.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double proj_xy_dist(PJ_COORD a, PJ_COORD b)
     * }
     */
    public static MethodHandle proj_xy_dist$handle() {
        return proj_xy_dist.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double proj_xy_dist(PJ_COORD a, PJ_COORD b)
     * }
     */
    public static MemorySegment proj_xy_dist$address() {
        return proj_xy_dist.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double proj_xy_dist(PJ_COORD a, PJ_COORD b)
     * }
     */
    public static double proj_xy_dist(MemorySegment a, MemorySegment b) {
        var mh$ = proj_xy_dist.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_xy_dist", a, b);
            }
            return (double)mh$.invokeExact(a, b);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_xyz_dist {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_DOUBLE,
            PJ_COORD.layout(),
            PJ_COORD.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_xyz_dist");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double proj_xyz_dist(PJ_COORD a, PJ_COORD b)
     * }
     */
    public static FunctionDescriptor proj_xyz_dist$descriptor() {
        return proj_xyz_dist.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double proj_xyz_dist(PJ_COORD a, PJ_COORD b)
     * }
     */
    public static MethodHandle proj_xyz_dist$handle() {
        return proj_xyz_dist.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double proj_xyz_dist(PJ_COORD a, PJ_COORD b)
     * }
     */
    public static MemorySegment proj_xyz_dist$address() {
        return proj_xyz_dist.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double proj_xyz_dist(PJ_COORD a, PJ_COORD b)
     * }
     */
    public static double proj_xyz_dist(MemorySegment a, MemorySegment b) {
        var mh$ = proj_xyz_dist.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_xyz_dist", a, b);
            }
            return (double)mh$.invokeExact(a, b);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_geod {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            PJ_COORD.layout(),
            proj_h.C_POINTER,
            PJ_COORD.layout(),
            PJ_COORD.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_geod");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ_COORD proj_geod(const PJ *P, PJ_COORD a, PJ_COORD b)
     * }
     */
    public static FunctionDescriptor proj_geod$descriptor() {
        return proj_geod.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ_COORD proj_geod(const PJ *P, PJ_COORD a, PJ_COORD b)
     * }
     */
    public static MethodHandle proj_geod$handle() {
        return proj_geod.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ_COORD proj_geod(const PJ *P, PJ_COORD a, PJ_COORD b)
     * }
     */
    public static MemorySegment proj_geod$address() {
        return proj_geod.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ_COORD proj_geod(const PJ *P, PJ_COORD a, PJ_COORD b)
     * }
     */
    public static MemorySegment proj_geod(SegmentAllocator allocator, MemorySegment P, MemorySegment a, MemorySegment b) {
        var mh$ = proj_geod.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_geod", allocator, P, a, b);
            }
            return (MemorySegment)mh$.invokeExact(allocator, P, a, b);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_context_errno {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_INT,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_context_errno");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int proj_context_errno(PJ_CONTEXT *ctx)
     * }
     */
    public static FunctionDescriptor proj_context_errno$descriptor() {
        return proj_context_errno.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int proj_context_errno(PJ_CONTEXT *ctx)
     * }
     */
    public static MethodHandle proj_context_errno$handle() {
        return proj_context_errno.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int proj_context_errno(PJ_CONTEXT *ctx)
     * }
     */
    public static MemorySegment proj_context_errno$address() {
        return proj_context_errno.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int proj_context_errno(PJ_CONTEXT *ctx)
     * }
     */
    public static int proj_context_errno(MemorySegment ctx) {
        var mh$ = proj_context_errno.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_context_errno", ctx);
            }
            return (int)mh$.invokeExact(ctx);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_errno {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_INT,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_errno");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int proj_errno(const PJ *P)
     * }
     */
    public static FunctionDescriptor proj_errno$descriptor() {
        return proj_errno.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int proj_errno(const PJ *P)
     * }
     */
    public static MethodHandle proj_errno$handle() {
        return proj_errno.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int proj_errno(const PJ *P)
     * }
     */
    public static MemorySegment proj_errno$address() {
        return proj_errno.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int proj_errno(const PJ *P)
     * }
     */
    public static int proj_errno(MemorySegment P) {
        var mh$ = proj_errno.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_errno", P);
            }
            return (int)mh$.invokeExact(P);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_errno_set {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_INT,
            proj_h.C_POINTER,
            proj_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_errno_set");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int proj_errno_set(const PJ *P, int err)
     * }
     */
    public static FunctionDescriptor proj_errno_set$descriptor() {
        return proj_errno_set.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int proj_errno_set(const PJ *P, int err)
     * }
     */
    public static MethodHandle proj_errno_set$handle() {
        return proj_errno_set.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int proj_errno_set(const PJ *P, int err)
     * }
     */
    public static MemorySegment proj_errno_set$address() {
        return proj_errno_set.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int proj_errno_set(const PJ *P, int err)
     * }
     */
    public static int proj_errno_set(MemorySegment P, int err) {
        var mh$ = proj_errno_set.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_errno_set", P, err);
            }
            return (int)mh$.invokeExact(P, err);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_errno_reset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_INT,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_errno_reset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int proj_errno_reset(const PJ *P)
     * }
     */
    public static FunctionDescriptor proj_errno_reset$descriptor() {
        return proj_errno_reset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int proj_errno_reset(const PJ *P)
     * }
     */
    public static MethodHandle proj_errno_reset$handle() {
        return proj_errno_reset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int proj_errno_reset(const PJ *P)
     * }
     */
    public static MemorySegment proj_errno_reset$address() {
        return proj_errno_reset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int proj_errno_reset(const PJ *P)
     * }
     */
    public static int proj_errno_reset(MemorySegment P) {
        var mh$ = proj_errno_reset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_errno_reset", P);
            }
            return (int)mh$.invokeExact(P);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_errno_restore {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_INT,
            proj_h.C_POINTER,
            proj_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_errno_restore");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int proj_errno_restore(const PJ *P, int err)
     * }
     */
    public static FunctionDescriptor proj_errno_restore$descriptor() {
        return proj_errno_restore.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int proj_errno_restore(const PJ *P, int err)
     * }
     */
    public static MethodHandle proj_errno_restore$handle() {
        return proj_errno_restore.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int proj_errno_restore(const PJ *P, int err)
     * }
     */
    public static MemorySegment proj_errno_restore$address() {
        return proj_errno_restore.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int proj_errno_restore(const PJ *P, int err)
     * }
     */
    public static int proj_errno_restore(MemorySegment P, int err) {
        var mh$ = proj_errno_restore.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_errno_restore", P, err);
            }
            return (int)mh$.invokeExact(P, err);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_errno_string {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_errno_string");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *proj_errno_string(int err)
     * }
     */
    public static FunctionDescriptor proj_errno_string$descriptor() {
        return proj_errno_string.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *proj_errno_string(int err)
     * }
     */
    public static MethodHandle proj_errno_string$handle() {
        return proj_errno_string.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *proj_errno_string(int err)
     * }
     */
    public static MemorySegment proj_errno_string$address() {
        return proj_errno_string.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *proj_errno_string(int err)
     * }
     */
    public static MemorySegment proj_errno_string(int err) {
        var mh$ = proj_errno_string.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_errno_string", err);
            }
            return (MemorySegment)mh$.invokeExact(err);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_context_errno_string {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_context_errno_string");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *proj_context_errno_string(PJ_CONTEXT *ctx, int err)
     * }
     */
    public static FunctionDescriptor proj_context_errno_string$descriptor() {
        return proj_context_errno_string.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *proj_context_errno_string(PJ_CONTEXT *ctx, int err)
     * }
     */
    public static MethodHandle proj_context_errno_string$handle() {
        return proj_context_errno_string.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *proj_context_errno_string(PJ_CONTEXT *ctx, int err)
     * }
     */
    public static MemorySegment proj_context_errno_string$address() {
        return proj_context_errno_string.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *proj_context_errno_string(PJ_CONTEXT *ctx, int err)
     * }
     */
    public static MemorySegment proj_context_errno_string(MemorySegment ctx, int err) {
        var mh$ = proj_context_errno_string.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_context_errno_string", ctx, err);
            }
            return (MemorySegment)mh$.invokeExact(ctx, err);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_log_level {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_INT,
            proj_h.C_POINTER,
            proj_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_log_level");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ_LOG_LEVEL proj_log_level(PJ_CONTEXT *ctx, PJ_LOG_LEVEL log_level)
     * }
     */
    public static FunctionDescriptor proj_log_level$descriptor() {
        return proj_log_level.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ_LOG_LEVEL proj_log_level(PJ_CONTEXT *ctx, PJ_LOG_LEVEL log_level)
     * }
     */
    public static MethodHandle proj_log_level$handle() {
        return proj_log_level.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ_LOG_LEVEL proj_log_level(PJ_CONTEXT *ctx, PJ_LOG_LEVEL log_level)
     * }
     */
    public static MemorySegment proj_log_level$address() {
        return proj_log_level.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ_LOG_LEVEL proj_log_level(PJ_CONTEXT *ctx, PJ_LOG_LEVEL log_level)
     * }
     */
    public static int proj_log_level(MemorySegment ctx, int log_level) {
        var mh$ = proj_log_level.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_log_level", ctx, log_level);
            }
            return (int)mh$.invokeExact(ctx, log_level);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_log_func {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_log_func");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void proj_log_func(PJ_CONTEXT *ctx, void *app_data, PJ_LOG_FUNCTION logf)
     * }
     */
    public static FunctionDescriptor proj_log_func$descriptor() {
        return proj_log_func.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void proj_log_func(PJ_CONTEXT *ctx, void *app_data, PJ_LOG_FUNCTION logf)
     * }
     */
    public static MethodHandle proj_log_func$handle() {
        return proj_log_func.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void proj_log_func(PJ_CONTEXT *ctx, void *app_data, PJ_LOG_FUNCTION logf)
     * }
     */
    public static MemorySegment proj_log_func$address() {
        return proj_log_func.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void proj_log_func(PJ_CONTEXT *ctx, void *app_data, PJ_LOG_FUNCTION logf)
     * }
     */
    public static void proj_log_func(MemorySegment ctx, MemorySegment app_data, MemorySegment logf) {
        var mh$ = proj_log_func.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_log_func", ctx, app_data, logf);
            }
            mh$.invokeExact(ctx, app_data, logf);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_factors {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            P5_FACTORS.layout(),
            proj_h.C_POINTER,
            PJ_COORD.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_factors");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ_FACTORS proj_factors(PJ *P, PJ_COORD lp)
     * }
     */
    public static FunctionDescriptor proj_factors$descriptor() {
        return proj_factors.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ_FACTORS proj_factors(PJ *P, PJ_COORD lp)
     * }
     */
    public static MethodHandle proj_factors$handle() {
        return proj_factors.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ_FACTORS proj_factors(PJ *P, PJ_COORD lp)
     * }
     */
    public static MemorySegment proj_factors$address() {
        return proj_factors.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ_FACTORS proj_factors(PJ *P, PJ_COORD lp)
     * }
     */
    public static MemorySegment proj_factors(SegmentAllocator allocator, MemorySegment P, MemorySegment lp) {
        var mh$ = proj_factors.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_factors", allocator, P, lp);
            }
            return (MemorySegment)mh$.invokeExact(allocator, P, lp);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_info {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            PJ_INFO.layout()    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_info");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ_INFO proj_info()
     * }
     */
    public static FunctionDescriptor proj_info$descriptor() {
        return proj_info.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ_INFO proj_info()
     * }
     */
    public static MethodHandle proj_info$handle() {
        return proj_info.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ_INFO proj_info()
     * }
     */
    public static MemorySegment proj_info$address() {
        return proj_info.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ_INFO proj_info()
     * }
     */
    public static MemorySegment proj_info(SegmentAllocator allocator) {
        var mh$ = proj_info.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_info", allocator);
            }
            return (MemorySegment)mh$.invokeExact(allocator);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_pj_info {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            PJ_PROJ_INFO.layout(),
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_pj_info");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ_PROJ_INFO proj_pj_info(PJ *P)
     * }
     */
    public static FunctionDescriptor proj_pj_info$descriptor() {
        return proj_pj_info.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ_PROJ_INFO proj_pj_info(PJ *P)
     * }
     */
    public static MethodHandle proj_pj_info$handle() {
        return proj_pj_info.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ_PROJ_INFO proj_pj_info(PJ *P)
     * }
     */
    public static MemorySegment proj_pj_info$address() {
        return proj_pj_info.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ_PROJ_INFO proj_pj_info(PJ *P)
     * }
     */
    public static MemorySegment proj_pj_info(SegmentAllocator allocator, MemorySegment P) {
        var mh$ = proj_pj_info.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_pj_info", allocator, P);
            }
            return (MemorySegment)mh$.invokeExact(allocator, P);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_grid_info {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            PJ_GRID_INFO.layout(),
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_grid_info");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ_GRID_INFO proj_grid_info(const char *gridname)
     * }
     */
    public static FunctionDescriptor proj_grid_info$descriptor() {
        return proj_grid_info.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ_GRID_INFO proj_grid_info(const char *gridname)
     * }
     */
    public static MethodHandle proj_grid_info$handle() {
        return proj_grid_info.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ_GRID_INFO proj_grid_info(const char *gridname)
     * }
     */
    public static MemorySegment proj_grid_info$address() {
        return proj_grid_info.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ_GRID_INFO proj_grid_info(const char *gridname)
     * }
     */
    public static MemorySegment proj_grid_info(SegmentAllocator allocator, MemorySegment gridname) {
        var mh$ = proj_grid_info.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_grid_info", allocator, gridname);
            }
            return (MemorySegment)mh$.invokeExact(allocator, gridname);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_init_info {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            PJ_INIT_INFO.layout(),
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_init_info");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ_INIT_INFO proj_init_info(const char *initname)
     * }
     */
    public static FunctionDescriptor proj_init_info$descriptor() {
        return proj_init_info.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ_INIT_INFO proj_init_info(const char *initname)
     * }
     */
    public static MethodHandle proj_init_info$handle() {
        return proj_init_info.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ_INIT_INFO proj_init_info(const char *initname)
     * }
     */
    public static MemorySegment proj_init_info$address() {
        return proj_init_info.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ_INIT_INFO proj_init_info(const char *initname)
     * }
     */
    public static MemorySegment proj_init_info(SegmentAllocator allocator, MemorySegment initname) {
        var mh$ = proj_init_info.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_init_info", allocator, initname);
            }
            return (MemorySegment)mh$.invokeExact(allocator, initname);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_list_operations {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_list_operations");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const PJ_OPERATIONS *proj_list_operations()
     * }
     */
    public static FunctionDescriptor proj_list_operations$descriptor() {
        return proj_list_operations.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const PJ_OPERATIONS *proj_list_operations()
     * }
     */
    public static MethodHandle proj_list_operations$handle() {
        return proj_list_operations.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const PJ_OPERATIONS *proj_list_operations()
     * }
     */
    public static MemorySegment proj_list_operations$address() {
        return proj_list_operations.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const PJ_OPERATIONS *proj_list_operations()
     * }
     */
    public static MemorySegment proj_list_operations() {
        var mh$ = proj_list_operations.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_list_operations");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_list_ellps {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_list_ellps");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const PJ_ELLPS *proj_list_ellps()
     * }
     */
    public static FunctionDescriptor proj_list_ellps$descriptor() {
        return proj_list_ellps.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const PJ_ELLPS *proj_list_ellps()
     * }
     */
    public static MethodHandle proj_list_ellps$handle() {
        return proj_list_ellps.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const PJ_ELLPS *proj_list_ellps()
     * }
     */
    public static MemorySegment proj_list_ellps$address() {
        return proj_list_ellps.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const PJ_ELLPS *proj_list_ellps()
     * }
     */
    public static MemorySegment proj_list_ellps() {
        var mh$ = proj_list_ellps.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_list_ellps");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_list_units {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_list_units");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const PJ_UNITS *proj_list_units()
     * }
     */
    public static FunctionDescriptor proj_list_units$descriptor() {
        return proj_list_units.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const PJ_UNITS *proj_list_units()
     * }
     */
    public static MethodHandle proj_list_units$handle() {
        return proj_list_units.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const PJ_UNITS *proj_list_units()
     * }
     */
    public static MemorySegment proj_list_units$address() {
        return proj_list_units.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const PJ_UNITS *proj_list_units()
     * }
     */
    public static MemorySegment proj_list_units() {
        var mh$ = proj_list_units.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_list_units");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_list_angular_units {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_list_angular_units");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const PJ_UNITS *proj_list_angular_units()
     * }
     */
    public static FunctionDescriptor proj_list_angular_units$descriptor() {
        return proj_list_angular_units.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const PJ_UNITS *proj_list_angular_units()
     * }
     */
    public static MethodHandle proj_list_angular_units$handle() {
        return proj_list_angular_units.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const PJ_UNITS *proj_list_angular_units()
     * }
     */
    public static MemorySegment proj_list_angular_units$address() {
        return proj_list_angular_units.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const PJ_UNITS *proj_list_angular_units()
     * }
     */
    public static MemorySegment proj_list_angular_units() {
        var mh$ = proj_list_angular_units.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_list_angular_units");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_list_prime_meridians {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_list_prime_meridians");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const PJ_PRIME_MERIDIANS *proj_list_prime_meridians()
     * }
     */
    public static FunctionDescriptor proj_list_prime_meridians$descriptor() {
        return proj_list_prime_meridians.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const PJ_PRIME_MERIDIANS *proj_list_prime_meridians()
     * }
     */
    public static MethodHandle proj_list_prime_meridians$handle() {
        return proj_list_prime_meridians.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const PJ_PRIME_MERIDIANS *proj_list_prime_meridians()
     * }
     */
    public static MemorySegment proj_list_prime_meridians$address() {
        return proj_list_prime_meridians.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const PJ_PRIME_MERIDIANS *proj_list_prime_meridians()
     * }
     */
    public static MemorySegment proj_list_prime_meridians() {
        var mh$ = proj_list_prime_meridians.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_list_prime_meridians");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_torad {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_torad");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double proj_torad(double angle_in_degrees)
     * }
     */
    public static FunctionDescriptor proj_torad$descriptor() {
        return proj_torad.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double proj_torad(double angle_in_degrees)
     * }
     */
    public static MethodHandle proj_torad$handle() {
        return proj_torad.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double proj_torad(double angle_in_degrees)
     * }
     */
    public static MemorySegment proj_torad$address() {
        return proj_torad.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double proj_torad(double angle_in_degrees)
     * }
     */
    public static double proj_torad(double angle_in_degrees) {
        var mh$ = proj_torad.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_torad", angle_in_degrees);
            }
            return (double)mh$.invokeExact(angle_in_degrees);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_todeg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_todeg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double proj_todeg(double angle_in_radians)
     * }
     */
    public static FunctionDescriptor proj_todeg$descriptor() {
        return proj_todeg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double proj_todeg(double angle_in_radians)
     * }
     */
    public static MethodHandle proj_todeg$handle() {
        return proj_todeg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double proj_todeg(double angle_in_radians)
     * }
     */
    public static MemorySegment proj_todeg$address() {
        return proj_todeg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double proj_todeg(double angle_in_radians)
     * }
     */
    public static double proj_todeg(double angle_in_radians) {
        var mh$ = proj_todeg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_todeg", angle_in_radians);
            }
            return (double)mh$.invokeExact(angle_in_radians);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_dmstor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_dmstor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double proj_dmstor(const char *is, char **rs)
     * }
     */
    public static FunctionDescriptor proj_dmstor$descriptor() {
        return proj_dmstor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double proj_dmstor(const char *is, char **rs)
     * }
     */
    public static MethodHandle proj_dmstor$handle() {
        return proj_dmstor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double proj_dmstor(const char *is, char **rs)
     * }
     */
    public static MemorySegment proj_dmstor$address() {
        return proj_dmstor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double proj_dmstor(const char *is, char **rs)
     * }
     */
    public static double proj_dmstor(MemorySegment is, MemorySegment rs) {
        var mh$ = proj_dmstor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_dmstor", is, rs);
            }
            return (double)mh$.invokeExact(is, rs);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_rtodms {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE,
            proj_h.C_INT,
            proj_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_rtodms");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *proj_rtodms(char *s, double r, int pos, int neg)
     * }
     */
    public static FunctionDescriptor proj_rtodms$descriptor() {
        return proj_rtodms.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *proj_rtodms(char *s, double r, int pos, int neg)
     * }
     */
    public static MethodHandle proj_rtodms$handle() {
        return proj_rtodms.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *proj_rtodms(char *s, double r, int pos, int neg)
     * }
     */
    public static MemorySegment proj_rtodms$address() {
        return proj_rtodms.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *proj_rtodms(char *s, double r, int pos, int neg)
     * }
     */
    public static MemorySegment proj_rtodms(MemorySegment s, double r, int pos, int neg) {
        var mh$ = proj_rtodms.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_rtodms", s, r, pos, neg);
            }
            return (MemorySegment)mh$.invokeExact(s, r, pos, neg);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_rtodms2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_LONG,
            proj_h.C_DOUBLE,
            proj_h.C_INT,
            proj_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_rtodms2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *proj_rtodms2(char *s, size_t sizeof_s, double r, int pos, int neg)
     * }
     */
    public static FunctionDescriptor proj_rtodms2$descriptor() {
        return proj_rtodms2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *proj_rtodms2(char *s, size_t sizeof_s, double r, int pos, int neg)
     * }
     */
    public static MethodHandle proj_rtodms2$handle() {
        return proj_rtodms2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *proj_rtodms2(char *s, size_t sizeof_s, double r, int pos, int neg)
     * }
     */
    public static MemorySegment proj_rtodms2$address() {
        return proj_rtodms2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *proj_rtodms2(char *s, size_t sizeof_s, double r, int pos, int neg)
     * }
     */
    public static MemorySegment proj_rtodms2(MemorySegment s, long sizeof_s, double r, int pos, int neg) {
        var mh$ = proj_rtodms2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_rtodms2", s, sizeof_s, r, pos, neg);
            }
            return (MemorySegment)mh$.invokeExact(s, sizeof_s, r, pos, neg);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_cleanup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_cleanup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void proj_cleanup()
     * }
     */
    public static FunctionDescriptor proj_cleanup$descriptor() {
        return proj_cleanup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void proj_cleanup()
     * }
     */
    public static MethodHandle proj_cleanup$handle() {
        return proj_cleanup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void proj_cleanup()
     * }
     */
    public static MemorySegment proj_cleanup$address() {
        return proj_cleanup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void proj_cleanup()
     * }
     */
    public static void proj_cleanup() {
        var mh$ = proj_cleanup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_cleanup");
            }
            mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef char **PROJ_STRING_LIST
     * }
     */
    public static final AddressLayout PROJ_STRING_LIST = proj_h.C_POINTER;
    private static final int PJ_GUESSED_WKT2_2019 = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PJ_GUESSED_WKT2_2019 = 0
     * }
     */
    public static int PJ_GUESSED_WKT2_2019() {
        return PJ_GUESSED_WKT2_2019;
    }
    private static final int PJ_GUESSED_WKT2_2018 = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PJ_GUESSED_WKT2_2018 = 0
     * }
     */
    public static int PJ_GUESSED_WKT2_2018() {
        return PJ_GUESSED_WKT2_2018;
    }
    private static final int PJ_GUESSED_WKT2_2015 = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PJ_GUESSED_WKT2_2015 = 1
     * }
     */
    public static int PJ_GUESSED_WKT2_2015() {
        return PJ_GUESSED_WKT2_2015;
    }
    private static final int PJ_GUESSED_WKT1_GDAL = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PJ_GUESSED_WKT1_GDAL = 2
     * }
     */
    public static int PJ_GUESSED_WKT1_GDAL() {
        return PJ_GUESSED_WKT1_GDAL;
    }
    private static final int PJ_GUESSED_WKT1_ESRI = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PJ_GUESSED_WKT1_ESRI = 3
     * }
     */
    public static int PJ_GUESSED_WKT1_ESRI() {
        return PJ_GUESSED_WKT1_ESRI;
    }
    private static final int PJ_GUESSED_NOT_WKT = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PJ_GUESSED_NOT_WKT = 4
     * }
     */
    public static int PJ_GUESSED_NOT_WKT() {
        return PJ_GUESSED_NOT_WKT;
    }
    private static final int PJ_CATEGORY_ELLIPSOID = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PJ_CATEGORY_ELLIPSOID = 0
     * }
     */
    public static int PJ_CATEGORY_ELLIPSOID() {
        return PJ_CATEGORY_ELLIPSOID;
    }
    private static final int PJ_CATEGORY_PRIME_MERIDIAN = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PJ_CATEGORY_PRIME_MERIDIAN = 1
     * }
     */
    public static int PJ_CATEGORY_PRIME_MERIDIAN() {
        return PJ_CATEGORY_PRIME_MERIDIAN;
    }
    private static final int PJ_CATEGORY_DATUM = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PJ_CATEGORY_DATUM = 2
     * }
     */
    public static int PJ_CATEGORY_DATUM() {
        return PJ_CATEGORY_DATUM;
    }
    private static final int PJ_CATEGORY_CRS = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PJ_CATEGORY_CRS = 3
     * }
     */
    public static int PJ_CATEGORY_CRS() {
        return PJ_CATEGORY_CRS;
    }
    private static final int PJ_CATEGORY_COORDINATE_OPERATION = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PJ_CATEGORY_COORDINATE_OPERATION = 4
     * }
     */
    public static int PJ_CATEGORY_COORDINATE_OPERATION() {
        return PJ_CATEGORY_COORDINATE_OPERATION;
    }
    private static final int PJ_CATEGORY_DATUM_ENSEMBLE = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PJ_CATEGORY_DATUM_ENSEMBLE = 5
     * }
     */
    public static int PJ_CATEGORY_DATUM_ENSEMBLE() {
        return PJ_CATEGORY_DATUM_ENSEMBLE;
    }
    private static final int PJ_TYPE_UNKNOWN = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PJ_TYPE_UNKNOWN = 0
     * }
     */
    public static int PJ_TYPE_UNKNOWN() {
        return PJ_TYPE_UNKNOWN;
    }
    private static final int PJ_TYPE_ELLIPSOID = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PJ_TYPE_ELLIPSOID = 1
     * }
     */
    public static int PJ_TYPE_ELLIPSOID() {
        return PJ_TYPE_ELLIPSOID;
    }
    private static final int PJ_TYPE_PRIME_MERIDIAN = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PJ_TYPE_PRIME_MERIDIAN = 2
     * }
     */
    public static int PJ_TYPE_PRIME_MERIDIAN() {
        return PJ_TYPE_PRIME_MERIDIAN;
    }
    private static final int PJ_TYPE_GEODETIC_REFERENCE_FRAME = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PJ_TYPE_GEODETIC_REFERENCE_FRAME = 3
     * }
     */
    public static int PJ_TYPE_GEODETIC_REFERENCE_FRAME() {
        return PJ_TYPE_GEODETIC_REFERENCE_FRAME;
    }
    private static final int PJ_TYPE_DYNAMIC_GEODETIC_REFERENCE_FRAME = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PJ_TYPE_DYNAMIC_GEODETIC_REFERENCE_FRAME = 4
     * }
     */
    public static int PJ_TYPE_DYNAMIC_GEODETIC_REFERENCE_FRAME() {
        return PJ_TYPE_DYNAMIC_GEODETIC_REFERENCE_FRAME;
    }
    private static final int PJ_TYPE_VERTICAL_REFERENCE_FRAME = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PJ_TYPE_VERTICAL_REFERENCE_FRAME = 5
     * }
     */
    public static int PJ_TYPE_VERTICAL_REFERENCE_FRAME() {
        return PJ_TYPE_VERTICAL_REFERENCE_FRAME;
    }
    private static final int PJ_TYPE_DYNAMIC_VERTICAL_REFERENCE_FRAME = (int)6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PJ_TYPE_DYNAMIC_VERTICAL_REFERENCE_FRAME = 6
     * }
     */
    public static int PJ_TYPE_DYNAMIC_VERTICAL_REFERENCE_FRAME() {
        return PJ_TYPE_DYNAMIC_VERTICAL_REFERENCE_FRAME;
    }
    private static final int PJ_TYPE_DATUM_ENSEMBLE = (int)7L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PJ_TYPE_DATUM_ENSEMBLE = 7
     * }
     */
    public static int PJ_TYPE_DATUM_ENSEMBLE() {
        return PJ_TYPE_DATUM_ENSEMBLE;
    }
    private static final int PJ_TYPE_CRS = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PJ_TYPE_CRS = 8
     * }
     */
    public static int PJ_TYPE_CRS() {
        return PJ_TYPE_CRS;
    }
    private static final int PJ_TYPE_GEODETIC_CRS = (int)9L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PJ_TYPE_GEODETIC_CRS = 9
     * }
     */
    public static int PJ_TYPE_GEODETIC_CRS() {
        return PJ_TYPE_GEODETIC_CRS;
    }
    private static final int PJ_TYPE_GEOCENTRIC_CRS = (int)10L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PJ_TYPE_GEOCENTRIC_CRS = 10
     * }
     */
    public static int PJ_TYPE_GEOCENTRIC_CRS() {
        return PJ_TYPE_GEOCENTRIC_CRS;
    }
    private static final int PJ_TYPE_GEOGRAPHIC_CRS = (int)11L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PJ_TYPE_GEOGRAPHIC_CRS = 11
     * }
     */
    public static int PJ_TYPE_GEOGRAPHIC_CRS() {
        return PJ_TYPE_GEOGRAPHIC_CRS;
    }
    private static final int PJ_TYPE_GEOGRAPHIC_2D_CRS = (int)12L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PJ_TYPE_GEOGRAPHIC_2D_CRS = 12
     * }
     */
    public static int PJ_TYPE_GEOGRAPHIC_2D_CRS() {
        return PJ_TYPE_GEOGRAPHIC_2D_CRS;
    }
    private static final int PJ_TYPE_GEOGRAPHIC_3D_CRS = (int)13L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PJ_TYPE_GEOGRAPHIC_3D_CRS = 13
     * }
     */
    public static int PJ_TYPE_GEOGRAPHIC_3D_CRS() {
        return PJ_TYPE_GEOGRAPHIC_3D_CRS;
    }
    private static final int PJ_TYPE_VERTICAL_CRS = (int)14L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PJ_TYPE_VERTICAL_CRS = 14
     * }
     */
    public static int PJ_TYPE_VERTICAL_CRS() {
        return PJ_TYPE_VERTICAL_CRS;
    }
    private static final int PJ_TYPE_PROJECTED_CRS = (int)15L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PJ_TYPE_PROJECTED_CRS = 15
     * }
     */
    public static int PJ_TYPE_PROJECTED_CRS() {
        return PJ_TYPE_PROJECTED_CRS;
    }
    private static final int PJ_TYPE_COMPOUND_CRS = (int)16L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PJ_TYPE_COMPOUND_CRS = 16
     * }
     */
    public static int PJ_TYPE_COMPOUND_CRS() {
        return PJ_TYPE_COMPOUND_CRS;
    }
    private static final int PJ_TYPE_TEMPORAL_CRS = (int)17L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PJ_TYPE_TEMPORAL_CRS = 17
     * }
     */
    public static int PJ_TYPE_TEMPORAL_CRS() {
        return PJ_TYPE_TEMPORAL_CRS;
    }
    private static final int PJ_TYPE_ENGINEERING_CRS = (int)18L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PJ_TYPE_ENGINEERING_CRS = 18
     * }
     */
    public static int PJ_TYPE_ENGINEERING_CRS() {
        return PJ_TYPE_ENGINEERING_CRS;
    }
    private static final int PJ_TYPE_BOUND_CRS = (int)19L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PJ_TYPE_BOUND_CRS = 19
     * }
     */
    public static int PJ_TYPE_BOUND_CRS() {
        return PJ_TYPE_BOUND_CRS;
    }
    private static final int PJ_TYPE_OTHER_CRS = (int)20L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PJ_TYPE_OTHER_CRS = 20
     * }
     */
    public static int PJ_TYPE_OTHER_CRS() {
        return PJ_TYPE_OTHER_CRS;
    }
    private static final int PJ_TYPE_CONVERSION = (int)21L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PJ_TYPE_CONVERSION = 21
     * }
     */
    public static int PJ_TYPE_CONVERSION() {
        return PJ_TYPE_CONVERSION;
    }
    private static final int PJ_TYPE_TRANSFORMATION = (int)22L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PJ_TYPE_TRANSFORMATION = 22
     * }
     */
    public static int PJ_TYPE_TRANSFORMATION() {
        return PJ_TYPE_TRANSFORMATION;
    }
    private static final int PJ_TYPE_CONCATENATED_OPERATION = (int)23L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PJ_TYPE_CONCATENATED_OPERATION = 23
     * }
     */
    public static int PJ_TYPE_CONCATENATED_OPERATION() {
        return PJ_TYPE_CONCATENATED_OPERATION;
    }
    private static final int PJ_TYPE_OTHER_COORDINATE_OPERATION = (int)24L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PJ_TYPE_OTHER_COORDINATE_OPERATION = 24
     * }
     */
    public static int PJ_TYPE_OTHER_COORDINATE_OPERATION() {
        return PJ_TYPE_OTHER_COORDINATE_OPERATION;
    }
    private static final int PJ_TYPE_TEMPORAL_DATUM = (int)25L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PJ_TYPE_TEMPORAL_DATUM = 25
     * }
     */
    public static int PJ_TYPE_TEMPORAL_DATUM() {
        return PJ_TYPE_TEMPORAL_DATUM;
    }
    private static final int PJ_TYPE_ENGINEERING_DATUM = (int)26L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PJ_TYPE_ENGINEERING_DATUM = 26
     * }
     */
    public static int PJ_TYPE_ENGINEERING_DATUM() {
        return PJ_TYPE_ENGINEERING_DATUM;
    }
    private static final int PJ_TYPE_PARAMETRIC_DATUM = (int)27L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PJ_TYPE_PARAMETRIC_DATUM = 27
     * }
     */
    public static int PJ_TYPE_PARAMETRIC_DATUM() {
        return PJ_TYPE_PARAMETRIC_DATUM;
    }
    private static final int PJ_TYPE_DERIVED_PROJECTED_CRS = (int)28L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PJ_TYPE_DERIVED_PROJECTED_CRS = 28
     * }
     */
    public static int PJ_TYPE_DERIVED_PROJECTED_CRS() {
        return PJ_TYPE_DERIVED_PROJECTED_CRS;
    }
    private static final int PJ_TYPE_COORDINATE_METADATA = (int)29L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PJ_TYPE_COORDINATE_METADATA = 29
     * }
     */
    public static int PJ_TYPE_COORDINATE_METADATA() {
        return PJ_TYPE_COORDINATE_METADATA;
    }
    private static final int PJ_COMP_STRICT = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PJ_COMP_STRICT = 0
     * }
     */
    public static int PJ_COMP_STRICT() {
        return PJ_COMP_STRICT;
    }
    private static final int PJ_COMP_EQUIVALENT = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PJ_COMP_EQUIVALENT = 1
     * }
     */
    public static int PJ_COMP_EQUIVALENT() {
        return PJ_COMP_EQUIVALENT;
    }
    private static final int PJ_COMP_EQUIVALENT_EXCEPT_AXIS_ORDER_GEOGCRS = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PJ_COMP_EQUIVALENT_EXCEPT_AXIS_ORDER_GEOGCRS = 2
     * }
     */
    public static int PJ_COMP_EQUIVALENT_EXCEPT_AXIS_ORDER_GEOGCRS() {
        return PJ_COMP_EQUIVALENT_EXCEPT_AXIS_ORDER_GEOGCRS;
    }
    private static final int PJ_WKT2_2015 = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PJ_WKT2_2015 = 0
     * }
     */
    public static int PJ_WKT2_2015() {
        return PJ_WKT2_2015;
    }
    private static final int PJ_WKT2_2015_SIMPLIFIED = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PJ_WKT2_2015_SIMPLIFIED = 1
     * }
     */
    public static int PJ_WKT2_2015_SIMPLIFIED() {
        return PJ_WKT2_2015_SIMPLIFIED;
    }
    private static final int PJ_WKT2_2019 = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PJ_WKT2_2019 = 2
     * }
     */
    public static int PJ_WKT2_2019() {
        return PJ_WKT2_2019;
    }
    private static final int PJ_WKT2_2018 = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PJ_WKT2_2018 = 2
     * }
     */
    public static int PJ_WKT2_2018() {
        return PJ_WKT2_2018;
    }
    private static final int PJ_WKT2_2019_SIMPLIFIED = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PJ_WKT2_2019_SIMPLIFIED = 3
     * }
     */
    public static int PJ_WKT2_2019_SIMPLIFIED() {
        return PJ_WKT2_2019_SIMPLIFIED;
    }
    private static final int PJ_WKT2_2018_SIMPLIFIED = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PJ_WKT2_2018_SIMPLIFIED = 3
     * }
     */
    public static int PJ_WKT2_2018_SIMPLIFIED() {
        return PJ_WKT2_2018_SIMPLIFIED;
    }
    private static final int PJ_WKT1_GDAL = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PJ_WKT1_GDAL = 4
     * }
     */
    public static int PJ_WKT1_GDAL() {
        return PJ_WKT1_GDAL;
    }
    private static final int PJ_WKT1_ESRI = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PJ_WKT1_ESRI = 5
     * }
     */
    public static int PJ_WKT1_ESRI() {
        return PJ_WKT1_ESRI;
    }
    private static final int PJ_CRS_EXTENT_NONE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PJ_CRS_EXTENT_NONE = 0
     * }
     */
    public static int PJ_CRS_EXTENT_NONE() {
        return PJ_CRS_EXTENT_NONE;
    }
    private static final int PJ_CRS_EXTENT_BOTH = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PJ_CRS_EXTENT_BOTH = 1
     * }
     */
    public static int PJ_CRS_EXTENT_BOTH() {
        return PJ_CRS_EXTENT_BOTH;
    }
    private static final int PJ_CRS_EXTENT_INTERSECTION = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PJ_CRS_EXTENT_INTERSECTION = 2
     * }
     */
    public static int PJ_CRS_EXTENT_INTERSECTION() {
        return PJ_CRS_EXTENT_INTERSECTION;
    }
    private static final int PJ_CRS_EXTENT_SMALLEST = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PJ_CRS_EXTENT_SMALLEST = 3
     * }
     */
    public static int PJ_CRS_EXTENT_SMALLEST() {
        return PJ_CRS_EXTENT_SMALLEST;
    }
    private static final int PROJ_GRID_AVAILABILITY_USED_FOR_SORTING = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PROJ_GRID_AVAILABILITY_USED_FOR_SORTING = 0
     * }
     */
    public static int PROJ_GRID_AVAILABILITY_USED_FOR_SORTING() {
        return PROJ_GRID_AVAILABILITY_USED_FOR_SORTING;
    }
    private static final int PROJ_GRID_AVAILABILITY_DISCARD_OPERATION_IF_MISSING_GRID = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PROJ_GRID_AVAILABILITY_DISCARD_OPERATION_IF_MISSING_GRID = 1
     * }
     */
    public static int PROJ_GRID_AVAILABILITY_DISCARD_OPERATION_IF_MISSING_GRID() {
        return PROJ_GRID_AVAILABILITY_DISCARD_OPERATION_IF_MISSING_GRID;
    }
    private static final int PROJ_GRID_AVAILABILITY_IGNORED = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PROJ_GRID_AVAILABILITY_IGNORED = 2
     * }
     */
    public static int PROJ_GRID_AVAILABILITY_IGNORED() {
        return PROJ_GRID_AVAILABILITY_IGNORED;
    }
    private static final int PROJ_GRID_AVAILABILITY_KNOWN_AVAILABLE = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PROJ_GRID_AVAILABILITY_KNOWN_AVAILABLE = 3
     * }
     */
    public static int PROJ_GRID_AVAILABILITY_KNOWN_AVAILABLE() {
        return PROJ_GRID_AVAILABILITY_KNOWN_AVAILABLE;
    }
    private static final int PJ_PROJ_5 = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PJ_PROJ_5 = 0
     * }
     */
    public static int PJ_PROJ_5() {
        return PJ_PROJ_5;
    }
    private static final int PJ_PROJ_4 = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PJ_PROJ_4 = 1
     * }
     */
    public static int PJ_PROJ_4() {
        return PJ_PROJ_4;
    }
    private static final int PROJ_SPATIAL_CRITERION_STRICT_CONTAINMENT = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PROJ_SPATIAL_CRITERION_STRICT_CONTAINMENT = 0
     * }
     */
    public static int PROJ_SPATIAL_CRITERION_STRICT_CONTAINMENT() {
        return PROJ_SPATIAL_CRITERION_STRICT_CONTAINMENT;
    }
    private static final int PROJ_SPATIAL_CRITERION_PARTIAL_INTERSECTION = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PROJ_SPATIAL_CRITERION_PARTIAL_INTERSECTION = 1
     * }
     */
    public static int PROJ_SPATIAL_CRITERION_PARTIAL_INTERSECTION() {
        return PROJ_SPATIAL_CRITERION_PARTIAL_INTERSECTION;
    }
    private static final int PROJ_INTERMEDIATE_CRS_USE_ALWAYS = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PROJ_INTERMEDIATE_CRS_USE_ALWAYS = 0
     * }
     */
    public static int PROJ_INTERMEDIATE_CRS_USE_ALWAYS() {
        return PROJ_INTERMEDIATE_CRS_USE_ALWAYS;
    }
    private static final int PROJ_INTERMEDIATE_CRS_USE_IF_NO_DIRECT_TRANSFORMATION = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PROJ_INTERMEDIATE_CRS_USE_IF_NO_DIRECT_TRANSFORMATION = 1
     * }
     */
    public static int PROJ_INTERMEDIATE_CRS_USE_IF_NO_DIRECT_TRANSFORMATION() {
        return PROJ_INTERMEDIATE_CRS_USE_IF_NO_DIRECT_TRANSFORMATION;
    }
    private static final int PROJ_INTERMEDIATE_CRS_USE_NEVER = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PROJ_INTERMEDIATE_CRS_USE_NEVER = 2
     * }
     */
    public static int PROJ_INTERMEDIATE_CRS_USE_NEVER() {
        return PROJ_INTERMEDIATE_CRS_USE_NEVER;
    }
    private static final int PJ_CS_TYPE_UNKNOWN = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PJ_CS_TYPE_UNKNOWN = 0
     * }
     */
    public static int PJ_CS_TYPE_UNKNOWN() {
        return PJ_CS_TYPE_UNKNOWN;
    }
    private static final int PJ_CS_TYPE_CARTESIAN = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PJ_CS_TYPE_CARTESIAN = 1
     * }
     */
    public static int PJ_CS_TYPE_CARTESIAN() {
        return PJ_CS_TYPE_CARTESIAN;
    }
    private static final int PJ_CS_TYPE_ELLIPSOIDAL = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PJ_CS_TYPE_ELLIPSOIDAL = 2
     * }
     */
    public static int PJ_CS_TYPE_ELLIPSOIDAL() {
        return PJ_CS_TYPE_ELLIPSOIDAL;
    }
    private static final int PJ_CS_TYPE_VERTICAL = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PJ_CS_TYPE_VERTICAL = 3
     * }
     */
    public static int PJ_CS_TYPE_VERTICAL() {
        return PJ_CS_TYPE_VERTICAL;
    }
    private static final int PJ_CS_TYPE_SPHERICAL = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PJ_CS_TYPE_SPHERICAL = 4
     * }
     */
    public static int PJ_CS_TYPE_SPHERICAL() {
        return PJ_CS_TYPE_SPHERICAL;
    }
    private static final int PJ_CS_TYPE_ORDINAL = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PJ_CS_TYPE_ORDINAL = 5
     * }
     */
    public static int PJ_CS_TYPE_ORDINAL() {
        return PJ_CS_TYPE_ORDINAL;
    }
    private static final int PJ_CS_TYPE_PARAMETRIC = (int)6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PJ_CS_TYPE_PARAMETRIC = 6
     * }
     */
    public static int PJ_CS_TYPE_PARAMETRIC() {
        return PJ_CS_TYPE_PARAMETRIC;
    }
    private static final int PJ_CS_TYPE_DATETIMETEMPORAL = (int)7L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PJ_CS_TYPE_DATETIMETEMPORAL = 7
     * }
     */
    public static int PJ_CS_TYPE_DATETIMETEMPORAL() {
        return PJ_CS_TYPE_DATETIMETEMPORAL;
    }
    private static final int PJ_CS_TYPE_TEMPORALCOUNT = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PJ_CS_TYPE_TEMPORALCOUNT = 8
     * }
     */
    public static int PJ_CS_TYPE_TEMPORALCOUNT() {
        return PJ_CS_TYPE_TEMPORALCOUNT;
    }
    private static final int PJ_CS_TYPE_TEMPORALMEASURE = (int)9L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PJ_CS_TYPE_TEMPORALMEASURE = 9
     * }
     */
    public static int PJ_CS_TYPE_TEMPORALMEASURE() {
        return PJ_CS_TYPE_TEMPORALMEASURE;
    }

    private static class proj_string_list_destroy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_string_list_destroy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void proj_string_list_destroy(PROJ_STRING_LIST list)
     * }
     */
    public static FunctionDescriptor proj_string_list_destroy$descriptor() {
        return proj_string_list_destroy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void proj_string_list_destroy(PROJ_STRING_LIST list)
     * }
     */
    public static MethodHandle proj_string_list_destroy$handle() {
        return proj_string_list_destroy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void proj_string_list_destroy(PROJ_STRING_LIST list)
     * }
     */
    public static MemorySegment proj_string_list_destroy$address() {
        return proj_string_list_destroy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void proj_string_list_destroy(PROJ_STRING_LIST list)
     * }
     */
    public static void proj_string_list_destroy(MemorySegment list) {
        var mh$ = proj_string_list_destroy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_string_list_destroy", list);
            }
            mh$.invokeExact(list);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_context_set_autoclose_database {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            proj_h.C_POINTER,
            proj_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_context_set_autoclose_database");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void proj_context_set_autoclose_database(PJ_CONTEXT *ctx, int autoclose)
     * }
     */
    public static FunctionDescriptor proj_context_set_autoclose_database$descriptor() {
        return proj_context_set_autoclose_database.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void proj_context_set_autoclose_database(PJ_CONTEXT *ctx, int autoclose)
     * }
     */
    public static MethodHandle proj_context_set_autoclose_database$handle() {
        return proj_context_set_autoclose_database.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void proj_context_set_autoclose_database(PJ_CONTEXT *ctx, int autoclose)
     * }
     */
    public static MemorySegment proj_context_set_autoclose_database$address() {
        return proj_context_set_autoclose_database.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void proj_context_set_autoclose_database(PJ_CONTEXT *ctx, int autoclose)
     * }
     */
    public static void proj_context_set_autoclose_database(MemorySegment ctx, int autoclose) {
        var mh$ = proj_context_set_autoclose_database.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_context_set_autoclose_database", ctx, autoclose);
            }
            mh$.invokeExact(ctx, autoclose);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_context_set_database_path {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_INT,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_context_set_database_path");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int proj_context_set_database_path(PJ_CONTEXT *ctx, const char *dbPath, const char *const *auxDbPaths, const char *const *options)
     * }
     */
    public static FunctionDescriptor proj_context_set_database_path$descriptor() {
        return proj_context_set_database_path.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int proj_context_set_database_path(PJ_CONTEXT *ctx, const char *dbPath, const char *const *auxDbPaths, const char *const *options)
     * }
     */
    public static MethodHandle proj_context_set_database_path$handle() {
        return proj_context_set_database_path.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int proj_context_set_database_path(PJ_CONTEXT *ctx, const char *dbPath, const char *const *auxDbPaths, const char *const *options)
     * }
     */
    public static MemorySegment proj_context_set_database_path$address() {
        return proj_context_set_database_path.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int proj_context_set_database_path(PJ_CONTEXT *ctx, const char *dbPath, const char *const *auxDbPaths, const char *const *options)
     * }
     */
    public static int proj_context_set_database_path(MemorySegment ctx, MemorySegment dbPath, MemorySegment auxDbPaths, MemorySegment options) {
        var mh$ = proj_context_set_database_path.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_context_set_database_path", ctx, dbPath, auxDbPaths, options);
            }
            return (int)mh$.invokeExact(ctx, dbPath, auxDbPaths, options);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_context_get_database_path {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_context_get_database_path");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *proj_context_get_database_path(PJ_CONTEXT *ctx)
     * }
     */
    public static FunctionDescriptor proj_context_get_database_path$descriptor() {
        return proj_context_get_database_path.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *proj_context_get_database_path(PJ_CONTEXT *ctx)
     * }
     */
    public static MethodHandle proj_context_get_database_path$handle() {
        return proj_context_get_database_path.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *proj_context_get_database_path(PJ_CONTEXT *ctx)
     * }
     */
    public static MemorySegment proj_context_get_database_path$address() {
        return proj_context_get_database_path.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *proj_context_get_database_path(PJ_CONTEXT *ctx)
     * }
     */
    public static MemorySegment proj_context_get_database_path(MemorySegment ctx) {
        var mh$ = proj_context_get_database_path.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_context_get_database_path", ctx);
            }
            return (MemorySegment)mh$.invokeExact(ctx);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_context_get_database_metadata {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_context_get_database_metadata");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *proj_context_get_database_metadata(PJ_CONTEXT *ctx, const char *key)
     * }
     */
    public static FunctionDescriptor proj_context_get_database_metadata$descriptor() {
        return proj_context_get_database_metadata.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *proj_context_get_database_metadata(PJ_CONTEXT *ctx, const char *key)
     * }
     */
    public static MethodHandle proj_context_get_database_metadata$handle() {
        return proj_context_get_database_metadata.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *proj_context_get_database_metadata(PJ_CONTEXT *ctx, const char *key)
     * }
     */
    public static MemorySegment proj_context_get_database_metadata$address() {
        return proj_context_get_database_metadata.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *proj_context_get_database_metadata(PJ_CONTEXT *ctx, const char *key)
     * }
     */
    public static MemorySegment proj_context_get_database_metadata(MemorySegment ctx, MemorySegment key) {
        var mh$ = proj_context_get_database_metadata.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_context_get_database_metadata", ctx, key);
            }
            return (MemorySegment)mh$.invokeExact(ctx, key);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_context_get_database_structure {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_context_get_database_structure");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PROJ_STRING_LIST proj_context_get_database_structure(PJ_CONTEXT *ctx, const char *const *options)
     * }
     */
    public static FunctionDescriptor proj_context_get_database_structure$descriptor() {
        return proj_context_get_database_structure.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PROJ_STRING_LIST proj_context_get_database_structure(PJ_CONTEXT *ctx, const char *const *options)
     * }
     */
    public static MethodHandle proj_context_get_database_structure$handle() {
        return proj_context_get_database_structure.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PROJ_STRING_LIST proj_context_get_database_structure(PJ_CONTEXT *ctx, const char *const *options)
     * }
     */
    public static MemorySegment proj_context_get_database_structure$address() {
        return proj_context_get_database_structure.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PROJ_STRING_LIST proj_context_get_database_structure(PJ_CONTEXT *ctx, const char *const *options)
     * }
     */
    public static MemorySegment proj_context_get_database_structure(MemorySegment ctx, MemorySegment options) {
        var mh$ = proj_context_get_database_structure.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_context_get_database_structure", ctx, options);
            }
            return (MemorySegment)mh$.invokeExact(ctx, options);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_context_guess_wkt_dialect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_INT,
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_context_guess_wkt_dialect");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ_GUESSED_WKT_DIALECT proj_context_guess_wkt_dialect(PJ_CONTEXT *ctx, const char *wkt)
     * }
     */
    public static FunctionDescriptor proj_context_guess_wkt_dialect$descriptor() {
        return proj_context_guess_wkt_dialect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ_GUESSED_WKT_DIALECT proj_context_guess_wkt_dialect(PJ_CONTEXT *ctx, const char *wkt)
     * }
     */
    public static MethodHandle proj_context_guess_wkt_dialect$handle() {
        return proj_context_guess_wkt_dialect.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ_GUESSED_WKT_DIALECT proj_context_guess_wkt_dialect(PJ_CONTEXT *ctx, const char *wkt)
     * }
     */
    public static MemorySegment proj_context_guess_wkt_dialect$address() {
        return proj_context_guess_wkt_dialect.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ_GUESSED_WKT_DIALECT proj_context_guess_wkt_dialect(PJ_CONTEXT *ctx, const char *wkt)
     * }
     */
    public static int proj_context_guess_wkt_dialect(MemorySegment ctx, MemorySegment wkt) {
        var mh$ = proj_context_guess_wkt_dialect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_context_guess_wkt_dialect", ctx, wkt);
            }
            return (int)mh$.invokeExact(ctx, wkt);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_create_from_wkt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_create_from_wkt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ *proj_create_from_wkt(PJ_CONTEXT *ctx, const char *wkt, const char *const *options, PROJ_STRING_LIST *out_warnings, PROJ_STRING_LIST *out_grammar_errors)
     * }
     */
    public static FunctionDescriptor proj_create_from_wkt$descriptor() {
        return proj_create_from_wkt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ *proj_create_from_wkt(PJ_CONTEXT *ctx, const char *wkt, const char *const *options, PROJ_STRING_LIST *out_warnings, PROJ_STRING_LIST *out_grammar_errors)
     * }
     */
    public static MethodHandle proj_create_from_wkt$handle() {
        return proj_create_from_wkt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ *proj_create_from_wkt(PJ_CONTEXT *ctx, const char *wkt, const char *const *options, PROJ_STRING_LIST *out_warnings, PROJ_STRING_LIST *out_grammar_errors)
     * }
     */
    public static MemorySegment proj_create_from_wkt$address() {
        return proj_create_from_wkt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ *proj_create_from_wkt(PJ_CONTEXT *ctx, const char *wkt, const char *const *options, PROJ_STRING_LIST *out_warnings, PROJ_STRING_LIST *out_grammar_errors)
     * }
     */
    public static MemorySegment proj_create_from_wkt(MemorySegment ctx, MemorySegment wkt, MemorySegment options, MemorySegment out_warnings, MemorySegment out_grammar_errors) {
        var mh$ = proj_create_from_wkt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_create_from_wkt", ctx, wkt, options, out_warnings, out_grammar_errors);
            }
            return (MemorySegment)mh$.invokeExact(ctx, wkt, options, out_warnings, out_grammar_errors);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_create_from_database {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_INT,
            proj_h.C_INT,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_create_from_database");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ *proj_create_from_database(PJ_CONTEXT *ctx, const char *auth_name, const char *code, PJ_CATEGORY category, int usePROJAlternativeGridNames, const char *const *options)
     * }
     */
    public static FunctionDescriptor proj_create_from_database$descriptor() {
        return proj_create_from_database.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ *proj_create_from_database(PJ_CONTEXT *ctx, const char *auth_name, const char *code, PJ_CATEGORY category, int usePROJAlternativeGridNames, const char *const *options)
     * }
     */
    public static MethodHandle proj_create_from_database$handle() {
        return proj_create_from_database.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ *proj_create_from_database(PJ_CONTEXT *ctx, const char *auth_name, const char *code, PJ_CATEGORY category, int usePROJAlternativeGridNames, const char *const *options)
     * }
     */
    public static MemorySegment proj_create_from_database$address() {
        return proj_create_from_database.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ *proj_create_from_database(PJ_CONTEXT *ctx, const char *auth_name, const char *code, PJ_CATEGORY category, int usePROJAlternativeGridNames, const char *const *options)
     * }
     */
    public static MemorySegment proj_create_from_database(MemorySegment ctx, MemorySegment auth_name, MemorySegment code, int category, int usePROJAlternativeGridNames, MemorySegment options) {
        var mh$ = proj_create_from_database.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_create_from_database", ctx, auth_name, code, category, usePROJAlternativeGridNames, options);
            }
            return (MemorySegment)mh$.invokeExact(ctx, auth_name, code, category, usePROJAlternativeGridNames, options);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_uom_get_info_from_database {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_INT,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_uom_get_info_from_database");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int proj_uom_get_info_from_database(PJ_CONTEXT *ctx, const char *auth_name, const char *code, const char **out_name, double *out_conv_factor, const char **out_category)
     * }
     */
    public static FunctionDescriptor proj_uom_get_info_from_database$descriptor() {
        return proj_uom_get_info_from_database.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int proj_uom_get_info_from_database(PJ_CONTEXT *ctx, const char *auth_name, const char *code, const char **out_name, double *out_conv_factor, const char **out_category)
     * }
     */
    public static MethodHandle proj_uom_get_info_from_database$handle() {
        return proj_uom_get_info_from_database.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int proj_uom_get_info_from_database(PJ_CONTEXT *ctx, const char *auth_name, const char *code, const char **out_name, double *out_conv_factor, const char **out_category)
     * }
     */
    public static MemorySegment proj_uom_get_info_from_database$address() {
        return proj_uom_get_info_from_database.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int proj_uom_get_info_from_database(PJ_CONTEXT *ctx, const char *auth_name, const char *code, const char **out_name, double *out_conv_factor, const char **out_category)
     * }
     */
    public static int proj_uom_get_info_from_database(MemorySegment ctx, MemorySegment auth_name, MemorySegment code, MemorySegment out_name, MemorySegment out_conv_factor, MemorySegment out_category) {
        var mh$ = proj_uom_get_info_from_database.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_uom_get_info_from_database", ctx, auth_name, code, out_name, out_conv_factor, out_category);
            }
            return (int)mh$.invokeExact(ctx, auth_name, code, out_name, out_conv_factor, out_category);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_grid_get_info_from_database {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_INT,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_grid_get_info_from_database");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int proj_grid_get_info_from_database(PJ_CONTEXT *ctx, const char *grid_name, const char **out_full_name, const char **out_package_name, const char **out_url, int *out_direct_download, int *out_open_license, int *out_available)
     * }
     */
    public static FunctionDescriptor proj_grid_get_info_from_database$descriptor() {
        return proj_grid_get_info_from_database.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int proj_grid_get_info_from_database(PJ_CONTEXT *ctx, const char *grid_name, const char **out_full_name, const char **out_package_name, const char **out_url, int *out_direct_download, int *out_open_license, int *out_available)
     * }
     */
    public static MethodHandle proj_grid_get_info_from_database$handle() {
        return proj_grid_get_info_from_database.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int proj_grid_get_info_from_database(PJ_CONTEXT *ctx, const char *grid_name, const char **out_full_name, const char **out_package_name, const char **out_url, int *out_direct_download, int *out_open_license, int *out_available)
     * }
     */
    public static MemorySegment proj_grid_get_info_from_database$address() {
        return proj_grid_get_info_from_database.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int proj_grid_get_info_from_database(PJ_CONTEXT *ctx, const char *grid_name, const char **out_full_name, const char **out_package_name, const char **out_url, int *out_direct_download, int *out_open_license, int *out_available)
     * }
     */
    public static int proj_grid_get_info_from_database(MemorySegment ctx, MemorySegment grid_name, MemorySegment out_full_name, MemorySegment out_package_name, MemorySegment out_url, MemorySegment out_direct_download, MemorySegment out_open_license, MemorySegment out_available) {
        var mh$ = proj_grid_get_info_from_database.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_grid_get_info_from_database", ctx, grid_name, out_full_name, out_package_name, out_url, out_direct_download, out_open_license, out_available);
            }
            return (int)mh$.invokeExact(ctx, grid_name, out_full_name, out_package_name, out_url, out_direct_download, out_open_license, out_available);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_clone {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_clone");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ *proj_clone(PJ_CONTEXT *ctx, const PJ *obj)
     * }
     */
    public static FunctionDescriptor proj_clone$descriptor() {
        return proj_clone.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ *proj_clone(PJ_CONTEXT *ctx, const PJ *obj)
     * }
     */
    public static MethodHandle proj_clone$handle() {
        return proj_clone.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ *proj_clone(PJ_CONTEXT *ctx, const PJ *obj)
     * }
     */
    public static MemorySegment proj_clone$address() {
        return proj_clone.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ *proj_clone(PJ_CONTEXT *ctx, const PJ *obj)
     * }
     */
    public static MemorySegment proj_clone(MemorySegment ctx, MemorySegment obj) {
        var mh$ = proj_clone.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_clone", ctx, obj);
            }
            return (MemorySegment)mh$.invokeExact(ctx, obj);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_create_from_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_LONG,
            proj_h.C_INT,
            proj_h.C_LONG,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_create_from_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ_OBJ_LIST *proj_create_from_name(PJ_CONTEXT *ctx, const char *auth_name, const char *searchedName, const PJ_TYPE *types, size_t typesCount, int approximateMatch, size_t limitResultCount, const char *const *options)
     * }
     */
    public static FunctionDescriptor proj_create_from_name$descriptor() {
        return proj_create_from_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ_OBJ_LIST *proj_create_from_name(PJ_CONTEXT *ctx, const char *auth_name, const char *searchedName, const PJ_TYPE *types, size_t typesCount, int approximateMatch, size_t limitResultCount, const char *const *options)
     * }
     */
    public static MethodHandle proj_create_from_name$handle() {
        return proj_create_from_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ_OBJ_LIST *proj_create_from_name(PJ_CONTEXT *ctx, const char *auth_name, const char *searchedName, const PJ_TYPE *types, size_t typesCount, int approximateMatch, size_t limitResultCount, const char *const *options)
     * }
     */
    public static MemorySegment proj_create_from_name$address() {
        return proj_create_from_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ_OBJ_LIST *proj_create_from_name(PJ_CONTEXT *ctx, const char *auth_name, const char *searchedName, const PJ_TYPE *types, size_t typesCount, int approximateMatch, size_t limitResultCount, const char *const *options)
     * }
     */
    public static MemorySegment proj_create_from_name(MemorySegment ctx, MemorySegment auth_name, MemorySegment searchedName, MemorySegment types, long typesCount, int approximateMatch, long limitResultCount, MemorySegment options) {
        var mh$ = proj_create_from_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_create_from_name", ctx, auth_name, searchedName, types, typesCount, approximateMatch, limitResultCount, options);
            }
            return (MemorySegment)mh$.invokeExact(ctx, auth_name, searchedName, types, typesCount, approximateMatch, limitResultCount, options);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_get_type {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_INT,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_get_type");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ_TYPE proj_get_type(const PJ *obj)
     * }
     */
    public static FunctionDescriptor proj_get_type$descriptor() {
        return proj_get_type.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ_TYPE proj_get_type(const PJ *obj)
     * }
     */
    public static MethodHandle proj_get_type$handle() {
        return proj_get_type.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ_TYPE proj_get_type(const PJ *obj)
     * }
     */
    public static MemorySegment proj_get_type$address() {
        return proj_get_type.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ_TYPE proj_get_type(const PJ *obj)
     * }
     */
    public static int proj_get_type(MemorySegment obj) {
        var mh$ = proj_get_type.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_get_type", obj);
            }
            return (int)mh$.invokeExact(obj);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_is_deprecated {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_INT,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_is_deprecated");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int proj_is_deprecated(const PJ *obj)
     * }
     */
    public static FunctionDescriptor proj_is_deprecated$descriptor() {
        return proj_is_deprecated.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int proj_is_deprecated(const PJ *obj)
     * }
     */
    public static MethodHandle proj_is_deprecated$handle() {
        return proj_is_deprecated.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int proj_is_deprecated(const PJ *obj)
     * }
     */
    public static MemorySegment proj_is_deprecated$address() {
        return proj_is_deprecated.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int proj_is_deprecated(const PJ *obj)
     * }
     */
    public static int proj_is_deprecated(MemorySegment obj) {
        var mh$ = proj_is_deprecated.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_is_deprecated", obj);
            }
            return (int)mh$.invokeExact(obj);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_get_non_deprecated {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_get_non_deprecated");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ_OBJ_LIST *proj_get_non_deprecated(PJ_CONTEXT *ctx, const PJ *obj)
     * }
     */
    public static FunctionDescriptor proj_get_non_deprecated$descriptor() {
        return proj_get_non_deprecated.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ_OBJ_LIST *proj_get_non_deprecated(PJ_CONTEXT *ctx, const PJ *obj)
     * }
     */
    public static MethodHandle proj_get_non_deprecated$handle() {
        return proj_get_non_deprecated.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ_OBJ_LIST *proj_get_non_deprecated(PJ_CONTEXT *ctx, const PJ *obj)
     * }
     */
    public static MemorySegment proj_get_non_deprecated$address() {
        return proj_get_non_deprecated.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ_OBJ_LIST *proj_get_non_deprecated(PJ_CONTEXT *ctx, const PJ *obj)
     * }
     */
    public static MemorySegment proj_get_non_deprecated(MemorySegment ctx, MemorySegment obj) {
        var mh$ = proj_get_non_deprecated.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_get_non_deprecated", ctx, obj);
            }
            return (MemorySegment)mh$.invokeExact(ctx, obj);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_is_equivalent_to {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_INT,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_is_equivalent_to");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int proj_is_equivalent_to(const PJ *obj, const PJ *other, PJ_COMPARISON_CRITERION criterion)
     * }
     */
    public static FunctionDescriptor proj_is_equivalent_to$descriptor() {
        return proj_is_equivalent_to.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int proj_is_equivalent_to(const PJ *obj, const PJ *other, PJ_COMPARISON_CRITERION criterion)
     * }
     */
    public static MethodHandle proj_is_equivalent_to$handle() {
        return proj_is_equivalent_to.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int proj_is_equivalent_to(const PJ *obj, const PJ *other, PJ_COMPARISON_CRITERION criterion)
     * }
     */
    public static MemorySegment proj_is_equivalent_to$address() {
        return proj_is_equivalent_to.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int proj_is_equivalent_to(const PJ *obj, const PJ *other, PJ_COMPARISON_CRITERION criterion)
     * }
     */
    public static int proj_is_equivalent_to(MemorySegment obj, MemorySegment other, int criterion) {
        var mh$ = proj_is_equivalent_to.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_is_equivalent_to", obj, other, criterion);
            }
            return (int)mh$.invokeExact(obj, other, criterion);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_is_equivalent_to_with_ctx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_INT,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_is_equivalent_to_with_ctx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int proj_is_equivalent_to_with_ctx(PJ_CONTEXT *ctx, const PJ *obj, const PJ *other, PJ_COMPARISON_CRITERION criterion)
     * }
     */
    public static FunctionDescriptor proj_is_equivalent_to_with_ctx$descriptor() {
        return proj_is_equivalent_to_with_ctx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int proj_is_equivalent_to_with_ctx(PJ_CONTEXT *ctx, const PJ *obj, const PJ *other, PJ_COMPARISON_CRITERION criterion)
     * }
     */
    public static MethodHandle proj_is_equivalent_to_with_ctx$handle() {
        return proj_is_equivalent_to_with_ctx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int proj_is_equivalent_to_with_ctx(PJ_CONTEXT *ctx, const PJ *obj, const PJ *other, PJ_COMPARISON_CRITERION criterion)
     * }
     */
    public static MemorySegment proj_is_equivalent_to_with_ctx$address() {
        return proj_is_equivalent_to_with_ctx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int proj_is_equivalent_to_with_ctx(PJ_CONTEXT *ctx, const PJ *obj, const PJ *other, PJ_COMPARISON_CRITERION criterion)
     * }
     */
    public static int proj_is_equivalent_to_with_ctx(MemorySegment ctx, MemorySegment obj, MemorySegment other, int criterion) {
        var mh$ = proj_is_equivalent_to_with_ctx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_is_equivalent_to_with_ctx", ctx, obj, other, criterion);
            }
            return (int)mh$.invokeExact(ctx, obj, other, criterion);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_is_crs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_INT,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_is_crs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int proj_is_crs(const PJ *obj)
     * }
     */
    public static FunctionDescriptor proj_is_crs$descriptor() {
        return proj_is_crs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int proj_is_crs(const PJ *obj)
     * }
     */
    public static MethodHandle proj_is_crs$handle() {
        return proj_is_crs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int proj_is_crs(const PJ *obj)
     * }
     */
    public static MemorySegment proj_is_crs$address() {
        return proj_is_crs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int proj_is_crs(const PJ *obj)
     * }
     */
    public static int proj_is_crs(MemorySegment obj) {
        var mh$ = proj_is_crs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_is_crs", obj);
            }
            return (int)mh$.invokeExact(obj);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_get_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_get_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *proj_get_name(const PJ *obj)
     * }
     */
    public static FunctionDescriptor proj_get_name$descriptor() {
        return proj_get_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *proj_get_name(const PJ *obj)
     * }
     */
    public static MethodHandle proj_get_name$handle() {
        return proj_get_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *proj_get_name(const PJ *obj)
     * }
     */
    public static MemorySegment proj_get_name$address() {
        return proj_get_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *proj_get_name(const PJ *obj)
     * }
     */
    public static MemorySegment proj_get_name(MemorySegment obj) {
        var mh$ = proj_get_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_get_name", obj);
            }
            return (MemorySegment)mh$.invokeExact(obj);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_get_id_auth_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_get_id_auth_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *proj_get_id_auth_name(const PJ *obj, int index)
     * }
     */
    public static FunctionDescriptor proj_get_id_auth_name$descriptor() {
        return proj_get_id_auth_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *proj_get_id_auth_name(const PJ *obj, int index)
     * }
     */
    public static MethodHandle proj_get_id_auth_name$handle() {
        return proj_get_id_auth_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *proj_get_id_auth_name(const PJ *obj, int index)
     * }
     */
    public static MemorySegment proj_get_id_auth_name$address() {
        return proj_get_id_auth_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *proj_get_id_auth_name(const PJ *obj, int index)
     * }
     */
    public static MemorySegment proj_get_id_auth_name(MemorySegment obj, int index) {
        var mh$ = proj_get_id_auth_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_get_id_auth_name", obj, index);
            }
            return (MemorySegment)mh$.invokeExact(obj, index);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_get_id_code {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_get_id_code");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *proj_get_id_code(const PJ *obj, int index)
     * }
     */
    public static FunctionDescriptor proj_get_id_code$descriptor() {
        return proj_get_id_code.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *proj_get_id_code(const PJ *obj, int index)
     * }
     */
    public static MethodHandle proj_get_id_code$handle() {
        return proj_get_id_code.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *proj_get_id_code(const PJ *obj, int index)
     * }
     */
    public static MemorySegment proj_get_id_code$address() {
        return proj_get_id_code.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *proj_get_id_code(const PJ *obj, int index)
     * }
     */
    public static MemorySegment proj_get_id_code(MemorySegment obj, int index) {
        var mh$ = proj_get_id_code.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_get_id_code", obj, index);
            }
            return (MemorySegment)mh$.invokeExact(obj, index);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_get_remarks {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_get_remarks");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *proj_get_remarks(const PJ *obj)
     * }
     */
    public static FunctionDescriptor proj_get_remarks$descriptor() {
        return proj_get_remarks.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *proj_get_remarks(const PJ *obj)
     * }
     */
    public static MethodHandle proj_get_remarks$handle() {
        return proj_get_remarks.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *proj_get_remarks(const PJ *obj)
     * }
     */
    public static MemorySegment proj_get_remarks$address() {
        return proj_get_remarks.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *proj_get_remarks(const PJ *obj)
     * }
     */
    public static MemorySegment proj_get_remarks(MemorySegment obj) {
        var mh$ = proj_get_remarks.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_get_remarks", obj);
            }
            return (MemorySegment)mh$.invokeExact(obj);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_get_domain_count {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_INT,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_get_domain_count");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int proj_get_domain_count(const PJ *obj)
     * }
     */
    public static FunctionDescriptor proj_get_domain_count$descriptor() {
        return proj_get_domain_count.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int proj_get_domain_count(const PJ *obj)
     * }
     */
    public static MethodHandle proj_get_domain_count$handle() {
        return proj_get_domain_count.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int proj_get_domain_count(const PJ *obj)
     * }
     */
    public static MemorySegment proj_get_domain_count$address() {
        return proj_get_domain_count.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int proj_get_domain_count(const PJ *obj)
     * }
     */
    public static int proj_get_domain_count(MemorySegment obj) {
        var mh$ = proj_get_domain_count.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_get_domain_count", obj);
            }
            return (int)mh$.invokeExact(obj);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_get_scope {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_get_scope");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *proj_get_scope(const PJ *obj)
     * }
     */
    public static FunctionDescriptor proj_get_scope$descriptor() {
        return proj_get_scope.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *proj_get_scope(const PJ *obj)
     * }
     */
    public static MethodHandle proj_get_scope$handle() {
        return proj_get_scope.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *proj_get_scope(const PJ *obj)
     * }
     */
    public static MemorySegment proj_get_scope$address() {
        return proj_get_scope.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *proj_get_scope(const PJ *obj)
     * }
     */
    public static MemorySegment proj_get_scope(MemorySegment obj) {
        var mh$ = proj_get_scope.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_get_scope", obj);
            }
            return (MemorySegment)mh$.invokeExact(obj);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_get_scope_ex {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_get_scope_ex");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *proj_get_scope_ex(const PJ *obj, int domainIdx)
     * }
     */
    public static FunctionDescriptor proj_get_scope_ex$descriptor() {
        return proj_get_scope_ex.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *proj_get_scope_ex(const PJ *obj, int domainIdx)
     * }
     */
    public static MethodHandle proj_get_scope_ex$handle() {
        return proj_get_scope_ex.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *proj_get_scope_ex(const PJ *obj, int domainIdx)
     * }
     */
    public static MemorySegment proj_get_scope_ex$address() {
        return proj_get_scope_ex.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *proj_get_scope_ex(const PJ *obj, int domainIdx)
     * }
     */
    public static MemorySegment proj_get_scope_ex(MemorySegment obj, int domainIdx) {
        var mh$ = proj_get_scope_ex.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_get_scope_ex", obj, domainIdx);
            }
            return (MemorySegment)mh$.invokeExact(obj, domainIdx);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_get_area_of_use {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_INT,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_get_area_of_use");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int proj_get_area_of_use(PJ_CONTEXT *ctx, const PJ *obj, double *out_west_lon_degree, double *out_south_lat_degree, double *out_east_lon_degree, double *out_north_lat_degree, const char **out_area_name)
     * }
     */
    public static FunctionDescriptor proj_get_area_of_use$descriptor() {
        return proj_get_area_of_use.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int proj_get_area_of_use(PJ_CONTEXT *ctx, const PJ *obj, double *out_west_lon_degree, double *out_south_lat_degree, double *out_east_lon_degree, double *out_north_lat_degree, const char **out_area_name)
     * }
     */
    public static MethodHandle proj_get_area_of_use$handle() {
        return proj_get_area_of_use.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int proj_get_area_of_use(PJ_CONTEXT *ctx, const PJ *obj, double *out_west_lon_degree, double *out_south_lat_degree, double *out_east_lon_degree, double *out_north_lat_degree, const char **out_area_name)
     * }
     */
    public static MemorySegment proj_get_area_of_use$address() {
        return proj_get_area_of_use.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int proj_get_area_of_use(PJ_CONTEXT *ctx, const PJ *obj, double *out_west_lon_degree, double *out_south_lat_degree, double *out_east_lon_degree, double *out_north_lat_degree, const char **out_area_name)
     * }
     */
    public static int proj_get_area_of_use(MemorySegment ctx, MemorySegment obj, MemorySegment out_west_lon_degree, MemorySegment out_south_lat_degree, MemorySegment out_east_lon_degree, MemorySegment out_north_lat_degree, MemorySegment out_area_name) {
        var mh$ = proj_get_area_of_use.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_get_area_of_use", ctx, obj, out_west_lon_degree, out_south_lat_degree, out_east_lon_degree, out_north_lat_degree, out_area_name);
            }
            return (int)mh$.invokeExact(ctx, obj, out_west_lon_degree, out_south_lat_degree, out_east_lon_degree, out_north_lat_degree, out_area_name);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_get_area_of_use_ex {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_INT,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_INT,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_get_area_of_use_ex");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int proj_get_area_of_use_ex(PJ_CONTEXT *ctx, const PJ *obj, int domainIdx, double *out_west_lon_degree, double *out_south_lat_degree, double *out_east_lon_degree, double *out_north_lat_degree, const char **out_area_name)
     * }
     */
    public static FunctionDescriptor proj_get_area_of_use_ex$descriptor() {
        return proj_get_area_of_use_ex.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int proj_get_area_of_use_ex(PJ_CONTEXT *ctx, const PJ *obj, int domainIdx, double *out_west_lon_degree, double *out_south_lat_degree, double *out_east_lon_degree, double *out_north_lat_degree, const char **out_area_name)
     * }
     */
    public static MethodHandle proj_get_area_of_use_ex$handle() {
        return proj_get_area_of_use_ex.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int proj_get_area_of_use_ex(PJ_CONTEXT *ctx, const PJ *obj, int domainIdx, double *out_west_lon_degree, double *out_south_lat_degree, double *out_east_lon_degree, double *out_north_lat_degree, const char **out_area_name)
     * }
     */
    public static MemorySegment proj_get_area_of_use_ex$address() {
        return proj_get_area_of_use_ex.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int proj_get_area_of_use_ex(PJ_CONTEXT *ctx, const PJ *obj, int domainIdx, double *out_west_lon_degree, double *out_south_lat_degree, double *out_east_lon_degree, double *out_north_lat_degree, const char **out_area_name)
     * }
     */
    public static int proj_get_area_of_use_ex(MemorySegment ctx, MemorySegment obj, int domainIdx, MemorySegment out_west_lon_degree, MemorySegment out_south_lat_degree, MemorySegment out_east_lon_degree, MemorySegment out_north_lat_degree, MemorySegment out_area_name) {
        var mh$ = proj_get_area_of_use_ex.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_get_area_of_use_ex", ctx, obj, domainIdx, out_west_lon_degree, out_south_lat_degree, out_east_lon_degree, out_north_lat_degree, out_area_name);
            }
            return (int)mh$.invokeExact(ctx, obj, domainIdx, out_west_lon_degree, out_south_lat_degree, out_east_lon_degree, out_north_lat_degree, out_area_name);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_as_wkt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_INT,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_as_wkt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *proj_as_wkt(PJ_CONTEXT *ctx, const PJ *obj, PJ_WKT_TYPE type, const char *const *options)
     * }
     */
    public static FunctionDescriptor proj_as_wkt$descriptor() {
        return proj_as_wkt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *proj_as_wkt(PJ_CONTEXT *ctx, const PJ *obj, PJ_WKT_TYPE type, const char *const *options)
     * }
     */
    public static MethodHandle proj_as_wkt$handle() {
        return proj_as_wkt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *proj_as_wkt(PJ_CONTEXT *ctx, const PJ *obj, PJ_WKT_TYPE type, const char *const *options)
     * }
     */
    public static MemorySegment proj_as_wkt$address() {
        return proj_as_wkt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *proj_as_wkt(PJ_CONTEXT *ctx, const PJ *obj, PJ_WKT_TYPE type, const char *const *options)
     * }
     */
    public static MemorySegment proj_as_wkt(MemorySegment ctx, MemorySegment obj, int type, MemorySegment options) {
        var mh$ = proj_as_wkt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_as_wkt", ctx, obj, type, options);
            }
            return (MemorySegment)mh$.invokeExact(ctx, obj, type, options);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_as_proj_string {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_INT,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_as_proj_string");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *proj_as_proj_string(PJ_CONTEXT *ctx, const PJ *obj, PJ_PROJ_STRING_TYPE type, const char *const *options)
     * }
     */
    public static FunctionDescriptor proj_as_proj_string$descriptor() {
        return proj_as_proj_string.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *proj_as_proj_string(PJ_CONTEXT *ctx, const PJ *obj, PJ_PROJ_STRING_TYPE type, const char *const *options)
     * }
     */
    public static MethodHandle proj_as_proj_string$handle() {
        return proj_as_proj_string.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *proj_as_proj_string(PJ_CONTEXT *ctx, const PJ *obj, PJ_PROJ_STRING_TYPE type, const char *const *options)
     * }
     */
    public static MemorySegment proj_as_proj_string$address() {
        return proj_as_proj_string.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *proj_as_proj_string(PJ_CONTEXT *ctx, const PJ *obj, PJ_PROJ_STRING_TYPE type, const char *const *options)
     * }
     */
    public static MemorySegment proj_as_proj_string(MemorySegment ctx, MemorySegment obj, int type, MemorySegment options) {
        var mh$ = proj_as_proj_string.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_as_proj_string", ctx, obj, type, options);
            }
            return (MemorySegment)mh$.invokeExact(ctx, obj, type, options);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_as_projjson {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_as_projjson");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *proj_as_projjson(PJ_CONTEXT *ctx, const PJ *obj, const char *const *options)
     * }
     */
    public static FunctionDescriptor proj_as_projjson$descriptor() {
        return proj_as_projjson.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *proj_as_projjson(PJ_CONTEXT *ctx, const PJ *obj, const char *const *options)
     * }
     */
    public static MethodHandle proj_as_projjson$handle() {
        return proj_as_projjson.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *proj_as_projjson(PJ_CONTEXT *ctx, const PJ *obj, const char *const *options)
     * }
     */
    public static MemorySegment proj_as_projjson$address() {
        return proj_as_projjson.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *proj_as_projjson(PJ_CONTEXT *ctx, const PJ *obj, const char *const *options)
     * }
     */
    public static MemorySegment proj_as_projjson(MemorySegment ctx, MemorySegment obj, MemorySegment options) {
        var mh$ = proj_as_projjson.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_as_projjson", ctx, obj, options);
            }
            return (MemorySegment)mh$.invokeExact(ctx, obj, options);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_get_source_crs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_get_source_crs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ *proj_get_source_crs(PJ_CONTEXT *ctx, const PJ *obj)
     * }
     */
    public static FunctionDescriptor proj_get_source_crs$descriptor() {
        return proj_get_source_crs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ *proj_get_source_crs(PJ_CONTEXT *ctx, const PJ *obj)
     * }
     */
    public static MethodHandle proj_get_source_crs$handle() {
        return proj_get_source_crs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ *proj_get_source_crs(PJ_CONTEXT *ctx, const PJ *obj)
     * }
     */
    public static MemorySegment proj_get_source_crs$address() {
        return proj_get_source_crs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ *proj_get_source_crs(PJ_CONTEXT *ctx, const PJ *obj)
     * }
     */
    public static MemorySegment proj_get_source_crs(MemorySegment ctx, MemorySegment obj) {
        var mh$ = proj_get_source_crs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_get_source_crs", ctx, obj);
            }
            return (MemorySegment)mh$.invokeExact(ctx, obj);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_get_target_crs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_get_target_crs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ *proj_get_target_crs(PJ_CONTEXT *ctx, const PJ *obj)
     * }
     */
    public static FunctionDescriptor proj_get_target_crs$descriptor() {
        return proj_get_target_crs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ *proj_get_target_crs(PJ_CONTEXT *ctx, const PJ *obj)
     * }
     */
    public static MethodHandle proj_get_target_crs$handle() {
        return proj_get_target_crs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ *proj_get_target_crs(PJ_CONTEXT *ctx, const PJ *obj)
     * }
     */
    public static MemorySegment proj_get_target_crs$address() {
        return proj_get_target_crs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ *proj_get_target_crs(PJ_CONTEXT *ctx, const PJ *obj)
     * }
     */
    public static MemorySegment proj_get_target_crs(MemorySegment ctx, MemorySegment obj) {
        var mh$ = proj_get_target_crs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_get_target_crs", ctx, obj);
            }
            return (MemorySegment)mh$.invokeExact(ctx, obj);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_identify {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_identify");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ_OBJ_LIST *proj_identify(PJ_CONTEXT *ctx, const PJ *obj, const char *auth_name, const char *const *options, int **out_confidence)
     * }
     */
    public static FunctionDescriptor proj_identify$descriptor() {
        return proj_identify.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ_OBJ_LIST *proj_identify(PJ_CONTEXT *ctx, const PJ *obj, const char *auth_name, const char *const *options, int **out_confidence)
     * }
     */
    public static MethodHandle proj_identify$handle() {
        return proj_identify.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ_OBJ_LIST *proj_identify(PJ_CONTEXT *ctx, const PJ *obj, const char *auth_name, const char *const *options, int **out_confidence)
     * }
     */
    public static MemorySegment proj_identify$address() {
        return proj_identify.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ_OBJ_LIST *proj_identify(PJ_CONTEXT *ctx, const PJ *obj, const char *auth_name, const char *const *options, int **out_confidence)
     * }
     */
    public static MemorySegment proj_identify(MemorySegment ctx, MemorySegment obj, MemorySegment auth_name, MemorySegment options, MemorySegment out_confidence) {
        var mh$ = proj_identify.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_identify", ctx, obj, auth_name, options, out_confidence);
            }
            return (MemorySegment)mh$.invokeExact(ctx, obj, auth_name, options, out_confidence);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_get_geoid_models_from_database {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_get_geoid_models_from_database");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PROJ_STRING_LIST proj_get_geoid_models_from_database(PJ_CONTEXT *ctx, const char *auth_name, const char *code, const char *const *options)
     * }
     */
    public static FunctionDescriptor proj_get_geoid_models_from_database$descriptor() {
        return proj_get_geoid_models_from_database.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PROJ_STRING_LIST proj_get_geoid_models_from_database(PJ_CONTEXT *ctx, const char *auth_name, const char *code, const char *const *options)
     * }
     */
    public static MethodHandle proj_get_geoid_models_from_database$handle() {
        return proj_get_geoid_models_from_database.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PROJ_STRING_LIST proj_get_geoid_models_from_database(PJ_CONTEXT *ctx, const char *auth_name, const char *code, const char *const *options)
     * }
     */
    public static MemorySegment proj_get_geoid_models_from_database$address() {
        return proj_get_geoid_models_from_database.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PROJ_STRING_LIST proj_get_geoid_models_from_database(PJ_CONTEXT *ctx, const char *auth_name, const char *code, const char *const *options)
     * }
     */
    public static MemorySegment proj_get_geoid_models_from_database(MemorySegment ctx, MemorySegment auth_name, MemorySegment code, MemorySegment options) {
        var mh$ = proj_get_geoid_models_from_database.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_get_geoid_models_from_database", ctx, auth_name, code, options);
            }
            return (MemorySegment)mh$.invokeExact(ctx, auth_name, code, options);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_int_list_destroy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_int_list_destroy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void proj_int_list_destroy(int *list)
     * }
     */
    public static FunctionDescriptor proj_int_list_destroy$descriptor() {
        return proj_int_list_destroy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void proj_int_list_destroy(int *list)
     * }
     */
    public static MethodHandle proj_int_list_destroy$handle() {
        return proj_int_list_destroy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void proj_int_list_destroy(int *list)
     * }
     */
    public static MemorySegment proj_int_list_destroy$address() {
        return proj_int_list_destroy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void proj_int_list_destroy(int *list)
     * }
     */
    public static void proj_int_list_destroy(MemorySegment list) {
        var mh$ = proj_int_list_destroy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_int_list_destroy", list);
            }
            mh$.invokeExact(list);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_get_authorities_from_database {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_get_authorities_from_database");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PROJ_STRING_LIST proj_get_authorities_from_database(PJ_CONTEXT *ctx)
     * }
     */
    public static FunctionDescriptor proj_get_authorities_from_database$descriptor() {
        return proj_get_authorities_from_database.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PROJ_STRING_LIST proj_get_authorities_from_database(PJ_CONTEXT *ctx)
     * }
     */
    public static MethodHandle proj_get_authorities_from_database$handle() {
        return proj_get_authorities_from_database.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PROJ_STRING_LIST proj_get_authorities_from_database(PJ_CONTEXT *ctx)
     * }
     */
    public static MemorySegment proj_get_authorities_from_database$address() {
        return proj_get_authorities_from_database.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PROJ_STRING_LIST proj_get_authorities_from_database(PJ_CONTEXT *ctx)
     * }
     */
    public static MemorySegment proj_get_authorities_from_database(MemorySegment ctx) {
        var mh$ = proj_get_authorities_from_database.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_get_authorities_from_database", ctx);
            }
            return (MemorySegment)mh$.invokeExact(ctx);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_get_codes_from_database {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_INT,
            proj_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_get_codes_from_database");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PROJ_STRING_LIST proj_get_codes_from_database(PJ_CONTEXT *ctx, const char *auth_name, PJ_TYPE type, int allow_deprecated)
     * }
     */
    public static FunctionDescriptor proj_get_codes_from_database$descriptor() {
        return proj_get_codes_from_database.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PROJ_STRING_LIST proj_get_codes_from_database(PJ_CONTEXT *ctx, const char *auth_name, PJ_TYPE type, int allow_deprecated)
     * }
     */
    public static MethodHandle proj_get_codes_from_database$handle() {
        return proj_get_codes_from_database.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PROJ_STRING_LIST proj_get_codes_from_database(PJ_CONTEXT *ctx, const char *auth_name, PJ_TYPE type, int allow_deprecated)
     * }
     */
    public static MemorySegment proj_get_codes_from_database$address() {
        return proj_get_codes_from_database.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PROJ_STRING_LIST proj_get_codes_from_database(PJ_CONTEXT *ctx, const char *auth_name, PJ_TYPE type, int allow_deprecated)
     * }
     */
    public static MemorySegment proj_get_codes_from_database(MemorySegment ctx, MemorySegment auth_name, int type, int allow_deprecated) {
        var mh$ = proj_get_codes_from_database.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_get_codes_from_database", ctx, auth_name, type, allow_deprecated);
            }
            return (MemorySegment)mh$.invokeExact(ctx, auth_name, type, allow_deprecated);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_get_celestial_body_list_from_database {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_get_celestial_body_list_from_database");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PROJ_CELESTIAL_BODY_INFO **proj_get_celestial_body_list_from_database(PJ_CONTEXT *ctx, const char *auth_name, int *out_result_count)
     * }
     */
    public static FunctionDescriptor proj_get_celestial_body_list_from_database$descriptor() {
        return proj_get_celestial_body_list_from_database.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PROJ_CELESTIAL_BODY_INFO **proj_get_celestial_body_list_from_database(PJ_CONTEXT *ctx, const char *auth_name, int *out_result_count)
     * }
     */
    public static MethodHandle proj_get_celestial_body_list_from_database$handle() {
        return proj_get_celestial_body_list_from_database.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PROJ_CELESTIAL_BODY_INFO **proj_get_celestial_body_list_from_database(PJ_CONTEXT *ctx, const char *auth_name, int *out_result_count)
     * }
     */
    public static MemorySegment proj_get_celestial_body_list_from_database$address() {
        return proj_get_celestial_body_list_from_database.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PROJ_CELESTIAL_BODY_INFO **proj_get_celestial_body_list_from_database(PJ_CONTEXT *ctx, const char *auth_name, int *out_result_count)
     * }
     */
    public static MemorySegment proj_get_celestial_body_list_from_database(MemorySegment ctx, MemorySegment auth_name, MemorySegment out_result_count) {
        var mh$ = proj_get_celestial_body_list_from_database.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_get_celestial_body_list_from_database", ctx, auth_name, out_result_count);
            }
            return (MemorySegment)mh$.invokeExact(ctx, auth_name, out_result_count);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_celestial_body_list_destroy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_celestial_body_list_destroy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void proj_celestial_body_list_destroy(PROJ_CELESTIAL_BODY_INFO **list)
     * }
     */
    public static FunctionDescriptor proj_celestial_body_list_destroy$descriptor() {
        return proj_celestial_body_list_destroy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void proj_celestial_body_list_destroy(PROJ_CELESTIAL_BODY_INFO **list)
     * }
     */
    public static MethodHandle proj_celestial_body_list_destroy$handle() {
        return proj_celestial_body_list_destroy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void proj_celestial_body_list_destroy(PROJ_CELESTIAL_BODY_INFO **list)
     * }
     */
    public static MemorySegment proj_celestial_body_list_destroy$address() {
        return proj_celestial_body_list_destroy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void proj_celestial_body_list_destroy(PROJ_CELESTIAL_BODY_INFO **list)
     * }
     */
    public static void proj_celestial_body_list_destroy(MemorySegment list) {
        var mh$ = proj_celestial_body_list_destroy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_celestial_body_list_destroy", list);
            }
            mh$.invokeExact(list);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_get_crs_list_parameters_create {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_get_crs_list_parameters_create");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PROJ_CRS_LIST_PARAMETERS *proj_get_crs_list_parameters_create()
     * }
     */
    public static FunctionDescriptor proj_get_crs_list_parameters_create$descriptor() {
        return proj_get_crs_list_parameters_create.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PROJ_CRS_LIST_PARAMETERS *proj_get_crs_list_parameters_create()
     * }
     */
    public static MethodHandle proj_get_crs_list_parameters_create$handle() {
        return proj_get_crs_list_parameters_create.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PROJ_CRS_LIST_PARAMETERS *proj_get_crs_list_parameters_create()
     * }
     */
    public static MemorySegment proj_get_crs_list_parameters_create$address() {
        return proj_get_crs_list_parameters_create.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PROJ_CRS_LIST_PARAMETERS *proj_get_crs_list_parameters_create()
     * }
     */
    public static MemorySegment proj_get_crs_list_parameters_create() {
        var mh$ = proj_get_crs_list_parameters_create.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_get_crs_list_parameters_create");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_get_crs_list_parameters_destroy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_get_crs_list_parameters_destroy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void proj_get_crs_list_parameters_destroy(PROJ_CRS_LIST_PARAMETERS *params)
     * }
     */
    public static FunctionDescriptor proj_get_crs_list_parameters_destroy$descriptor() {
        return proj_get_crs_list_parameters_destroy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void proj_get_crs_list_parameters_destroy(PROJ_CRS_LIST_PARAMETERS *params)
     * }
     */
    public static MethodHandle proj_get_crs_list_parameters_destroy$handle() {
        return proj_get_crs_list_parameters_destroy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void proj_get_crs_list_parameters_destroy(PROJ_CRS_LIST_PARAMETERS *params)
     * }
     */
    public static MemorySegment proj_get_crs_list_parameters_destroy$address() {
        return proj_get_crs_list_parameters_destroy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void proj_get_crs_list_parameters_destroy(PROJ_CRS_LIST_PARAMETERS *params)
     * }
     */
    public static void proj_get_crs_list_parameters_destroy(MemorySegment params) {
        var mh$ = proj_get_crs_list_parameters_destroy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_get_crs_list_parameters_destroy", params);
            }
            mh$.invokeExact(params);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_get_crs_info_list_from_database {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_get_crs_info_list_from_database");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PROJ_CRS_INFO **proj_get_crs_info_list_from_database(PJ_CONTEXT *ctx, const char *auth_name, const PROJ_CRS_LIST_PARAMETERS *params, int *out_result_count)
     * }
     */
    public static FunctionDescriptor proj_get_crs_info_list_from_database$descriptor() {
        return proj_get_crs_info_list_from_database.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PROJ_CRS_INFO **proj_get_crs_info_list_from_database(PJ_CONTEXT *ctx, const char *auth_name, const PROJ_CRS_LIST_PARAMETERS *params, int *out_result_count)
     * }
     */
    public static MethodHandle proj_get_crs_info_list_from_database$handle() {
        return proj_get_crs_info_list_from_database.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PROJ_CRS_INFO **proj_get_crs_info_list_from_database(PJ_CONTEXT *ctx, const char *auth_name, const PROJ_CRS_LIST_PARAMETERS *params, int *out_result_count)
     * }
     */
    public static MemorySegment proj_get_crs_info_list_from_database$address() {
        return proj_get_crs_info_list_from_database.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PROJ_CRS_INFO **proj_get_crs_info_list_from_database(PJ_CONTEXT *ctx, const char *auth_name, const PROJ_CRS_LIST_PARAMETERS *params, int *out_result_count)
     * }
     */
    public static MemorySegment proj_get_crs_info_list_from_database(MemorySegment ctx, MemorySegment auth_name, MemorySegment params, MemorySegment out_result_count) {
        var mh$ = proj_get_crs_info_list_from_database.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_get_crs_info_list_from_database", ctx, auth_name, params, out_result_count);
            }
            return (MemorySegment)mh$.invokeExact(ctx, auth_name, params, out_result_count);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_crs_info_list_destroy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_crs_info_list_destroy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void proj_crs_info_list_destroy(PROJ_CRS_INFO **list)
     * }
     */
    public static FunctionDescriptor proj_crs_info_list_destroy$descriptor() {
        return proj_crs_info_list_destroy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void proj_crs_info_list_destroy(PROJ_CRS_INFO **list)
     * }
     */
    public static MethodHandle proj_crs_info_list_destroy$handle() {
        return proj_crs_info_list_destroy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void proj_crs_info_list_destroy(PROJ_CRS_INFO **list)
     * }
     */
    public static MemorySegment proj_crs_info_list_destroy$address() {
        return proj_crs_info_list_destroy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void proj_crs_info_list_destroy(PROJ_CRS_INFO **list)
     * }
     */
    public static void proj_crs_info_list_destroy(MemorySegment list) {
        var mh$ = proj_crs_info_list_destroy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_crs_info_list_destroy", list);
            }
            mh$.invokeExact(list);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_get_units_from_database {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_INT,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_get_units_from_database");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PROJ_UNIT_INFO **proj_get_units_from_database(PJ_CONTEXT *ctx, const char *auth_name, const char *category, int allow_deprecated, int *out_result_count)
     * }
     */
    public static FunctionDescriptor proj_get_units_from_database$descriptor() {
        return proj_get_units_from_database.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PROJ_UNIT_INFO **proj_get_units_from_database(PJ_CONTEXT *ctx, const char *auth_name, const char *category, int allow_deprecated, int *out_result_count)
     * }
     */
    public static MethodHandle proj_get_units_from_database$handle() {
        return proj_get_units_from_database.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PROJ_UNIT_INFO **proj_get_units_from_database(PJ_CONTEXT *ctx, const char *auth_name, const char *category, int allow_deprecated, int *out_result_count)
     * }
     */
    public static MemorySegment proj_get_units_from_database$address() {
        return proj_get_units_from_database.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PROJ_UNIT_INFO **proj_get_units_from_database(PJ_CONTEXT *ctx, const char *auth_name, const char *category, int allow_deprecated, int *out_result_count)
     * }
     */
    public static MemorySegment proj_get_units_from_database(MemorySegment ctx, MemorySegment auth_name, MemorySegment category, int allow_deprecated, MemorySegment out_result_count) {
        var mh$ = proj_get_units_from_database.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_get_units_from_database", ctx, auth_name, category, allow_deprecated, out_result_count);
            }
            return (MemorySegment)mh$.invokeExact(ctx, auth_name, category, allow_deprecated, out_result_count);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_unit_list_destroy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_unit_list_destroy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void proj_unit_list_destroy(PROJ_UNIT_INFO **list)
     * }
     */
    public static FunctionDescriptor proj_unit_list_destroy$descriptor() {
        return proj_unit_list_destroy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void proj_unit_list_destroy(PROJ_UNIT_INFO **list)
     * }
     */
    public static MethodHandle proj_unit_list_destroy$handle() {
        return proj_unit_list_destroy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void proj_unit_list_destroy(PROJ_UNIT_INFO **list)
     * }
     */
    public static MemorySegment proj_unit_list_destroy$address() {
        return proj_unit_list_destroy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void proj_unit_list_destroy(PROJ_UNIT_INFO **list)
     * }
     */
    public static void proj_unit_list_destroy(MemorySegment list) {
        var mh$ = proj_unit_list_destroy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_unit_list_destroy", list);
            }
            mh$.invokeExact(list);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_insert_object_session_create {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_insert_object_session_create");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ_INSERT_SESSION *proj_insert_object_session_create(PJ_CONTEXT *ctx)
     * }
     */
    public static FunctionDescriptor proj_insert_object_session_create$descriptor() {
        return proj_insert_object_session_create.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ_INSERT_SESSION *proj_insert_object_session_create(PJ_CONTEXT *ctx)
     * }
     */
    public static MethodHandle proj_insert_object_session_create$handle() {
        return proj_insert_object_session_create.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ_INSERT_SESSION *proj_insert_object_session_create(PJ_CONTEXT *ctx)
     * }
     */
    public static MemorySegment proj_insert_object_session_create$address() {
        return proj_insert_object_session_create.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ_INSERT_SESSION *proj_insert_object_session_create(PJ_CONTEXT *ctx)
     * }
     */
    public static MemorySegment proj_insert_object_session_create(MemorySegment ctx) {
        var mh$ = proj_insert_object_session_create.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_insert_object_session_create", ctx);
            }
            return (MemorySegment)mh$.invokeExact(ctx);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_insert_object_session_destroy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_insert_object_session_destroy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void proj_insert_object_session_destroy(PJ_CONTEXT *ctx, PJ_INSERT_SESSION *session)
     * }
     */
    public static FunctionDescriptor proj_insert_object_session_destroy$descriptor() {
        return proj_insert_object_session_destroy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void proj_insert_object_session_destroy(PJ_CONTEXT *ctx, PJ_INSERT_SESSION *session)
     * }
     */
    public static MethodHandle proj_insert_object_session_destroy$handle() {
        return proj_insert_object_session_destroy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void proj_insert_object_session_destroy(PJ_CONTEXT *ctx, PJ_INSERT_SESSION *session)
     * }
     */
    public static MemorySegment proj_insert_object_session_destroy$address() {
        return proj_insert_object_session_destroy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void proj_insert_object_session_destroy(PJ_CONTEXT *ctx, PJ_INSERT_SESSION *session)
     * }
     */
    public static void proj_insert_object_session_destroy(MemorySegment ctx, MemorySegment session) {
        var mh$ = proj_insert_object_session_destroy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_insert_object_session_destroy", ctx, session);
            }
            mh$.invokeExact(ctx, session);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_get_insert_statements {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_INT,
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_get_insert_statements");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PROJ_STRING_LIST proj_get_insert_statements(PJ_CONTEXT *ctx, PJ_INSERT_SESSION *session, const PJ *object, const char *authority, const char *code, int numeric_codes, const char *const *allowed_authorities, const char *const *options)
     * }
     */
    public static FunctionDescriptor proj_get_insert_statements$descriptor() {
        return proj_get_insert_statements.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PROJ_STRING_LIST proj_get_insert_statements(PJ_CONTEXT *ctx, PJ_INSERT_SESSION *session, const PJ *object, const char *authority, const char *code, int numeric_codes, const char *const *allowed_authorities, const char *const *options)
     * }
     */
    public static MethodHandle proj_get_insert_statements$handle() {
        return proj_get_insert_statements.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PROJ_STRING_LIST proj_get_insert_statements(PJ_CONTEXT *ctx, PJ_INSERT_SESSION *session, const PJ *object, const char *authority, const char *code, int numeric_codes, const char *const *allowed_authorities, const char *const *options)
     * }
     */
    public static MemorySegment proj_get_insert_statements$address() {
        return proj_get_insert_statements.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PROJ_STRING_LIST proj_get_insert_statements(PJ_CONTEXT *ctx, PJ_INSERT_SESSION *session, const PJ *object, const char *authority, const char *code, int numeric_codes, const char *const *allowed_authorities, const char *const *options)
     * }
     */
    public static MemorySegment proj_get_insert_statements(MemorySegment ctx, MemorySegment session, MemorySegment object, MemorySegment authority, MemorySegment code, int numeric_codes, MemorySegment allowed_authorities, MemorySegment options) {
        var mh$ = proj_get_insert_statements.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_get_insert_statements", ctx, session, object, authority, code, numeric_codes, allowed_authorities, options);
            }
            return (MemorySegment)mh$.invokeExact(ctx, session, object, authority, code, numeric_codes, allowed_authorities, options);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_suggests_code_for {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_INT,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_suggests_code_for");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *proj_suggests_code_for(PJ_CONTEXT *ctx, const PJ *object, const char *authority, int numeric_code, const char *const *options)
     * }
     */
    public static FunctionDescriptor proj_suggests_code_for$descriptor() {
        return proj_suggests_code_for.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *proj_suggests_code_for(PJ_CONTEXT *ctx, const PJ *object, const char *authority, int numeric_code, const char *const *options)
     * }
     */
    public static MethodHandle proj_suggests_code_for$handle() {
        return proj_suggests_code_for.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *proj_suggests_code_for(PJ_CONTEXT *ctx, const PJ *object, const char *authority, int numeric_code, const char *const *options)
     * }
     */
    public static MemorySegment proj_suggests_code_for$address() {
        return proj_suggests_code_for.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *proj_suggests_code_for(PJ_CONTEXT *ctx, const PJ *object, const char *authority, int numeric_code, const char *const *options)
     * }
     */
    public static MemorySegment proj_suggests_code_for(MemorySegment ctx, MemorySegment object, MemorySegment authority, int numeric_code, MemorySegment options) {
        var mh$ = proj_suggests_code_for.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_suggests_code_for", ctx, object, authority, numeric_code, options);
            }
            return (MemorySegment)mh$.invokeExact(ctx, object, authority, numeric_code, options);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_string_destroy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_string_destroy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void proj_string_destroy(char *str)
     * }
     */
    public static FunctionDescriptor proj_string_destroy$descriptor() {
        return proj_string_destroy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void proj_string_destroy(char *str)
     * }
     */
    public static MethodHandle proj_string_destroy$handle() {
        return proj_string_destroy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void proj_string_destroy(char *str)
     * }
     */
    public static MemorySegment proj_string_destroy$address() {
        return proj_string_destroy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void proj_string_destroy(char *str)
     * }
     */
    public static void proj_string_destroy(MemorySegment str) {
        var mh$ = proj_string_destroy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_string_destroy", str);
            }
            mh$.invokeExact(str);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_create_operation_factory_context {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_create_operation_factory_context");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ_OPERATION_FACTORY_CONTEXT *proj_create_operation_factory_context(PJ_CONTEXT *ctx, const char *authority)
     * }
     */
    public static FunctionDescriptor proj_create_operation_factory_context$descriptor() {
        return proj_create_operation_factory_context.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ_OPERATION_FACTORY_CONTEXT *proj_create_operation_factory_context(PJ_CONTEXT *ctx, const char *authority)
     * }
     */
    public static MethodHandle proj_create_operation_factory_context$handle() {
        return proj_create_operation_factory_context.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ_OPERATION_FACTORY_CONTEXT *proj_create_operation_factory_context(PJ_CONTEXT *ctx, const char *authority)
     * }
     */
    public static MemorySegment proj_create_operation_factory_context$address() {
        return proj_create_operation_factory_context.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ_OPERATION_FACTORY_CONTEXT *proj_create_operation_factory_context(PJ_CONTEXT *ctx, const char *authority)
     * }
     */
    public static MemorySegment proj_create_operation_factory_context(MemorySegment ctx, MemorySegment authority) {
        var mh$ = proj_create_operation_factory_context.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_create_operation_factory_context", ctx, authority);
            }
            return (MemorySegment)mh$.invokeExact(ctx, authority);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_operation_factory_context_destroy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_operation_factory_context_destroy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void proj_operation_factory_context_destroy(PJ_OPERATION_FACTORY_CONTEXT *ctx)
     * }
     */
    public static FunctionDescriptor proj_operation_factory_context_destroy$descriptor() {
        return proj_operation_factory_context_destroy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void proj_operation_factory_context_destroy(PJ_OPERATION_FACTORY_CONTEXT *ctx)
     * }
     */
    public static MethodHandle proj_operation_factory_context_destroy$handle() {
        return proj_operation_factory_context_destroy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void proj_operation_factory_context_destroy(PJ_OPERATION_FACTORY_CONTEXT *ctx)
     * }
     */
    public static MemorySegment proj_operation_factory_context_destroy$address() {
        return proj_operation_factory_context_destroy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void proj_operation_factory_context_destroy(PJ_OPERATION_FACTORY_CONTEXT *ctx)
     * }
     */
    public static void proj_operation_factory_context_destroy(MemorySegment ctx) {
        var mh$ = proj_operation_factory_context_destroy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_operation_factory_context_destroy", ctx);
            }
            mh$.invokeExact(ctx);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_operation_factory_context_set_desired_accuracy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_operation_factory_context_set_desired_accuracy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void proj_operation_factory_context_set_desired_accuracy(PJ_CONTEXT *ctx, PJ_OPERATION_FACTORY_CONTEXT *factory_ctx, double accuracy)
     * }
     */
    public static FunctionDescriptor proj_operation_factory_context_set_desired_accuracy$descriptor() {
        return proj_operation_factory_context_set_desired_accuracy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void proj_operation_factory_context_set_desired_accuracy(PJ_CONTEXT *ctx, PJ_OPERATION_FACTORY_CONTEXT *factory_ctx, double accuracy)
     * }
     */
    public static MethodHandle proj_operation_factory_context_set_desired_accuracy$handle() {
        return proj_operation_factory_context_set_desired_accuracy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void proj_operation_factory_context_set_desired_accuracy(PJ_CONTEXT *ctx, PJ_OPERATION_FACTORY_CONTEXT *factory_ctx, double accuracy)
     * }
     */
    public static MemorySegment proj_operation_factory_context_set_desired_accuracy$address() {
        return proj_operation_factory_context_set_desired_accuracy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void proj_operation_factory_context_set_desired_accuracy(PJ_CONTEXT *ctx, PJ_OPERATION_FACTORY_CONTEXT *factory_ctx, double accuracy)
     * }
     */
    public static void proj_operation_factory_context_set_desired_accuracy(MemorySegment ctx, MemorySegment factory_ctx, double accuracy) {
        var mh$ = proj_operation_factory_context_set_desired_accuracy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_operation_factory_context_set_desired_accuracy", ctx, factory_ctx, accuracy);
            }
            mh$.invokeExact(ctx, factory_ctx, accuracy);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_operation_factory_context_set_area_of_interest {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_operation_factory_context_set_area_of_interest");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void proj_operation_factory_context_set_area_of_interest(PJ_CONTEXT *ctx, PJ_OPERATION_FACTORY_CONTEXT *factory_ctx, double west_lon_degree, double south_lat_degree, double east_lon_degree, double north_lat_degree)
     * }
     */
    public static FunctionDescriptor proj_operation_factory_context_set_area_of_interest$descriptor() {
        return proj_operation_factory_context_set_area_of_interest.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void proj_operation_factory_context_set_area_of_interest(PJ_CONTEXT *ctx, PJ_OPERATION_FACTORY_CONTEXT *factory_ctx, double west_lon_degree, double south_lat_degree, double east_lon_degree, double north_lat_degree)
     * }
     */
    public static MethodHandle proj_operation_factory_context_set_area_of_interest$handle() {
        return proj_operation_factory_context_set_area_of_interest.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void proj_operation_factory_context_set_area_of_interest(PJ_CONTEXT *ctx, PJ_OPERATION_FACTORY_CONTEXT *factory_ctx, double west_lon_degree, double south_lat_degree, double east_lon_degree, double north_lat_degree)
     * }
     */
    public static MemorySegment proj_operation_factory_context_set_area_of_interest$address() {
        return proj_operation_factory_context_set_area_of_interest.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void proj_operation_factory_context_set_area_of_interest(PJ_CONTEXT *ctx, PJ_OPERATION_FACTORY_CONTEXT *factory_ctx, double west_lon_degree, double south_lat_degree, double east_lon_degree, double north_lat_degree)
     * }
     */
    public static void proj_operation_factory_context_set_area_of_interest(MemorySegment ctx, MemorySegment factory_ctx, double west_lon_degree, double south_lat_degree, double east_lon_degree, double north_lat_degree) {
        var mh$ = proj_operation_factory_context_set_area_of_interest.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_operation_factory_context_set_area_of_interest", ctx, factory_ctx, west_lon_degree, south_lat_degree, east_lon_degree, north_lat_degree);
            }
            mh$.invokeExact(ctx, factory_ctx, west_lon_degree, south_lat_degree, east_lon_degree, north_lat_degree);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_operation_factory_context_set_area_of_interest_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_operation_factory_context_set_area_of_interest_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void proj_operation_factory_context_set_area_of_interest_name(PJ_CONTEXT *ctx, PJ_OPERATION_FACTORY_CONTEXT *factory_ctx, const char *area_name)
     * }
     */
    public static FunctionDescriptor proj_operation_factory_context_set_area_of_interest_name$descriptor() {
        return proj_operation_factory_context_set_area_of_interest_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void proj_operation_factory_context_set_area_of_interest_name(PJ_CONTEXT *ctx, PJ_OPERATION_FACTORY_CONTEXT *factory_ctx, const char *area_name)
     * }
     */
    public static MethodHandle proj_operation_factory_context_set_area_of_interest_name$handle() {
        return proj_operation_factory_context_set_area_of_interest_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void proj_operation_factory_context_set_area_of_interest_name(PJ_CONTEXT *ctx, PJ_OPERATION_FACTORY_CONTEXT *factory_ctx, const char *area_name)
     * }
     */
    public static MemorySegment proj_operation_factory_context_set_area_of_interest_name$address() {
        return proj_operation_factory_context_set_area_of_interest_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void proj_operation_factory_context_set_area_of_interest_name(PJ_CONTEXT *ctx, PJ_OPERATION_FACTORY_CONTEXT *factory_ctx, const char *area_name)
     * }
     */
    public static void proj_operation_factory_context_set_area_of_interest_name(MemorySegment ctx, MemorySegment factory_ctx, MemorySegment area_name) {
        var mh$ = proj_operation_factory_context_set_area_of_interest_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_operation_factory_context_set_area_of_interest_name", ctx, factory_ctx, area_name);
            }
            mh$.invokeExact(ctx, factory_ctx, area_name);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_operation_factory_context_set_crs_extent_use {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_operation_factory_context_set_crs_extent_use");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void proj_operation_factory_context_set_crs_extent_use(PJ_CONTEXT *ctx, PJ_OPERATION_FACTORY_CONTEXT *factory_ctx, PROJ_CRS_EXTENT_USE use)
     * }
     */
    public static FunctionDescriptor proj_operation_factory_context_set_crs_extent_use$descriptor() {
        return proj_operation_factory_context_set_crs_extent_use.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void proj_operation_factory_context_set_crs_extent_use(PJ_CONTEXT *ctx, PJ_OPERATION_FACTORY_CONTEXT *factory_ctx, PROJ_CRS_EXTENT_USE use)
     * }
     */
    public static MethodHandle proj_operation_factory_context_set_crs_extent_use$handle() {
        return proj_operation_factory_context_set_crs_extent_use.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void proj_operation_factory_context_set_crs_extent_use(PJ_CONTEXT *ctx, PJ_OPERATION_FACTORY_CONTEXT *factory_ctx, PROJ_CRS_EXTENT_USE use)
     * }
     */
    public static MemorySegment proj_operation_factory_context_set_crs_extent_use$address() {
        return proj_operation_factory_context_set_crs_extent_use.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void proj_operation_factory_context_set_crs_extent_use(PJ_CONTEXT *ctx, PJ_OPERATION_FACTORY_CONTEXT *factory_ctx, PROJ_CRS_EXTENT_USE use)
     * }
     */
    public static void proj_operation_factory_context_set_crs_extent_use(MemorySegment ctx, MemorySegment factory_ctx, int use) {
        var mh$ = proj_operation_factory_context_set_crs_extent_use.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_operation_factory_context_set_crs_extent_use", ctx, factory_ctx, use);
            }
            mh$.invokeExact(ctx, factory_ctx, use);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_operation_factory_context_set_spatial_criterion {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_operation_factory_context_set_spatial_criterion");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void proj_operation_factory_context_set_spatial_criterion(PJ_CONTEXT *ctx, PJ_OPERATION_FACTORY_CONTEXT *factory_ctx, PROJ_SPATIAL_CRITERION criterion)
     * }
     */
    public static FunctionDescriptor proj_operation_factory_context_set_spatial_criterion$descriptor() {
        return proj_operation_factory_context_set_spatial_criterion.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void proj_operation_factory_context_set_spatial_criterion(PJ_CONTEXT *ctx, PJ_OPERATION_FACTORY_CONTEXT *factory_ctx, PROJ_SPATIAL_CRITERION criterion)
     * }
     */
    public static MethodHandle proj_operation_factory_context_set_spatial_criterion$handle() {
        return proj_operation_factory_context_set_spatial_criterion.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void proj_operation_factory_context_set_spatial_criterion(PJ_CONTEXT *ctx, PJ_OPERATION_FACTORY_CONTEXT *factory_ctx, PROJ_SPATIAL_CRITERION criterion)
     * }
     */
    public static MemorySegment proj_operation_factory_context_set_spatial_criterion$address() {
        return proj_operation_factory_context_set_spatial_criterion.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void proj_operation_factory_context_set_spatial_criterion(PJ_CONTEXT *ctx, PJ_OPERATION_FACTORY_CONTEXT *factory_ctx, PROJ_SPATIAL_CRITERION criterion)
     * }
     */
    public static void proj_operation_factory_context_set_spatial_criterion(MemorySegment ctx, MemorySegment factory_ctx, int criterion) {
        var mh$ = proj_operation_factory_context_set_spatial_criterion.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_operation_factory_context_set_spatial_criterion", ctx, factory_ctx, criterion);
            }
            mh$.invokeExact(ctx, factory_ctx, criterion);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_operation_factory_context_set_grid_availability_use {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_operation_factory_context_set_grid_availability_use");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void proj_operation_factory_context_set_grid_availability_use(PJ_CONTEXT *ctx, PJ_OPERATION_FACTORY_CONTEXT *factory_ctx, PROJ_GRID_AVAILABILITY_USE use)
     * }
     */
    public static FunctionDescriptor proj_operation_factory_context_set_grid_availability_use$descriptor() {
        return proj_operation_factory_context_set_grid_availability_use.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void proj_operation_factory_context_set_grid_availability_use(PJ_CONTEXT *ctx, PJ_OPERATION_FACTORY_CONTEXT *factory_ctx, PROJ_GRID_AVAILABILITY_USE use)
     * }
     */
    public static MethodHandle proj_operation_factory_context_set_grid_availability_use$handle() {
        return proj_operation_factory_context_set_grid_availability_use.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void proj_operation_factory_context_set_grid_availability_use(PJ_CONTEXT *ctx, PJ_OPERATION_FACTORY_CONTEXT *factory_ctx, PROJ_GRID_AVAILABILITY_USE use)
     * }
     */
    public static MemorySegment proj_operation_factory_context_set_grid_availability_use$address() {
        return proj_operation_factory_context_set_grid_availability_use.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void proj_operation_factory_context_set_grid_availability_use(PJ_CONTEXT *ctx, PJ_OPERATION_FACTORY_CONTEXT *factory_ctx, PROJ_GRID_AVAILABILITY_USE use)
     * }
     */
    public static void proj_operation_factory_context_set_grid_availability_use(MemorySegment ctx, MemorySegment factory_ctx, int use) {
        var mh$ = proj_operation_factory_context_set_grid_availability_use.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_operation_factory_context_set_grid_availability_use", ctx, factory_ctx, use);
            }
            mh$.invokeExact(ctx, factory_ctx, use);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_operation_factory_context_set_use_proj_alternative_grid_names {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_operation_factory_context_set_use_proj_alternative_grid_names");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void proj_operation_factory_context_set_use_proj_alternative_grid_names(PJ_CONTEXT *ctx, PJ_OPERATION_FACTORY_CONTEXT *factory_ctx, int usePROJNames)
     * }
     */
    public static FunctionDescriptor proj_operation_factory_context_set_use_proj_alternative_grid_names$descriptor() {
        return proj_operation_factory_context_set_use_proj_alternative_grid_names.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void proj_operation_factory_context_set_use_proj_alternative_grid_names(PJ_CONTEXT *ctx, PJ_OPERATION_FACTORY_CONTEXT *factory_ctx, int usePROJNames)
     * }
     */
    public static MethodHandle proj_operation_factory_context_set_use_proj_alternative_grid_names$handle() {
        return proj_operation_factory_context_set_use_proj_alternative_grid_names.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void proj_operation_factory_context_set_use_proj_alternative_grid_names(PJ_CONTEXT *ctx, PJ_OPERATION_FACTORY_CONTEXT *factory_ctx, int usePROJNames)
     * }
     */
    public static MemorySegment proj_operation_factory_context_set_use_proj_alternative_grid_names$address() {
        return proj_operation_factory_context_set_use_proj_alternative_grid_names.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void proj_operation_factory_context_set_use_proj_alternative_grid_names(PJ_CONTEXT *ctx, PJ_OPERATION_FACTORY_CONTEXT *factory_ctx, int usePROJNames)
     * }
     */
    public static void proj_operation_factory_context_set_use_proj_alternative_grid_names(MemorySegment ctx, MemorySegment factory_ctx, int usePROJNames) {
        var mh$ = proj_operation_factory_context_set_use_proj_alternative_grid_names.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_operation_factory_context_set_use_proj_alternative_grid_names", ctx, factory_ctx, usePROJNames);
            }
            mh$.invokeExact(ctx, factory_ctx, usePROJNames);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_operation_factory_context_set_allow_use_intermediate_crs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_operation_factory_context_set_allow_use_intermediate_crs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void proj_operation_factory_context_set_allow_use_intermediate_crs(PJ_CONTEXT *ctx, PJ_OPERATION_FACTORY_CONTEXT *factory_ctx, PROJ_INTERMEDIATE_CRS_USE use)
     * }
     */
    public static FunctionDescriptor proj_operation_factory_context_set_allow_use_intermediate_crs$descriptor() {
        return proj_operation_factory_context_set_allow_use_intermediate_crs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void proj_operation_factory_context_set_allow_use_intermediate_crs(PJ_CONTEXT *ctx, PJ_OPERATION_FACTORY_CONTEXT *factory_ctx, PROJ_INTERMEDIATE_CRS_USE use)
     * }
     */
    public static MethodHandle proj_operation_factory_context_set_allow_use_intermediate_crs$handle() {
        return proj_operation_factory_context_set_allow_use_intermediate_crs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void proj_operation_factory_context_set_allow_use_intermediate_crs(PJ_CONTEXT *ctx, PJ_OPERATION_FACTORY_CONTEXT *factory_ctx, PROJ_INTERMEDIATE_CRS_USE use)
     * }
     */
    public static MemorySegment proj_operation_factory_context_set_allow_use_intermediate_crs$address() {
        return proj_operation_factory_context_set_allow_use_intermediate_crs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void proj_operation_factory_context_set_allow_use_intermediate_crs(PJ_CONTEXT *ctx, PJ_OPERATION_FACTORY_CONTEXT *factory_ctx, PROJ_INTERMEDIATE_CRS_USE use)
     * }
     */
    public static void proj_operation_factory_context_set_allow_use_intermediate_crs(MemorySegment ctx, MemorySegment factory_ctx, int use) {
        var mh$ = proj_operation_factory_context_set_allow_use_intermediate_crs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_operation_factory_context_set_allow_use_intermediate_crs", ctx, factory_ctx, use);
            }
            mh$.invokeExact(ctx, factory_ctx, use);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_operation_factory_context_set_allowed_intermediate_crs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_operation_factory_context_set_allowed_intermediate_crs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void proj_operation_factory_context_set_allowed_intermediate_crs(PJ_CONTEXT *ctx, PJ_OPERATION_FACTORY_CONTEXT *factory_ctx, const char *const *list_of_auth_name_codes)
     * }
     */
    public static FunctionDescriptor proj_operation_factory_context_set_allowed_intermediate_crs$descriptor() {
        return proj_operation_factory_context_set_allowed_intermediate_crs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void proj_operation_factory_context_set_allowed_intermediate_crs(PJ_CONTEXT *ctx, PJ_OPERATION_FACTORY_CONTEXT *factory_ctx, const char *const *list_of_auth_name_codes)
     * }
     */
    public static MethodHandle proj_operation_factory_context_set_allowed_intermediate_crs$handle() {
        return proj_operation_factory_context_set_allowed_intermediate_crs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void proj_operation_factory_context_set_allowed_intermediate_crs(PJ_CONTEXT *ctx, PJ_OPERATION_FACTORY_CONTEXT *factory_ctx, const char *const *list_of_auth_name_codes)
     * }
     */
    public static MemorySegment proj_operation_factory_context_set_allowed_intermediate_crs$address() {
        return proj_operation_factory_context_set_allowed_intermediate_crs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void proj_operation_factory_context_set_allowed_intermediate_crs(PJ_CONTEXT *ctx, PJ_OPERATION_FACTORY_CONTEXT *factory_ctx, const char *const *list_of_auth_name_codes)
     * }
     */
    public static void proj_operation_factory_context_set_allowed_intermediate_crs(MemorySegment ctx, MemorySegment factory_ctx, MemorySegment list_of_auth_name_codes) {
        var mh$ = proj_operation_factory_context_set_allowed_intermediate_crs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_operation_factory_context_set_allowed_intermediate_crs", ctx, factory_ctx, list_of_auth_name_codes);
            }
            mh$.invokeExact(ctx, factory_ctx, list_of_auth_name_codes);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_operation_factory_context_set_discard_superseded {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_operation_factory_context_set_discard_superseded");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void proj_operation_factory_context_set_discard_superseded(PJ_CONTEXT *ctx, PJ_OPERATION_FACTORY_CONTEXT *factory_ctx, int discard)
     * }
     */
    public static FunctionDescriptor proj_operation_factory_context_set_discard_superseded$descriptor() {
        return proj_operation_factory_context_set_discard_superseded.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void proj_operation_factory_context_set_discard_superseded(PJ_CONTEXT *ctx, PJ_OPERATION_FACTORY_CONTEXT *factory_ctx, int discard)
     * }
     */
    public static MethodHandle proj_operation_factory_context_set_discard_superseded$handle() {
        return proj_operation_factory_context_set_discard_superseded.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void proj_operation_factory_context_set_discard_superseded(PJ_CONTEXT *ctx, PJ_OPERATION_FACTORY_CONTEXT *factory_ctx, int discard)
     * }
     */
    public static MemorySegment proj_operation_factory_context_set_discard_superseded$address() {
        return proj_operation_factory_context_set_discard_superseded.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void proj_operation_factory_context_set_discard_superseded(PJ_CONTEXT *ctx, PJ_OPERATION_FACTORY_CONTEXT *factory_ctx, int discard)
     * }
     */
    public static void proj_operation_factory_context_set_discard_superseded(MemorySegment ctx, MemorySegment factory_ctx, int discard) {
        var mh$ = proj_operation_factory_context_set_discard_superseded.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_operation_factory_context_set_discard_superseded", ctx, factory_ctx, discard);
            }
            mh$.invokeExact(ctx, factory_ctx, discard);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_operation_factory_context_set_allow_ballpark_transformations {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_operation_factory_context_set_allow_ballpark_transformations");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void proj_operation_factory_context_set_allow_ballpark_transformations(PJ_CONTEXT *ctx, PJ_OPERATION_FACTORY_CONTEXT *factory_ctx, int allow)
     * }
     */
    public static FunctionDescriptor proj_operation_factory_context_set_allow_ballpark_transformations$descriptor() {
        return proj_operation_factory_context_set_allow_ballpark_transformations.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void proj_operation_factory_context_set_allow_ballpark_transformations(PJ_CONTEXT *ctx, PJ_OPERATION_FACTORY_CONTEXT *factory_ctx, int allow)
     * }
     */
    public static MethodHandle proj_operation_factory_context_set_allow_ballpark_transformations$handle() {
        return proj_operation_factory_context_set_allow_ballpark_transformations.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void proj_operation_factory_context_set_allow_ballpark_transformations(PJ_CONTEXT *ctx, PJ_OPERATION_FACTORY_CONTEXT *factory_ctx, int allow)
     * }
     */
    public static MemorySegment proj_operation_factory_context_set_allow_ballpark_transformations$address() {
        return proj_operation_factory_context_set_allow_ballpark_transformations.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void proj_operation_factory_context_set_allow_ballpark_transformations(PJ_CONTEXT *ctx, PJ_OPERATION_FACTORY_CONTEXT *factory_ctx, int allow)
     * }
     */
    public static void proj_operation_factory_context_set_allow_ballpark_transformations(MemorySegment ctx, MemorySegment factory_ctx, int allow) {
        var mh$ = proj_operation_factory_context_set_allow_ballpark_transformations.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_operation_factory_context_set_allow_ballpark_transformations", ctx, factory_ctx, allow);
            }
            mh$.invokeExact(ctx, factory_ctx, allow);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_create_operations {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_create_operations");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ_OBJ_LIST *proj_create_operations(PJ_CONTEXT *ctx, const PJ *source_crs, const PJ *target_crs, const PJ_OPERATION_FACTORY_CONTEXT *operationContext)
     * }
     */
    public static FunctionDescriptor proj_create_operations$descriptor() {
        return proj_create_operations.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ_OBJ_LIST *proj_create_operations(PJ_CONTEXT *ctx, const PJ *source_crs, const PJ *target_crs, const PJ_OPERATION_FACTORY_CONTEXT *operationContext)
     * }
     */
    public static MethodHandle proj_create_operations$handle() {
        return proj_create_operations.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ_OBJ_LIST *proj_create_operations(PJ_CONTEXT *ctx, const PJ *source_crs, const PJ *target_crs, const PJ_OPERATION_FACTORY_CONTEXT *operationContext)
     * }
     */
    public static MemorySegment proj_create_operations$address() {
        return proj_create_operations.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ_OBJ_LIST *proj_create_operations(PJ_CONTEXT *ctx, const PJ *source_crs, const PJ *target_crs, const PJ_OPERATION_FACTORY_CONTEXT *operationContext)
     * }
     */
    public static MemorySegment proj_create_operations(MemorySegment ctx, MemorySegment source_crs, MemorySegment target_crs, MemorySegment operationContext) {
        var mh$ = proj_create_operations.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_create_operations", ctx, source_crs, target_crs, operationContext);
            }
            return (MemorySegment)mh$.invokeExact(ctx, source_crs, target_crs, operationContext);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_list_get_count {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_INT,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_list_get_count");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int proj_list_get_count(const PJ_OBJ_LIST *result)
     * }
     */
    public static FunctionDescriptor proj_list_get_count$descriptor() {
        return proj_list_get_count.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int proj_list_get_count(const PJ_OBJ_LIST *result)
     * }
     */
    public static MethodHandle proj_list_get_count$handle() {
        return proj_list_get_count.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int proj_list_get_count(const PJ_OBJ_LIST *result)
     * }
     */
    public static MemorySegment proj_list_get_count$address() {
        return proj_list_get_count.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int proj_list_get_count(const PJ_OBJ_LIST *result)
     * }
     */
    public static int proj_list_get_count(MemorySegment result) {
        var mh$ = proj_list_get_count.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_list_get_count", result);
            }
            return (int)mh$.invokeExact(result);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_list_get {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_list_get");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ *proj_list_get(PJ_CONTEXT *ctx, const PJ_OBJ_LIST *result, int index)
     * }
     */
    public static FunctionDescriptor proj_list_get$descriptor() {
        return proj_list_get.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ *proj_list_get(PJ_CONTEXT *ctx, const PJ_OBJ_LIST *result, int index)
     * }
     */
    public static MethodHandle proj_list_get$handle() {
        return proj_list_get.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ *proj_list_get(PJ_CONTEXT *ctx, const PJ_OBJ_LIST *result, int index)
     * }
     */
    public static MemorySegment proj_list_get$address() {
        return proj_list_get.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ *proj_list_get(PJ_CONTEXT *ctx, const PJ_OBJ_LIST *result, int index)
     * }
     */
    public static MemorySegment proj_list_get(MemorySegment ctx, MemorySegment result, int index) {
        var mh$ = proj_list_get.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_list_get", ctx, result, index);
            }
            return (MemorySegment)mh$.invokeExact(ctx, result, index);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_list_destroy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_list_destroy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void proj_list_destroy(PJ_OBJ_LIST *result)
     * }
     */
    public static FunctionDescriptor proj_list_destroy$descriptor() {
        return proj_list_destroy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void proj_list_destroy(PJ_OBJ_LIST *result)
     * }
     */
    public static MethodHandle proj_list_destroy$handle() {
        return proj_list_destroy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void proj_list_destroy(PJ_OBJ_LIST *result)
     * }
     */
    public static MemorySegment proj_list_destroy$address() {
        return proj_list_destroy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void proj_list_destroy(PJ_OBJ_LIST *result)
     * }
     */
    public static void proj_list_destroy(MemorySegment result) {
        var mh$ = proj_list_destroy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_list_destroy", result);
            }
            mh$.invokeExact(result);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_get_suggested_operation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_INT,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_INT,
            PJ_COORD.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_get_suggested_operation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int proj_get_suggested_operation(PJ_CONTEXT *ctx, PJ_OBJ_LIST *operations, PJ_DIRECTION direction, PJ_COORD coord)
     * }
     */
    public static FunctionDescriptor proj_get_suggested_operation$descriptor() {
        return proj_get_suggested_operation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int proj_get_suggested_operation(PJ_CONTEXT *ctx, PJ_OBJ_LIST *operations, PJ_DIRECTION direction, PJ_COORD coord)
     * }
     */
    public static MethodHandle proj_get_suggested_operation$handle() {
        return proj_get_suggested_operation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int proj_get_suggested_operation(PJ_CONTEXT *ctx, PJ_OBJ_LIST *operations, PJ_DIRECTION direction, PJ_COORD coord)
     * }
     */
    public static MemorySegment proj_get_suggested_operation$address() {
        return proj_get_suggested_operation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int proj_get_suggested_operation(PJ_CONTEXT *ctx, PJ_OBJ_LIST *operations, PJ_DIRECTION direction, PJ_COORD coord)
     * }
     */
    public static int proj_get_suggested_operation(MemorySegment ctx, MemorySegment operations, int direction, MemorySegment coord) {
        var mh$ = proj_get_suggested_operation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_get_suggested_operation", ctx, operations, direction, coord);
            }
            return (int)mh$.invokeExact(ctx, operations, direction, coord);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_crs_is_derived {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_INT,
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_crs_is_derived");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int proj_crs_is_derived(PJ_CONTEXT *ctx, const PJ *crs)
     * }
     */
    public static FunctionDescriptor proj_crs_is_derived$descriptor() {
        return proj_crs_is_derived.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int proj_crs_is_derived(PJ_CONTEXT *ctx, const PJ *crs)
     * }
     */
    public static MethodHandle proj_crs_is_derived$handle() {
        return proj_crs_is_derived.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int proj_crs_is_derived(PJ_CONTEXT *ctx, const PJ *crs)
     * }
     */
    public static MemorySegment proj_crs_is_derived$address() {
        return proj_crs_is_derived.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int proj_crs_is_derived(PJ_CONTEXT *ctx, const PJ *crs)
     * }
     */
    public static int proj_crs_is_derived(MemorySegment ctx, MemorySegment crs) {
        var mh$ = proj_crs_is_derived.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_crs_is_derived", ctx, crs);
            }
            return (int)mh$.invokeExact(ctx, crs);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_crs_get_geodetic_crs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_crs_get_geodetic_crs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ *proj_crs_get_geodetic_crs(PJ_CONTEXT *ctx, const PJ *crs)
     * }
     */
    public static FunctionDescriptor proj_crs_get_geodetic_crs$descriptor() {
        return proj_crs_get_geodetic_crs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ *proj_crs_get_geodetic_crs(PJ_CONTEXT *ctx, const PJ *crs)
     * }
     */
    public static MethodHandle proj_crs_get_geodetic_crs$handle() {
        return proj_crs_get_geodetic_crs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ *proj_crs_get_geodetic_crs(PJ_CONTEXT *ctx, const PJ *crs)
     * }
     */
    public static MemorySegment proj_crs_get_geodetic_crs$address() {
        return proj_crs_get_geodetic_crs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ *proj_crs_get_geodetic_crs(PJ_CONTEXT *ctx, const PJ *crs)
     * }
     */
    public static MemorySegment proj_crs_get_geodetic_crs(MemorySegment ctx, MemorySegment crs) {
        var mh$ = proj_crs_get_geodetic_crs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_crs_get_geodetic_crs", ctx, crs);
            }
            return (MemorySegment)mh$.invokeExact(ctx, crs);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_crs_get_horizontal_datum {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_crs_get_horizontal_datum");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ *proj_crs_get_horizontal_datum(PJ_CONTEXT *ctx, const PJ *crs)
     * }
     */
    public static FunctionDescriptor proj_crs_get_horizontal_datum$descriptor() {
        return proj_crs_get_horizontal_datum.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ *proj_crs_get_horizontal_datum(PJ_CONTEXT *ctx, const PJ *crs)
     * }
     */
    public static MethodHandle proj_crs_get_horizontal_datum$handle() {
        return proj_crs_get_horizontal_datum.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ *proj_crs_get_horizontal_datum(PJ_CONTEXT *ctx, const PJ *crs)
     * }
     */
    public static MemorySegment proj_crs_get_horizontal_datum$address() {
        return proj_crs_get_horizontal_datum.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ *proj_crs_get_horizontal_datum(PJ_CONTEXT *ctx, const PJ *crs)
     * }
     */
    public static MemorySegment proj_crs_get_horizontal_datum(MemorySegment ctx, MemorySegment crs) {
        var mh$ = proj_crs_get_horizontal_datum.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_crs_get_horizontal_datum", ctx, crs);
            }
            return (MemorySegment)mh$.invokeExact(ctx, crs);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_crs_get_sub_crs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_crs_get_sub_crs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ *proj_crs_get_sub_crs(PJ_CONTEXT *ctx, const PJ *crs, int index)
     * }
     */
    public static FunctionDescriptor proj_crs_get_sub_crs$descriptor() {
        return proj_crs_get_sub_crs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ *proj_crs_get_sub_crs(PJ_CONTEXT *ctx, const PJ *crs, int index)
     * }
     */
    public static MethodHandle proj_crs_get_sub_crs$handle() {
        return proj_crs_get_sub_crs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ *proj_crs_get_sub_crs(PJ_CONTEXT *ctx, const PJ *crs, int index)
     * }
     */
    public static MemorySegment proj_crs_get_sub_crs$address() {
        return proj_crs_get_sub_crs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ *proj_crs_get_sub_crs(PJ_CONTEXT *ctx, const PJ *crs, int index)
     * }
     */
    public static MemorySegment proj_crs_get_sub_crs(MemorySegment ctx, MemorySegment crs, int index) {
        var mh$ = proj_crs_get_sub_crs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_crs_get_sub_crs", ctx, crs, index);
            }
            return (MemorySegment)mh$.invokeExact(ctx, crs, index);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_crs_get_datum {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_crs_get_datum");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ *proj_crs_get_datum(PJ_CONTEXT *ctx, const PJ *crs)
     * }
     */
    public static FunctionDescriptor proj_crs_get_datum$descriptor() {
        return proj_crs_get_datum.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ *proj_crs_get_datum(PJ_CONTEXT *ctx, const PJ *crs)
     * }
     */
    public static MethodHandle proj_crs_get_datum$handle() {
        return proj_crs_get_datum.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ *proj_crs_get_datum(PJ_CONTEXT *ctx, const PJ *crs)
     * }
     */
    public static MemorySegment proj_crs_get_datum$address() {
        return proj_crs_get_datum.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ *proj_crs_get_datum(PJ_CONTEXT *ctx, const PJ *crs)
     * }
     */
    public static MemorySegment proj_crs_get_datum(MemorySegment ctx, MemorySegment crs) {
        var mh$ = proj_crs_get_datum.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_crs_get_datum", ctx, crs);
            }
            return (MemorySegment)mh$.invokeExact(ctx, crs);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_crs_get_datum_ensemble {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_crs_get_datum_ensemble");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ *proj_crs_get_datum_ensemble(PJ_CONTEXT *ctx, const PJ *crs)
     * }
     */
    public static FunctionDescriptor proj_crs_get_datum_ensemble$descriptor() {
        return proj_crs_get_datum_ensemble.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ *proj_crs_get_datum_ensemble(PJ_CONTEXT *ctx, const PJ *crs)
     * }
     */
    public static MethodHandle proj_crs_get_datum_ensemble$handle() {
        return proj_crs_get_datum_ensemble.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ *proj_crs_get_datum_ensemble(PJ_CONTEXT *ctx, const PJ *crs)
     * }
     */
    public static MemorySegment proj_crs_get_datum_ensemble$address() {
        return proj_crs_get_datum_ensemble.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ *proj_crs_get_datum_ensemble(PJ_CONTEXT *ctx, const PJ *crs)
     * }
     */
    public static MemorySegment proj_crs_get_datum_ensemble(MemorySegment ctx, MemorySegment crs) {
        var mh$ = proj_crs_get_datum_ensemble.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_crs_get_datum_ensemble", ctx, crs);
            }
            return (MemorySegment)mh$.invokeExact(ctx, crs);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_crs_get_datum_forced {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_crs_get_datum_forced");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ *proj_crs_get_datum_forced(PJ_CONTEXT *ctx, const PJ *crs)
     * }
     */
    public static FunctionDescriptor proj_crs_get_datum_forced$descriptor() {
        return proj_crs_get_datum_forced.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ *proj_crs_get_datum_forced(PJ_CONTEXT *ctx, const PJ *crs)
     * }
     */
    public static MethodHandle proj_crs_get_datum_forced$handle() {
        return proj_crs_get_datum_forced.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ *proj_crs_get_datum_forced(PJ_CONTEXT *ctx, const PJ *crs)
     * }
     */
    public static MemorySegment proj_crs_get_datum_forced$address() {
        return proj_crs_get_datum_forced.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ *proj_crs_get_datum_forced(PJ_CONTEXT *ctx, const PJ *crs)
     * }
     */
    public static MemorySegment proj_crs_get_datum_forced(MemorySegment ctx, MemorySegment crs) {
        var mh$ = proj_crs_get_datum_forced.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_crs_get_datum_forced", ctx, crs);
            }
            return (MemorySegment)mh$.invokeExact(ctx, crs);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_crs_has_point_motion_operation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_INT,
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_crs_has_point_motion_operation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int proj_crs_has_point_motion_operation(PJ_CONTEXT *ctx, const PJ *crs)
     * }
     */
    public static FunctionDescriptor proj_crs_has_point_motion_operation$descriptor() {
        return proj_crs_has_point_motion_operation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int proj_crs_has_point_motion_operation(PJ_CONTEXT *ctx, const PJ *crs)
     * }
     */
    public static MethodHandle proj_crs_has_point_motion_operation$handle() {
        return proj_crs_has_point_motion_operation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int proj_crs_has_point_motion_operation(PJ_CONTEXT *ctx, const PJ *crs)
     * }
     */
    public static MemorySegment proj_crs_has_point_motion_operation$address() {
        return proj_crs_has_point_motion_operation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int proj_crs_has_point_motion_operation(PJ_CONTEXT *ctx, const PJ *crs)
     * }
     */
    public static int proj_crs_has_point_motion_operation(MemorySegment ctx, MemorySegment crs) {
        var mh$ = proj_crs_has_point_motion_operation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_crs_has_point_motion_operation", ctx, crs);
            }
            return (int)mh$.invokeExact(ctx, crs);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_datum_ensemble_get_member_count {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_INT,
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_datum_ensemble_get_member_count");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int proj_datum_ensemble_get_member_count(PJ_CONTEXT *ctx, const PJ *datum_ensemble)
     * }
     */
    public static FunctionDescriptor proj_datum_ensemble_get_member_count$descriptor() {
        return proj_datum_ensemble_get_member_count.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int proj_datum_ensemble_get_member_count(PJ_CONTEXT *ctx, const PJ *datum_ensemble)
     * }
     */
    public static MethodHandle proj_datum_ensemble_get_member_count$handle() {
        return proj_datum_ensemble_get_member_count.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int proj_datum_ensemble_get_member_count(PJ_CONTEXT *ctx, const PJ *datum_ensemble)
     * }
     */
    public static MemorySegment proj_datum_ensemble_get_member_count$address() {
        return proj_datum_ensemble_get_member_count.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int proj_datum_ensemble_get_member_count(PJ_CONTEXT *ctx, const PJ *datum_ensemble)
     * }
     */
    public static int proj_datum_ensemble_get_member_count(MemorySegment ctx, MemorySegment datum_ensemble) {
        var mh$ = proj_datum_ensemble_get_member_count.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_datum_ensemble_get_member_count", ctx, datum_ensemble);
            }
            return (int)mh$.invokeExact(ctx, datum_ensemble);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_datum_ensemble_get_accuracy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_datum_ensemble_get_accuracy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double proj_datum_ensemble_get_accuracy(PJ_CONTEXT *ctx, const PJ *datum_ensemble)
     * }
     */
    public static FunctionDescriptor proj_datum_ensemble_get_accuracy$descriptor() {
        return proj_datum_ensemble_get_accuracy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double proj_datum_ensemble_get_accuracy(PJ_CONTEXT *ctx, const PJ *datum_ensemble)
     * }
     */
    public static MethodHandle proj_datum_ensemble_get_accuracy$handle() {
        return proj_datum_ensemble_get_accuracy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double proj_datum_ensemble_get_accuracy(PJ_CONTEXT *ctx, const PJ *datum_ensemble)
     * }
     */
    public static MemorySegment proj_datum_ensemble_get_accuracy$address() {
        return proj_datum_ensemble_get_accuracy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double proj_datum_ensemble_get_accuracy(PJ_CONTEXT *ctx, const PJ *datum_ensemble)
     * }
     */
    public static double proj_datum_ensemble_get_accuracy(MemorySegment ctx, MemorySegment datum_ensemble) {
        var mh$ = proj_datum_ensemble_get_accuracy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_datum_ensemble_get_accuracy", ctx, datum_ensemble);
            }
            return (double)mh$.invokeExact(ctx, datum_ensemble);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_datum_ensemble_get_member {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_datum_ensemble_get_member");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ *proj_datum_ensemble_get_member(PJ_CONTEXT *ctx, const PJ *datum_ensemble, int member_index)
     * }
     */
    public static FunctionDescriptor proj_datum_ensemble_get_member$descriptor() {
        return proj_datum_ensemble_get_member.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ *proj_datum_ensemble_get_member(PJ_CONTEXT *ctx, const PJ *datum_ensemble, int member_index)
     * }
     */
    public static MethodHandle proj_datum_ensemble_get_member$handle() {
        return proj_datum_ensemble_get_member.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ *proj_datum_ensemble_get_member(PJ_CONTEXT *ctx, const PJ *datum_ensemble, int member_index)
     * }
     */
    public static MemorySegment proj_datum_ensemble_get_member$address() {
        return proj_datum_ensemble_get_member.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ *proj_datum_ensemble_get_member(PJ_CONTEXT *ctx, const PJ *datum_ensemble, int member_index)
     * }
     */
    public static MemorySegment proj_datum_ensemble_get_member(MemorySegment ctx, MemorySegment datum_ensemble, int member_index) {
        var mh$ = proj_datum_ensemble_get_member.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_datum_ensemble_get_member", ctx, datum_ensemble, member_index);
            }
            return (MemorySegment)mh$.invokeExact(ctx, datum_ensemble, member_index);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_dynamic_datum_get_frame_reference_epoch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_dynamic_datum_get_frame_reference_epoch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double proj_dynamic_datum_get_frame_reference_epoch(PJ_CONTEXT *ctx, const PJ *datum)
     * }
     */
    public static FunctionDescriptor proj_dynamic_datum_get_frame_reference_epoch$descriptor() {
        return proj_dynamic_datum_get_frame_reference_epoch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double proj_dynamic_datum_get_frame_reference_epoch(PJ_CONTEXT *ctx, const PJ *datum)
     * }
     */
    public static MethodHandle proj_dynamic_datum_get_frame_reference_epoch$handle() {
        return proj_dynamic_datum_get_frame_reference_epoch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double proj_dynamic_datum_get_frame_reference_epoch(PJ_CONTEXT *ctx, const PJ *datum)
     * }
     */
    public static MemorySegment proj_dynamic_datum_get_frame_reference_epoch$address() {
        return proj_dynamic_datum_get_frame_reference_epoch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double proj_dynamic_datum_get_frame_reference_epoch(PJ_CONTEXT *ctx, const PJ *datum)
     * }
     */
    public static double proj_dynamic_datum_get_frame_reference_epoch(MemorySegment ctx, MemorySegment datum) {
        var mh$ = proj_dynamic_datum_get_frame_reference_epoch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_dynamic_datum_get_frame_reference_epoch", ctx, datum);
            }
            return (double)mh$.invokeExact(ctx, datum);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_crs_get_coordinate_system {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_crs_get_coordinate_system");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ *proj_crs_get_coordinate_system(PJ_CONTEXT *ctx, const PJ *crs)
     * }
     */
    public static FunctionDescriptor proj_crs_get_coordinate_system$descriptor() {
        return proj_crs_get_coordinate_system.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ *proj_crs_get_coordinate_system(PJ_CONTEXT *ctx, const PJ *crs)
     * }
     */
    public static MethodHandle proj_crs_get_coordinate_system$handle() {
        return proj_crs_get_coordinate_system.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ *proj_crs_get_coordinate_system(PJ_CONTEXT *ctx, const PJ *crs)
     * }
     */
    public static MemorySegment proj_crs_get_coordinate_system$address() {
        return proj_crs_get_coordinate_system.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ *proj_crs_get_coordinate_system(PJ_CONTEXT *ctx, const PJ *crs)
     * }
     */
    public static MemorySegment proj_crs_get_coordinate_system(MemorySegment ctx, MemorySegment crs) {
        var mh$ = proj_crs_get_coordinate_system.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_crs_get_coordinate_system", ctx, crs);
            }
            return (MemorySegment)mh$.invokeExact(ctx, crs);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_cs_get_type {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_INT,
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_cs_get_type");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ_COORDINATE_SYSTEM_TYPE proj_cs_get_type(PJ_CONTEXT *ctx, const PJ *cs)
     * }
     */
    public static FunctionDescriptor proj_cs_get_type$descriptor() {
        return proj_cs_get_type.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ_COORDINATE_SYSTEM_TYPE proj_cs_get_type(PJ_CONTEXT *ctx, const PJ *cs)
     * }
     */
    public static MethodHandle proj_cs_get_type$handle() {
        return proj_cs_get_type.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ_COORDINATE_SYSTEM_TYPE proj_cs_get_type(PJ_CONTEXT *ctx, const PJ *cs)
     * }
     */
    public static MemorySegment proj_cs_get_type$address() {
        return proj_cs_get_type.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ_COORDINATE_SYSTEM_TYPE proj_cs_get_type(PJ_CONTEXT *ctx, const PJ *cs)
     * }
     */
    public static int proj_cs_get_type(MemorySegment ctx, MemorySegment cs) {
        var mh$ = proj_cs_get_type.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_cs_get_type", ctx, cs);
            }
            return (int)mh$.invokeExact(ctx, cs);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_cs_get_axis_count {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_INT,
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_cs_get_axis_count");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int proj_cs_get_axis_count(PJ_CONTEXT *ctx, const PJ *cs)
     * }
     */
    public static FunctionDescriptor proj_cs_get_axis_count$descriptor() {
        return proj_cs_get_axis_count.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int proj_cs_get_axis_count(PJ_CONTEXT *ctx, const PJ *cs)
     * }
     */
    public static MethodHandle proj_cs_get_axis_count$handle() {
        return proj_cs_get_axis_count.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int proj_cs_get_axis_count(PJ_CONTEXT *ctx, const PJ *cs)
     * }
     */
    public static MemorySegment proj_cs_get_axis_count$address() {
        return proj_cs_get_axis_count.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int proj_cs_get_axis_count(PJ_CONTEXT *ctx, const PJ *cs)
     * }
     */
    public static int proj_cs_get_axis_count(MemorySegment ctx, MemorySegment cs) {
        var mh$ = proj_cs_get_axis_count.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_cs_get_axis_count", ctx, cs);
            }
            return (int)mh$.invokeExact(ctx, cs);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_cs_get_axis_info {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_INT,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_INT,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_cs_get_axis_info");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int proj_cs_get_axis_info(PJ_CONTEXT *ctx, const PJ *cs, int index, const char **out_name, const char **out_abbrev, const char **out_direction, double *out_unit_conv_factor, const char **out_unit_name, const char **out_unit_auth_name, const char **out_unit_code)
     * }
     */
    public static FunctionDescriptor proj_cs_get_axis_info$descriptor() {
        return proj_cs_get_axis_info.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int proj_cs_get_axis_info(PJ_CONTEXT *ctx, const PJ *cs, int index, const char **out_name, const char **out_abbrev, const char **out_direction, double *out_unit_conv_factor, const char **out_unit_name, const char **out_unit_auth_name, const char **out_unit_code)
     * }
     */
    public static MethodHandle proj_cs_get_axis_info$handle() {
        return proj_cs_get_axis_info.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int proj_cs_get_axis_info(PJ_CONTEXT *ctx, const PJ *cs, int index, const char **out_name, const char **out_abbrev, const char **out_direction, double *out_unit_conv_factor, const char **out_unit_name, const char **out_unit_auth_name, const char **out_unit_code)
     * }
     */
    public static MemorySegment proj_cs_get_axis_info$address() {
        return proj_cs_get_axis_info.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int proj_cs_get_axis_info(PJ_CONTEXT *ctx, const PJ *cs, int index, const char **out_name, const char **out_abbrev, const char **out_direction, double *out_unit_conv_factor, const char **out_unit_name, const char **out_unit_auth_name, const char **out_unit_code)
     * }
     */
    public static int proj_cs_get_axis_info(MemorySegment ctx, MemorySegment cs, int index, MemorySegment out_name, MemorySegment out_abbrev, MemorySegment out_direction, MemorySegment out_unit_conv_factor, MemorySegment out_unit_name, MemorySegment out_unit_auth_name, MemorySegment out_unit_code) {
        var mh$ = proj_cs_get_axis_info.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_cs_get_axis_info", ctx, cs, index, out_name, out_abbrev, out_direction, out_unit_conv_factor, out_unit_name, out_unit_auth_name, out_unit_code);
            }
            return (int)mh$.invokeExact(ctx, cs, index, out_name, out_abbrev, out_direction, out_unit_conv_factor, out_unit_name, out_unit_auth_name, out_unit_code);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_get_ellipsoid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_get_ellipsoid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ *proj_get_ellipsoid(PJ_CONTEXT *ctx, const PJ *obj)
     * }
     */
    public static FunctionDescriptor proj_get_ellipsoid$descriptor() {
        return proj_get_ellipsoid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ *proj_get_ellipsoid(PJ_CONTEXT *ctx, const PJ *obj)
     * }
     */
    public static MethodHandle proj_get_ellipsoid$handle() {
        return proj_get_ellipsoid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ *proj_get_ellipsoid(PJ_CONTEXT *ctx, const PJ *obj)
     * }
     */
    public static MemorySegment proj_get_ellipsoid$address() {
        return proj_get_ellipsoid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ *proj_get_ellipsoid(PJ_CONTEXT *ctx, const PJ *obj)
     * }
     */
    public static MemorySegment proj_get_ellipsoid(MemorySegment ctx, MemorySegment obj) {
        var mh$ = proj_get_ellipsoid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_get_ellipsoid", ctx, obj);
            }
            return (MemorySegment)mh$.invokeExact(ctx, obj);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_ellipsoid_get_parameters {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_INT,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_ellipsoid_get_parameters");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int proj_ellipsoid_get_parameters(PJ_CONTEXT *ctx, const PJ *ellipsoid, double *out_semi_major_metre, double *out_semi_minor_metre, int *out_is_semi_minor_computed, double *out_inv_flattening)
     * }
     */
    public static FunctionDescriptor proj_ellipsoid_get_parameters$descriptor() {
        return proj_ellipsoid_get_parameters.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int proj_ellipsoid_get_parameters(PJ_CONTEXT *ctx, const PJ *ellipsoid, double *out_semi_major_metre, double *out_semi_minor_metre, int *out_is_semi_minor_computed, double *out_inv_flattening)
     * }
     */
    public static MethodHandle proj_ellipsoid_get_parameters$handle() {
        return proj_ellipsoid_get_parameters.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int proj_ellipsoid_get_parameters(PJ_CONTEXT *ctx, const PJ *ellipsoid, double *out_semi_major_metre, double *out_semi_minor_metre, int *out_is_semi_minor_computed, double *out_inv_flattening)
     * }
     */
    public static MemorySegment proj_ellipsoid_get_parameters$address() {
        return proj_ellipsoid_get_parameters.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int proj_ellipsoid_get_parameters(PJ_CONTEXT *ctx, const PJ *ellipsoid, double *out_semi_major_metre, double *out_semi_minor_metre, int *out_is_semi_minor_computed, double *out_inv_flattening)
     * }
     */
    public static int proj_ellipsoid_get_parameters(MemorySegment ctx, MemorySegment ellipsoid, MemorySegment out_semi_major_metre, MemorySegment out_semi_minor_metre, MemorySegment out_is_semi_minor_computed, MemorySegment out_inv_flattening) {
        var mh$ = proj_ellipsoid_get_parameters.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_ellipsoid_get_parameters", ctx, ellipsoid, out_semi_major_metre, out_semi_minor_metre, out_is_semi_minor_computed, out_inv_flattening);
            }
            return (int)mh$.invokeExact(ctx, ellipsoid, out_semi_major_metre, out_semi_minor_metre, out_is_semi_minor_computed, out_inv_flattening);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_get_celestial_body_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_get_celestial_body_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *proj_get_celestial_body_name(PJ_CONTEXT *ctx, const PJ *obj)
     * }
     */
    public static FunctionDescriptor proj_get_celestial_body_name$descriptor() {
        return proj_get_celestial_body_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *proj_get_celestial_body_name(PJ_CONTEXT *ctx, const PJ *obj)
     * }
     */
    public static MethodHandle proj_get_celestial_body_name$handle() {
        return proj_get_celestial_body_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *proj_get_celestial_body_name(PJ_CONTEXT *ctx, const PJ *obj)
     * }
     */
    public static MemorySegment proj_get_celestial_body_name$address() {
        return proj_get_celestial_body_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *proj_get_celestial_body_name(PJ_CONTEXT *ctx, const PJ *obj)
     * }
     */
    public static MemorySegment proj_get_celestial_body_name(MemorySegment ctx, MemorySegment obj) {
        var mh$ = proj_get_celestial_body_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_get_celestial_body_name", ctx, obj);
            }
            return (MemorySegment)mh$.invokeExact(ctx, obj);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_get_prime_meridian {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_get_prime_meridian");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ *proj_get_prime_meridian(PJ_CONTEXT *ctx, const PJ *obj)
     * }
     */
    public static FunctionDescriptor proj_get_prime_meridian$descriptor() {
        return proj_get_prime_meridian.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ *proj_get_prime_meridian(PJ_CONTEXT *ctx, const PJ *obj)
     * }
     */
    public static MethodHandle proj_get_prime_meridian$handle() {
        return proj_get_prime_meridian.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ *proj_get_prime_meridian(PJ_CONTEXT *ctx, const PJ *obj)
     * }
     */
    public static MemorySegment proj_get_prime_meridian$address() {
        return proj_get_prime_meridian.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ *proj_get_prime_meridian(PJ_CONTEXT *ctx, const PJ *obj)
     * }
     */
    public static MemorySegment proj_get_prime_meridian(MemorySegment ctx, MemorySegment obj) {
        var mh$ = proj_get_prime_meridian.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_get_prime_meridian", ctx, obj);
            }
            return (MemorySegment)mh$.invokeExact(ctx, obj);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_prime_meridian_get_parameters {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_INT,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_prime_meridian_get_parameters");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int proj_prime_meridian_get_parameters(PJ_CONTEXT *ctx, const PJ *prime_meridian, double *out_longitude, double *out_unit_conv_factor, const char **out_unit_name)
     * }
     */
    public static FunctionDescriptor proj_prime_meridian_get_parameters$descriptor() {
        return proj_prime_meridian_get_parameters.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int proj_prime_meridian_get_parameters(PJ_CONTEXT *ctx, const PJ *prime_meridian, double *out_longitude, double *out_unit_conv_factor, const char **out_unit_name)
     * }
     */
    public static MethodHandle proj_prime_meridian_get_parameters$handle() {
        return proj_prime_meridian_get_parameters.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int proj_prime_meridian_get_parameters(PJ_CONTEXT *ctx, const PJ *prime_meridian, double *out_longitude, double *out_unit_conv_factor, const char **out_unit_name)
     * }
     */
    public static MemorySegment proj_prime_meridian_get_parameters$address() {
        return proj_prime_meridian_get_parameters.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int proj_prime_meridian_get_parameters(PJ_CONTEXT *ctx, const PJ *prime_meridian, double *out_longitude, double *out_unit_conv_factor, const char **out_unit_name)
     * }
     */
    public static int proj_prime_meridian_get_parameters(MemorySegment ctx, MemorySegment prime_meridian, MemorySegment out_longitude, MemorySegment out_unit_conv_factor, MemorySegment out_unit_name) {
        var mh$ = proj_prime_meridian_get_parameters.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_prime_meridian_get_parameters", ctx, prime_meridian, out_longitude, out_unit_conv_factor, out_unit_name);
            }
            return (int)mh$.invokeExact(ctx, prime_meridian, out_longitude, out_unit_conv_factor, out_unit_name);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_crs_get_coordoperation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_crs_get_coordoperation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ *proj_crs_get_coordoperation(PJ_CONTEXT *ctx, const PJ *crs)
     * }
     */
    public static FunctionDescriptor proj_crs_get_coordoperation$descriptor() {
        return proj_crs_get_coordoperation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ *proj_crs_get_coordoperation(PJ_CONTEXT *ctx, const PJ *crs)
     * }
     */
    public static MethodHandle proj_crs_get_coordoperation$handle() {
        return proj_crs_get_coordoperation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ *proj_crs_get_coordoperation(PJ_CONTEXT *ctx, const PJ *crs)
     * }
     */
    public static MemorySegment proj_crs_get_coordoperation$address() {
        return proj_crs_get_coordoperation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ *proj_crs_get_coordoperation(PJ_CONTEXT *ctx, const PJ *crs)
     * }
     */
    public static MemorySegment proj_crs_get_coordoperation(MemorySegment ctx, MemorySegment crs) {
        var mh$ = proj_crs_get_coordoperation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_crs_get_coordoperation", ctx, crs);
            }
            return (MemorySegment)mh$.invokeExact(ctx, crs);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_coordoperation_get_method_info {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_INT,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_coordoperation_get_method_info");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int proj_coordoperation_get_method_info(PJ_CONTEXT *ctx, const PJ *coordoperation, const char **out_method_name, const char **out_method_auth_name, const char **out_method_code)
     * }
     */
    public static FunctionDescriptor proj_coordoperation_get_method_info$descriptor() {
        return proj_coordoperation_get_method_info.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int proj_coordoperation_get_method_info(PJ_CONTEXT *ctx, const PJ *coordoperation, const char **out_method_name, const char **out_method_auth_name, const char **out_method_code)
     * }
     */
    public static MethodHandle proj_coordoperation_get_method_info$handle() {
        return proj_coordoperation_get_method_info.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int proj_coordoperation_get_method_info(PJ_CONTEXT *ctx, const PJ *coordoperation, const char **out_method_name, const char **out_method_auth_name, const char **out_method_code)
     * }
     */
    public static MemorySegment proj_coordoperation_get_method_info$address() {
        return proj_coordoperation_get_method_info.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int proj_coordoperation_get_method_info(PJ_CONTEXT *ctx, const PJ *coordoperation, const char **out_method_name, const char **out_method_auth_name, const char **out_method_code)
     * }
     */
    public static int proj_coordoperation_get_method_info(MemorySegment ctx, MemorySegment coordoperation, MemorySegment out_method_name, MemorySegment out_method_auth_name, MemorySegment out_method_code) {
        var mh$ = proj_coordoperation_get_method_info.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_coordoperation_get_method_info", ctx, coordoperation, out_method_name, out_method_auth_name, out_method_code);
            }
            return (int)mh$.invokeExact(ctx, coordoperation, out_method_name, out_method_auth_name, out_method_code);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_coordoperation_is_instantiable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_INT,
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_coordoperation_is_instantiable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int proj_coordoperation_is_instantiable(PJ_CONTEXT *ctx, const PJ *coordoperation)
     * }
     */
    public static FunctionDescriptor proj_coordoperation_is_instantiable$descriptor() {
        return proj_coordoperation_is_instantiable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int proj_coordoperation_is_instantiable(PJ_CONTEXT *ctx, const PJ *coordoperation)
     * }
     */
    public static MethodHandle proj_coordoperation_is_instantiable$handle() {
        return proj_coordoperation_is_instantiable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int proj_coordoperation_is_instantiable(PJ_CONTEXT *ctx, const PJ *coordoperation)
     * }
     */
    public static MemorySegment proj_coordoperation_is_instantiable$address() {
        return proj_coordoperation_is_instantiable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int proj_coordoperation_is_instantiable(PJ_CONTEXT *ctx, const PJ *coordoperation)
     * }
     */
    public static int proj_coordoperation_is_instantiable(MemorySegment ctx, MemorySegment coordoperation) {
        var mh$ = proj_coordoperation_is_instantiable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_coordoperation_is_instantiable", ctx, coordoperation);
            }
            return (int)mh$.invokeExact(ctx, coordoperation);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_coordoperation_has_ballpark_transformation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_INT,
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_coordoperation_has_ballpark_transformation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int proj_coordoperation_has_ballpark_transformation(PJ_CONTEXT *ctx, const PJ *coordoperation)
     * }
     */
    public static FunctionDescriptor proj_coordoperation_has_ballpark_transformation$descriptor() {
        return proj_coordoperation_has_ballpark_transformation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int proj_coordoperation_has_ballpark_transformation(PJ_CONTEXT *ctx, const PJ *coordoperation)
     * }
     */
    public static MethodHandle proj_coordoperation_has_ballpark_transformation$handle() {
        return proj_coordoperation_has_ballpark_transformation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int proj_coordoperation_has_ballpark_transformation(PJ_CONTEXT *ctx, const PJ *coordoperation)
     * }
     */
    public static MemorySegment proj_coordoperation_has_ballpark_transformation$address() {
        return proj_coordoperation_has_ballpark_transformation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int proj_coordoperation_has_ballpark_transformation(PJ_CONTEXT *ctx, const PJ *coordoperation)
     * }
     */
    public static int proj_coordoperation_has_ballpark_transformation(MemorySegment ctx, MemorySegment coordoperation) {
        var mh$ = proj_coordoperation_has_ballpark_transformation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_coordoperation_has_ballpark_transformation", ctx, coordoperation);
            }
            return (int)mh$.invokeExact(ctx, coordoperation);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_coordoperation_requires_per_coordinate_input_time {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_INT,
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_coordoperation_requires_per_coordinate_input_time");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int proj_coordoperation_requires_per_coordinate_input_time(PJ_CONTEXT *ctx, const PJ *coordoperation)
     * }
     */
    public static FunctionDescriptor proj_coordoperation_requires_per_coordinate_input_time$descriptor() {
        return proj_coordoperation_requires_per_coordinate_input_time.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int proj_coordoperation_requires_per_coordinate_input_time(PJ_CONTEXT *ctx, const PJ *coordoperation)
     * }
     */
    public static MethodHandle proj_coordoperation_requires_per_coordinate_input_time$handle() {
        return proj_coordoperation_requires_per_coordinate_input_time.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int proj_coordoperation_requires_per_coordinate_input_time(PJ_CONTEXT *ctx, const PJ *coordoperation)
     * }
     */
    public static MemorySegment proj_coordoperation_requires_per_coordinate_input_time$address() {
        return proj_coordoperation_requires_per_coordinate_input_time.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int proj_coordoperation_requires_per_coordinate_input_time(PJ_CONTEXT *ctx, const PJ *coordoperation)
     * }
     */
    public static int proj_coordoperation_requires_per_coordinate_input_time(MemorySegment ctx, MemorySegment coordoperation) {
        var mh$ = proj_coordoperation_requires_per_coordinate_input_time.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_coordoperation_requires_per_coordinate_input_time", ctx, coordoperation);
            }
            return (int)mh$.invokeExact(ctx, coordoperation);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_coordoperation_get_param_count {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_INT,
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_coordoperation_get_param_count");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int proj_coordoperation_get_param_count(PJ_CONTEXT *ctx, const PJ *coordoperation)
     * }
     */
    public static FunctionDescriptor proj_coordoperation_get_param_count$descriptor() {
        return proj_coordoperation_get_param_count.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int proj_coordoperation_get_param_count(PJ_CONTEXT *ctx, const PJ *coordoperation)
     * }
     */
    public static MethodHandle proj_coordoperation_get_param_count$handle() {
        return proj_coordoperation_get_param_count.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int proj_coordoperation_get_param_count(PJ_CONTEXT *ctx, const PJ *coordoperation)
     * }
     */
    public static MemorySegment proj_coordoperation_get_param_count$address() {
        return proj_coordoperation_get_param_count.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int proj_coordoperation_get_param_count(PJ_CONTEXT *ctx, const PJ *coordoperation)
     * }
     */
    public static int proj_coordoperation_get_param_count(MemorySegment ctx, MemorySegment coordoperation) {
        var mh$ = proj_coordoperation_get_param_count.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_coordoperation_get_param_count", ctx, coordoperation);
            }
            return (int)mh$.invokeExact(ctx, coordoperation);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_coordoperation_get_param_index {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_INT,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_coordoperation_get_param_index");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int proj_coordoperation_get_param_index(PJ_CONTEXT *ctx, const PJ *coordoperation, const char *name)
     * }
     */
    public static FunctionDescriptor proj_coordoperation_get_param_index$descriptor() {
        return proj_coordoperation_get_param_index.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int proj_coordoperation_get_param_index(PJ_CONTEXT *ctx, const PJ *coordoperation, const char *name)
     * }
     */
    public static MethodHandle proj_coordoperation_get_param_index$handle() {
        return proj_coordoperation_get_param_index.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int proj_coordoperation_get_param_index(PJ_CONTEXT *ctx, const PJ *coordoperation, const char *name)
     * }
     */
    public static MemorySegment proj_coordoperation_get_param_index$address() {
        return proj_coordoperation_get_param_index.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int proj_coordoperation_get_param_index(PJ_CONTEXT *ctx, const PJ *coordoperation, const char *name)
     * }
     */
    public static int proj_coordoperation_get_param_index(MemorySegment ctx, MemorySegment coordoperation, MemorySegment name) {
        var mh$ = proj_coordoperation_get_param_index.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_coordoperation_get_param_index", ctx, coordoperation, name);
            }
            return (int)mh$.invokeExact(ctx, coordoperation, name);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_coordoperation_get_param {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_INT,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_INT,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_coordoperation_get_param");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int proj_coordoperation_get_param(PJ_CONTEXT *ctx, const PJ *coordoperation, int index, const char **out_name, const char **out_auth_name, const char **out_code, double *out_value, const char **out_value_string, double *out_unit_conv_factor, const char **out_unit_name, const char **out_unit_auth_name, const char **out_unit_code, const char **out_unit_category)
     * }
     */
    public static FunctionDescriptor proj_coordoperation_get_param$descriptor() {
        return proj_coordoperation_get_param.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int proj_coordoperation_get_param(PJ_CONTEXT *ctx, const PJ *coordoperation, int index, const char **out_name, const char **out_auth_name, const char **out_code, double *out_value, const char **out_value_string, double *out_unit_conv_factor, const char **out_unit_name, const char **out_unit_auth_name, const char **out_unit_code, const char **out_unit_category)
     * }
     */
    public static MethodHandle proj_coordoperation_get_param$handle() {
        return proj_coordoperation_get_param.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int proj_coordoperation_get_param(PJ_CONTEXT *ctx, const PJ *coordoperation, int index, const char **out_name, const char **out_auth_name, const char **out_code, double *out_value, const char **out_value_string, double *out_unit_conv_factor, const char **out_unit_name, const char **out_unit_auth_name, const char **out_unit_code, const char **out_unit_category)
     * }
     */
    public static MemorySegment proj_coordoperation_get_param$address() {
        return proj_coordoperation_get_param.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int proj_coordoperation_get_param(PJ_CONTEXT *ctx, const PJ *coordoperation, int index, const char **out_name, const char **out_auth_name, const char **out_code, double *out_value, const char **out_value_string, double *out_unit_conv_factor, const char **out_unit_name, const char **out_unit_auth_name, const char **out_unit_code, const char **out_unit_category)
     * }
     */
    public static int proj_coordoperation_get_param(MemorySegment ctx, MemorySegment coordoperation, int index, MemorySegment out_name, MemorySegment out_auth_name, MemorySegment out_code, MemorySegment out_value, MemorySegment out_value_string, MemorySegment out_unit_conv_factor, MemorySegment out_unit_name, MemorySegment out_unit_auth_name, MemorySegment out_unit_code, MemorySegment out_unit_category) {
        var mh$ = proj_coordoperation_get_param.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_coordoperation_get_param", ctx, coordoperation, index, out_name, out_auth_name, out_code, out_value, out_value_string, out_unit_conv_factor, out_unit_name, out_unit_auth_name, out_unit_code, out_unit_category);
            }
            return (int)mh$.invokeExact(ctx, coordoperation, index, out_name, out_auth_name, out_code, out_value, out_value_string, out_unit_conv_factor, out_unit_name, out_unit_auth_name, out_unit_code, out_unit_category);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_coordoperation_get_grid_used_count {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_INT,
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_coordoperation_get_grid_used_count");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int proj_coordoperation_get_grid_used_count(PJ_CONTEXT *ctx, const PJ *coordoperation)
     * }
     */
    public static FunctionDescriptor proj_coordoperation_get_grid_used_count$descriptor() {
        return proj_coordoperation_get_grid_used_count.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int proj_coordoperation_get_grid_used_count(PJ_CONTEXT *ctx, const PJ *coordoperation)
     * }
     */
    public static MethodHandle proj_coordoperation_get_grid_used_count$handle() {
        return proj_coordoperation_get_grid_used_count.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int proj_coordoperation_get_grid_used_count(PJ_CONTEXT *ctx, const PJ *coordoperation)
     * }
     */
    public static MemorySegment proj_coordoperation_get_grid_used_count$address() {
        return proj_coordoperation_get_grid_used_count.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int proj_coordoperation_get_grid_used_count(PJ_CONTEXT *ctx, const PJ *coordoperation)
     * }
     */
    public static int proj_coordoperation_get_grid_used_count(MemorySegment ctx, MemorySegment coordoperation) {
        var mh$ = proj_coordoperation_get_grid_used_count.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_coordoperation_get_grid_used_count", ctx, coordoperation);
            }
            return (int)mh$.invokeExact(ctx, coordoperation);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_coordoperation_get_grid_used {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_INT,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_INT,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_coordoperation_get_grid_used");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int proj_coordoperation_get_grid_used(PJ_CONTEXT *ctx, const PJ *coordoperation, int index, const char **out_short_name, const char **out_full_name, const char **out_package_name, const char **out_url, int *out_direct_download, int *out_open_license, int *out_available)
     * }
     */
    public static FunctionDescriptor proj_coordoperation_get_grid_used$descriptor() {
        return proj_coordoperation_get_grid_used.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int proj_coordoperation_get_grid_used(PJ_CONTEXT *ctx, const PJ *coordoperation, int index, const char **out_short_name, const char **out_full_name, const char **out_package_name, const char **out_url, int *out_direct_download, int *out_open_license, int *out_available)
     * }
     */
    public static MethodHandle proj_coordoperation_get_grid_used$handle() {
        return proj_coordoperation_get_grid_used.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int proj_coordoperation_get_grid_used(PJ_CONTEXT *ctx, const PJ *coordoperation, int index, const char **out_short_name, const char **out_full_name, const char **out_package_name, const char **out_url, int *out_direct_download, int *out_open_license, int *out_available)
     * }
     */
    public static MemorySegment proj_coordoperation_get_grid_used$address() {
        return proj_coordoperation_get_grid_used.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int proj_coordoperation_get_grid_used(PJ_CONTEXT *ctx, const PJ *coordoperation, int index, const char **out_short_name, const char **out_full_name, const char **out_package_name, const char **out_url, int *out_direct_download, int *out_open_license, int *out_available)
     * }
     */
    public static int proj_coordoperation_get_grid_used(MemorySegment ctx, MemorySegment coordoperation, int index, MemorySegment out_short_name, MemorySegment out_full_name, MemorySegment out_package_name, MemorySegment out_url, MemorySegment out_direct_download, MemorySegment out_open_license, MemorySegment out_available) {
        var mh$ = proj_coordoperation_get_grid_used.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_coordoperation_get_grid_used", ctx, coordoperation, index, out_short_name, out_full_name, out_package_name, out_url, out_direct_download, out_open_license, out_available);
            }
            return (int)mh$.invokeExact(ctx, coordoperation, index, out_short_name, out_full_name, out_package_name, out_url, out_direct_download, out_open_license, out_available);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_coordoperation_get_accuracy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_coordoperation_get_accuracy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double proj_coordoperation_get_accuracy(PJ_CONTEXT *ctx, const PJ *obj)
     * }
     */
    public static FunctionDescriptor proj_coordoperation_get_accuracy$descriptor() {
        return proj_coordoperation_get_accuracy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double proj_coordoperation_get_accuracy(PJ_CONTEXT *ctx, const PJ *obj)
     * }
     */
    public static MethodHandle proj_coordoperation_get_accuracy$handle() {
        return proj_coordoperation_get_accuracy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double proj_coordoperation_get_accuracy(PJ_CONTEXT *ctx, const PJ *obj)
     * }
     */
    public static MemorySegment proj_coordoperation_get_accuracy$address() {
        return proj_coordoperation_get_accuracy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double proj_coordoperation_get_accuracy(PJ_CONTEXT *ctx, const PJ *obj)
     * }
     */
    public static double proj_coordoperation_get_accuracy(MemorySegment ctx, MemorySegment obj) {
        var mh$ = proj_coordoperation_get_accuracy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_coordoperation_get_accuracy", ctx, obj);
            }
            return (double)mh$.invokeExact(ctx, obj);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_coordoperation_get_towgs84_values {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_INT,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_INT,
            proj_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_coordoperation_get_towgs84_values");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int proj_coordoperation_get_towgs84_values(PJ_CONTEXT *ctx, const PJ *coordoperation, double *out_values, int value_count, int emit_error_if_incompatible)
     * }
     */
    public static FunctionDescriptor proj_coordoperation_get_towgs84_values$descriptor() {
        return proj_coordoperation_get_towgs84_values.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int proj_coordoperation_get_towgs84_values(PJ_CONTEXT *ctx, const PJ *coordoperation, double *out_values, int value_count, int emit_error_if_incompatible)
     * }
     */
    public static MethodHandle proj_coordoperation_get_towgs84_values$handle() {
        return proj_coordoperation_get_towgs84_values.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int proj_coordoperation_get_towgs84_values(PJ_CONTEXT *ctx, const PJ *coordoperation, double *out_values, int value_count, int emit_error_if_incompatible)
     * }
     */
    public static MemorySegment proj_coordoperation_get_towgs84_values$address() {
        return proj_coordoperation_get_towgs84_values.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int proj_coordoperation_get_towgs84_values(PJ_CONTEXT *ctx, const PJ *coordoperation, double *out_values, int value_count, int emit_error_if_incompatible)
     * }
     */
    public static int proj_coordoperation_get_towgs84_values(MemorySegment ctx, MemorySegment coordoperation, MemorySegment out_values, int value_count, int emit_error_if_incompatible) {
        var mh$ = proj_coordoperation_get_towgs84_values.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_coordoperation_get_towgs84_values", ctx, coordoperation, out_values, value_count, emit_error_if_incompatible);
            }
            return (int)mh$.invokeExact(ctx, coordoperation, out_values, value_count, emit_error_if_incompatible);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_coordoperation_create_inverse {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_coordoperation_create_inverse");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ *proj_coordoperation_create_inverse(PJ_CONTEXT *ctx, const PJ *obj)
     * }
     */
    public static FunctionDescriptor proj_coordoperation_create_inverse$descriptor() {
        return proj_coordoperation_create_inverse.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ *proj_coordoperation_create_inverse(PJ_CONTEXT *ctx, const PJ *obj)
     * }
     */
    public static MethodHandle proj_coordoperation_create_inverse$handle() {
        return proj_coordoperation_create_inverse.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ *proj_coordoperation_create_inverse(PJ_CONTEXT *ctx, const PJ *obj)
     * }
     */
    public static MemorySegment proj_coordoperation_create_inverse$address() {
        return proj_coordoperation_create_inverse.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ *proj_coordoperation_create_inverse(PJ_CONTEXT *ctx, const PJ *obj)
     * }
     */
    public static MemorySegment proj_coordoperation_create_inverse(MemorySegment ctx, MemorySegment obj) {
        var mh$ = proj_coordoperation_create_inverse.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_coordoperation_create_inverse", ctx, obj);
            }
            return (MemorySegment)mh$.invokeExact(ctx, obj);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_concatoperation_get_step_count {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_INT,
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_concatoperation_get_step_count");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int proj_concatoperation_get_step_count(PJ_CONTEXT *ctx, const PJ *concatoperation)
     * }
     */
    public static FunctionDescriptor proj_concatoperation_get_step_count$descriptor() {
        return proj_concatoperation_get_step_count.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int proj_concatoperation_get_step_count(PJ_CONTEXT *ctx, const PJ *concatoperation)
     * }
     */
    public static MethodHandle proj_concatoperation_get_step_count$handle() {
        return proj_concatoperation_get_step_count.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int proj_concatoperation_get_step_count(PJ_CONTEXT *ctx, const PJ *concatoperation)
     * }
     */
    public static MemorySegment proj_concatoperation_get_step_count$address() {
        return proj_concatoperation_get_step_count.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int proj_concatoperation_get_step_count(PJ_CONTEXT *ctx, const PJ *concatoperation)
     * }
     */
    public static int proj_concatoperation_get_step_count(MemorySegment ctx, MemorySegment concatoperation) {
        var mh$ = proj_concatoperation_get_step_count.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_concatoperation_get_step_count", ctx, concatoperation);
            }
            return (int)mh$.invokeExact(ctx, concatoperation);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_concatoperation_get_step {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_concatoperation_get_step");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ *proj_concatoperation_get_step(PJ_CONTEXT *ctx, const PJ *concatoperation, int i_step)
     * }
     */
    public static FunctionDescriptor proj_concatoperation_get_step$descriptor() {
        return proj_concatoperation_get_step.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ *proj_concatoperation_get_step(PJ_CONTEXT *ctx, const PJ *concatoperation, int i_step)
     * }
     */
    public static MethodHandle proj_concatoperation_get_step$handle() {
        return proj_concatoperation_get_step.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ *proj_concatoperation_get_step(PJ_CONTEXT *ctx, const PJ *concatoperation, int i_step)
     * }
     */
    public static MemorySegment proj_concatoperation_get_step$address() {
        return proj_concatoperation_get_step.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ *proj_concatoperation_get_step(PJ_CONTEXT *ctx, const PJ *concatoperation, int i_step)
     * }
     */
    public static MemorySegment proj_concatoperation_get_step(MemorySegment ctx, MemorySegment concatoperation, int i_step) {
        var mh$ = proj_concatoperation_get_step.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_concatoperation_get_step", ctx, concatoperation, i_step);
            }
            return (MemorySegment)mh$.invokeExact(ctx, concatoperation, i_step);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_coordinate_metadata_create {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_coordinate_metadata_create");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ *proj_coordinate_metadata_create(PJ_CONTEXT *ctx, const PJ *crs, double epoch)
     * }
     */
    public static FunctionDescriptor proj_coordinate_metadata_create$descriptor() {
        return proj_coordinate_metadata_create.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ *proj_coordinate_metadata_create(PJ_CONTEXT *ctx, const PJ *crs, double epoch)
     * }
     */
    public static MethodHandle proj_coordinate_metadata_create$handle() {
        return proj_coordinate_metadata_create.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ *proj_coordinate_metadata_create(PJ_CONTEXT *ctx, const PJ *crs, double epoch)
     * }
     */
    public static MemorySegment proj_coordinate_metadata_create$address() {
        return proj_coordinate_metadata_create.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ *proj_coordinate_metadata_create(PJ_CONTEXT *ctx, const PJ *crs, double epoch)
     * }
     */
    public static MemorySegment proj_coordinate_metadata_create(MemorySegment ctx, MemorySegment crs, double epoch) {
        var mh$ = proj_coordinate_metadata_create.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_coordinate_metadata_create", ctx, crs, epoch);
            }
            return (MemorySegment)mh$.invokeExact(ctx, crs, epoch);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_coordinate_metadata_get_epoch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_coordinate_metadata_get_epoch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double proj_coordinate_metadata_get_epoch(PJ_CONTEXT *ctx, const PJ *obj)
     * }
     */
    public static FunctionDescriptor proj_coordinate_metadata_get_epoch$descriptor() {
        return proj_coordinate_metadata_get_epoch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double proj_coordinate_metadata_get_epoch(PJ_CONTEXT *ctx, const PJ *obj)
     * }
     */
    public static MethodHandle proj_coordinate_metadata_get_epoch$handle() {
        return proj_coordinate_metadata_get_epoch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double proj_coordinate_metadata_get_epoch(PJ_CONTEXT *ctx, const PJ *obj)
     * }
     */
    public static MemorySegment proj_coordinate_metadata_get_epoch$address() {
        return proj_coordinate_metadata_get_epoch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double proj_coordinate_metadata_get_epoch(PJ_CONTEXT *ctx, const PJ *obj)
     * }
     */
    public static double proj_coordinate_metadata_get_epoch(MemorySegment ctx, MemorySegment obj) {
        var mh$ = proj_coordinate_metadata_get_epoch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_coordinate_metadata_get_epoch", ctx, obj);
            }
            return (double)mh$.invokeExact(ctx, obj);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int PJ_UT_ANGULAR = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PJ_UT_ANGULAR = 0
     * }
     */
    public static int PJ_UT_ANGULAR() {
        return PJ_UT_ANGULAR;
    }
    private static final int PJ_UT_LINEAR = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PJ_UT_LINEAR = 1
     * }
     */
    public static int PJ_UT_LINEAR() {
        return PJ_UT_LINEAR;
    }
    private static final int PJ_UT_SCALE = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PJ_UT_SCALE = 2
     * }
     */
    public static int PJ_UT_SCALE() {
        return PJ_UT_SCALE;
    }
    private static final int PJ_UT_TIME = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PJ_UT_TIME = 3
     * }
     */
    public static int PJ_UT_TIME() {
        return PJ_UT_TIME;
    }
    private static final int PJ_UT_PARAMETRIC = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PJ_UT_PARAMETRIC = 4
     * }
     */
    public static int PJ_UT_PARAMETRIC() {
        return PJ_UT_PARAMETRIC;
    }
    private static final int PJ_CART2D_EASTING_NORTHING = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PJ_CART2D_EASTING_NORTHING = 0
     * }
     */
    public static int PJ_CART2D_EASTING_NORTHING() {
        return PJ_CART2D_EASTING_NORTHING;
    }
    private static final int PJ_CART2D_NORTHING_EASTING = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PJ_CART2D_NORTHING_EASTING = 1
     * }
     */
    public static int PJ_CART2D_NORTHING_EASTING() {
        return PJ_CART2D_NORTHING_EASTING;
    }
    private static final int PJ_CART2D_NORTH_POLE_EASTING_SOUTH_NORTHING_SOUTH = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PJ_CART2D_NORTH_POLE_EASTING_SOUTH_NORTHING_SOUTH = 2
     * }
     */
    public static int PJ_CART2D_NORTH_POLE_EASTING_SOUTH_NORTHING_SOUTH() {
        return PJ_CART2D_NORTH_POLE_EASTING_SOUTH_NORTHING_SOUTH;
    }
    private static final int PJ_CART2D_SOUTH_POLE_EASTING_NORTH_NORTHING_NORTH = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PJ_CART2D_SOUTH_POLE_EASTING_NORTH_NORTHING_NORTH = 3
     * }
     */
    public static int PJ_CART2D_SOUTH_POLE_EASTING_NORTH_NORTHING_NORTH() {
        return PJ_CART2D_SOUTH_POLE_EASTING_NORTH_NORTHING_NORTH;
    }
    private static final int PJ_CART2D_WESTING_SOUTHING = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PJ_CART2D_WESTING_SOUTHING = 4
     * }
     */
    public static int PJ_CART2D_WESTING_SOUTHING() {
        return PJ_CART2D_WESTING_SOUTHING;
    }
    private static final int PJ_ELLPS2D_LONGITUDE_LATITUDE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PJ_ELLPS2D_LONGITUDE_LATITUDE = 0
     * }
     */
    public static int PJ_ELLPS2D_LONGITUDE_LATITUDE() {
        return PJ_ELLPS2D_LONGITUDE_LATITUDE;
    }
    private static final int PJ_ELLPS2D_LATITUDE_LONGITUDE = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PJ_ELLPS2D_LATITUDE_LONGITUDE = 1
     * }
     */
    public static int PJ_ELLPS2D_LATITUDE_LONGITUDE() {
        return PJ_ELLPS2D_LATITUDE_LONGITUDE;
    }
    private static final int PJ_ELLPS3D_LONGITUDE_LATITUDE_HEIGHT = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PJ_ELLPS3D_LONGITUDE_LATITUDE_HEIGHT = 0
     * }
     */
    public static int PJ_ELLPS3D_LONGITUDE_LATITUDE_HEIGHT() {
        return PJ_ELLPS3D_LONGITUDE_LATITUDE_HEIGHT;
    }
    private static final int PJ_ELLPS3D_LATITUDE_LONGITUDE_HEIGHT = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PJ_ELLPS3D_LATITUDE_LONGITUDE_HEIGHT = 1
     * }
     */
    public static int PJ_ELLPS3D_LATITUDE_LONGITUDE_HEIGHT() {
        return PJ_ELLPS3D_LATITUDE_LONGITUDE_HEIGHT;
    }

    private static class proj_create_cs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_INT,
            proj_h.C_INT,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_create_cs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ *proj_create_cs(PJ_CONTEXT *ctx, PJ_COORDINATE_SYSTEM_TYPE type, int axis_count, const PJ_AXIS_DESCRIPTION *axis)
     * }
     */
    public static FunctionDescriptor proj_create_cs$descriptor() {
        return proj_create_cs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ *proj_create_cs(PJ_CONTEXT *ctx, PJ_COORDINATE_SYSTEM_TYPE type, int axis_count, const PJ_AXIS_DESCRIPTION *axis)
     * }
     */
    public static MethodHandle proj_create_cs$handle() {
        return proj_create_cs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ *proj_create_cs(PJ_CONTEXT *ctx, PJ_COORDINATE_SYSTEM_TYPE type, int axis_count, const PJ_AXIS_DESCRIPTION *axis)
     * }
     */
    public static MemorySegment proj_create_cs$address() {
        return proj_create_cs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ *proj_create_cs(PJ_CONTEXT *ctx, PJ_COORDINATE_SYSTEM_TYPE type, int axis_count, const PJ_AXIS_DESCRIPTION *axis)
     * }
     */
    public static MemorySegment proj_create_cs(MemorySegment ctx, int type, int axis_count, MemorySegment axis) {
        var mh$ = proj_create_cs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_create_cs", ctx, type, axis_count, axis);
            }
            return (MemorySegment)mh$.invokeExact(ctx, type, axis_count, axis);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_create_cartesian_2D_cs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_INT,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_create_cartesian_2D_cs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ *proj_create_cartesian_2D_cs(PJ_CONTEXT *ctx, PJ_CARTESIAN_CS_2D_TYPE type, const char *unit_name, double unit_conv_factor)
     * }
     */
    public static FunctionDescriptor proj_create_cartesian_2D_cs$descriptor() {
        return proj_create_cartesian_2D_cs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ *proj_create_cartesian_2D_cs(PJ_CONTEXT *ctx, PJ_CARTESIAN_CS_2D_TYPE type, const char *unit_name, double unit_conv_factor)
     * }
     */
    public static MethodHandle proj_create_cartesian_2D_cs$handle() {
        return proj_create_cartesian_2D_cs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ *proj_create_cartesian_2D_cs(PJ_CONTEXT *ctx, PJ_CARTESIAN_CS_2D_TYPE type, const char *unit_name, double unit_conv_factor)
     * }
     */
    public static MemorySegment proj_create_cartesian_2D_cs$address() {
        return proj_create_cartesian_2D_cs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ *proj_create_cartesian_2D_cs(PJ_CONTEXT *ctx, PJ_CARTESIAN_CS_2D_TYPE type, const char *unit_name, double unit_conv_factor)
     * }
     */
    public static MemorySegment proj_create_cartesian_2D_cs(MemorySegment ctx, int type, MemorySegment unit_name, double unit_conv_factor) {
        var mh$ = proj_create_cartesian_2D_cs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_create_cartesian_2D_cs", ctx, type, unit_name, unit_conv_factor);
            }
            return (MemorySegment)mh$.invokeExact(ctx, type, unit_name, unit_conv_factor);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_create_ellipsoidal_2D_cs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_INT,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_create_ellipsoidal_2D_cs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ *proj_create_ellipsoidal_2D_cs(PJ_CONTEXT *ctx, PJ_ELLIPSOIDAL_CS_2D_TYPE type, const char *unit_name, double unit_conv_factor)
     * }
     */
    public static FunctionDescriptor proj_create_ellipsoidal_2D_cs$descriptor() {
        return proj_create_ellipsoidal_2D_cs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ *proj_create_ellipsoidal_2D_cs(PJ_CONTEXT *ctx, PJ_ELLIPSOIDAL_CS_2D_TYPE type, const char *unit_name, double unit_conv_factor)
     * }
     */
    public static MethodHandle proj_create_ellipsoidal_2D_cs$handle() {
        return proj_create_ellipsoidal_2D_cs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ *proj_create_ellipsoidal_2D_cs(PJ_CONTEXT *ctx, PJ_ELLIPSOIDAL_CS_2D_TYPE type, const char *unit_name, double unit_conv_factor)
     * }
     */
    public static MemorySegment proj_create_ellipsoidal_2D_cs$address() {
        return proj_create_ellipsoidal_2D_cs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ *proj_create_ellipsoidal_2D_cs(PJ_CONTEXT *ctx, PJ_ELLIPSOIDAL_CS_2D_TYPE type, const char *unit_name, double unit_conv_factor)
     * }
     */
    public static MemorySegment proj_create_ellipsoidal_2D_cs(MemorySegment ctx, int type, MemorySegment unit_name, double unit_conv_factor) {
        var mh$ = proj_create_ellipsoidal_2D_cs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_create_ellipsoidal_2D_cs", ctx, type, unit_name, unit_conv_factor);
            }
            return (MemorySegment)mh$.invokeExact(ctx, type, unit_name, unit_conv_factor);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_create_ellipsoidal_3D_cs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_INT,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_create_ellipsoidal_3D_cs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ *proj_create_ellipsoidal_3D_cs(PJ_CONTEXT *ctx, PJ_ELLIPSOIDAL_CS_3D_TYPE type, const char *horizontal_angular_unit_name, double horizontal_angular_unit_conv_factor, const char *vertical_linear_unit_name, double vertical_linear_unit_conv_factor)
     * }
     */
    public static FunctionDescriptor proj_create_ellipsoidal_3D_cs$descriptor() {
        return proj_create_ellipsoidal_3D_cs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ *proj_create_ellipsoidal_3D_cs(PJ_CONTEXT *ctx, PJ_ELLIPSOIDAL_CS_3D_TYPE type, const char *horizontal_angular_unit_name, double horizontal_angular_unit_conv_factor, const char *vertical_linear_unit_name, double vertical_linear_unit_conv_factor)
     * }
     */
    public static MethodHandle proj_create_ellipsoidal_3D_cs$handle() {
        return proj_create_ellipsoidal_3D_cs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ *proj_create_ellipsoidal_3D_cs(PJ_CONTEXT *ctx, PJ_ELLIPSOIDAL_CS_3D_TYPE type, const char *horizontal_angular_unit_name, double horizontal_angular_unit_conv_factor, const char *vertical_linear_unit_name, double vertical_linear_unit_conv_factor)
     * }
     */
    public static MemorySegment proj_create_ellipsoidal_3D_cs$address() {
        return proj_create_ellipsoidal_3D_cs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ *proj_create_ellipsoidal_3D_cs(PJ_CONTEXT *ctx, PJ_ELLIPSOIDAL_CS_3D_TYPE type, const char *horizontal_angular_unit_name, double horizontal_angular_unit_conv_factor, const char *vertical_linear_unit_name, double vertical_linear_unit_conv_factor)
     * }
     */
    public static MemorySegment proj_create_ellipsoidal_3D_cs(MemorySegment ctx, int type, MemorySegment horizontal_angular_unit_name, double horizontal_angular_unit_conv_factor, MemorySegment vertical_linear_unit_name, double vertical_linear_unit_conv_factor) {
        var mh$ = proj_create_ellipsoidal_3D_cs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_create_ellipsoidal_3D_cs", ctx, type, horizontal_angular_unit_name, horizontal_angular_unit_conv_factor, vertical_linear_unit_name, vertical_linear_unit_conv_factor);
            }
            return (MemorySegment)mh$.invokeExact(ctx, type, horizontal_angular_unit_name, horizontal_angular_unit_conv_factor, vertical_linear_unit_name, vertical_linear_unit_conv_factor);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_query_geodetic_crs_from_datum {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_query_geodetic_crs_from_datum");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ_OBJ_LIST *proj_query_geodetic_crs_from_datum(PJ_CONTEXT *ctx, const char *crs_auth_name, const char *datum_auth_name, const char *datum_code, const char *crs_type)
     * }
     */
    public static FunctionDescriptor proj_query_geodetic_crs_from_datum$descriptor() {
        return proj_query_geodetic_crs_from_datum.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ_OBJ_LIST *proj_query_geodetic_crs_from_datum(PJ_CONTEXT *ctx, const char *crs_auth_name, const char *datum_auth_name, const char *datum_code, const char *crs_type)
     * }
     */
    public static MethodHandle proj_query_geodetic_crs_from_datum$handle() {
        return proj_query_geodetic_crs_from_datum.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ_OBJ_LIST *proj_query_geodetic_crs_from_datum(PJ_CONTEXT *ctx, const char *crs_auth_name, const char *datum_auth_name, const char *datum_code, const char *crs_type)
     * }
     */
    public static MemorySegment proj_query_geodetic_crs_from_datum$address() {
        return proj_query_geodetic_crs_from_datum.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ_OBJ_LIST *proj_query_geodetic_crs_from_datum(PJ_CONTEXT *ctx, const char *crs_auth_name, const char *datum_auth_name, const char *datum_code, const char *crs_type)
     * }
     */
    public static MemorySegment proj_query_geodetic_crs_from_datum(MemorySegment ctx, MemorySegment crs_auth_name, MemorySegment datum_auth_name, MemorySegment datum_code, MemorySegment crs_type) {
        var mh$ = proj_query_geodetic_crs_from_datum.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_query_geodetic_crs_from_datum", ctx, crs_auth_name, datum_auth_name, datum_code, crs_type);
            }
            return (MemorySegment)mh$.invokeExact(ctx, crs_auth_name, datum_auth_name, datum_code, crs_type);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_create_geographic_crs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_create_geographic_crs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ *proj_create_geographic_crs(PJ_CONTEXT *ctx, const char *crs_name, const char *datum_name, const char *ellps_name, double semi_major_metre, double inv_flattening, const char *prime_meridian_name, double prime_meridian_offset, const char *pm_angular_units, double pm_units_conv, const PJ *ellipsoidal_cs)
     * }
     */
    public static FunctionDescriptor proj_create_geographic_crs$descriptor() {
        return proj_create_geographic_crs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ *proj_create_geographic_crs(PJ_CONTEXT *ctx, const char *crs_name, const char *datum_name, const char *ellps_name, double semi_major_metre, double inv_flattening, const char *prime_meridian_name, double prime_meridian_offset, const char *pm_angular_units, double pm_units_conv, const PJ *ellipsoidal_cs)
     * }
     */
    public static MethodHandle proj_create_geographic_crs$handle() {
        return proj_create_geographic_crs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ *proj_create_geographic_crs(PJ_CONTEXT *ctx, const char *crs_name, const char *datum_name, const char *ellps_name, double semi_major_metre, double inv_flattening, const char *prime_meridian_name, double prime_meridian_offset, const char *pm_angular_units, double pm_units_conv, const PJ *ellipsoidal_cs)
     * }
     */
    public static MemorySegment proj_create_geographic_crs$address() {
        return proj_create_geographic_crs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ *proj_create_geographic_crs(PJ_CONTEXT *ctx, const char *crs_name, const char *datum_name, const char *ellps_name, double semi_major_metre, double inv_flattening, const char *prime_meridian_name, double prime_meridian_offset, const char *pm_angular_units, double pm_units_conv, const PJ *ellipsoidal_cs)
     * }
     */
    public static MemorySegment proj_create_geographic_crs(MemorySegment ctx, MemorySegment crs_name, MemorySegment datum_name, MemorySegment ellps_name, double semi_major_metre, double inv_flattening, MemorySegment prime_meridian_name, double prime_meridian_offset, MemorySegment pm_angular_units, double pm_units_conv, MemorySegment ellipsoidal_cs) {
        var mh$ = proj_create_geographic_crs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_create_geographic_crs", ctx, crs_name, datum_name, ellps_name, semi_major_metre, inv_flattening, prime_meridian_name, prime_meridian_offset, pm_angular_units, pm_units_conv, ellipsoidal_cs);
            }
            return (MemorySegment)mh$.invokeExact(ctx, crs_name, datum_name, ellps_name, semi_major_metre, inv_flattening, prime_meridian_name, prime_meridian_offset, pm_angular_units, pm_units_conv, ellipsoidal_cs);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_create_geographic_crs_from_datum {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_create_geographic_crs_from_datum");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ *proj_create_geographic_crs_from_datum(PJ_CONTEXT *ctx, const char *crs_name, const PJ *datum_or_datum_ensemble, const PJ *ellipsoidal_cs)
     * }
     */
    public static FunctionDescriptor proj_create_geographic_crs_from_datum$descriptor() {
        return proj_create_geographic_crs_from_datum.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ *proj_create_geographic_crs_from_datum(PJ_CONTEXT *ctx, const char *crs_name, const PJ *datum_or_datum_ensemble, const PJ *ellipsoidal_cs)
     * }
     */
    public static MethodHandle proj_create_geographic_crs_from_datum$handle() {
        return proj_create_geographic_crs_from_datum.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ *proj_create_geographic_crs_from_datum(PJ_CONTEXT *ctx, const char *crs_name, const PJ *datum_or_datum_ensemble, const PJ *ellipsoidal_cs)
     * }
     */
    public static MemorySegment proj_create_geographic_crs_from_datum$address() {
        return proj_create_geographic_crs_from_datum.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ *proj_create_geographic_crs_from_datum(PJ_CONTEXT *ctx, const char *crs_name, const PJ *datum_or_datum_ensemble, const PJ *ellipsoidal_cs)
     * }
     */
    public static MemorySegment proj_create_geographic_crs_from_datum(MemorySegment ctx, MemorySegment crs_name, MemorySegment datum_or_datum_ensemble, MemorySegment ellipsoidal_cs) {
        var mh$ = proj_create_geographic_crs_from_datum.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_create_geographic_crs_from_datum", ctx, crs_name, datum_or_datum_ensemble, ellipsoidal_cs);
            }
            return (MemorySegment)mh$.invokeExact(ctx, crs_name, datum_or_datum_ensemble, ellipsoidal_cs);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_create_geocentric_crs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_create_geocentric_crs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ *proj_create_geocentric_crs(PJ_CONTEXT *ctx, const char *crs_name, const char *datum_name, const char *ellps_name, double semi_major_metre, double inv_flattening, const char *prime_meridian_name, double prime_meridian_offset, const char *angular_units, double angular_units_conv, const char *linear_units, double linear_units_conv)
     * }
     */
    public static FunctionDescriptor proj_create_geocentric_crs$descriptor() {
        return proj_create_geocentric_crs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ *proj_create_geocentric_crs(PJ_CONTEXT *ctx, const char *crs_name, const char *datum_name, const char *ellps_name, double semi_major_metre, double inv_flattening, const char *prime_meridian_name, double prime_meridian_offset, const char *angular_units, double angular_units_conv, const char *linear_units, double linear_units_conv)
     * }
     */
    public static MethodHandle proj_create_geocentric_crs$handle() {
        return proj_create_geocentric_crs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ *proj_create_geocentric_crs(PJ_CONTEXT *ctx, const char *crs_name, const char *datum_name, const char *ellps_name, double semi_major_metre, double inv_flattening, const char *prime_meridian_name, double prime_meridian_offset, const char *angular_units, double angular_units_conv, const char *linear_units, double linear_units_conv)
     * }
     */
    public static MemorySegment proj_create_geocentric_crs$address() {
        return proj_create_geocentric_crs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ *proj_create_geocentric_crs(PJ_CONTEXT *ctx, const char *crs_name, const char *datum_name, const char *ellps_name, double semi_major_metre, double inv_flattening, const char *prime_meridian_name, double prime_meridian_offset, const char *angular_units, double angular_units_conv, const char *linear_units, double linear_units_conv)
     * }
     */
    public static MemorySegment proj_create_geocentric_crs(MemorySegment ctx, MemorySegment crs_name, MemorySegment datum_name, MemorySegment ellps_name, double semi_major_metre, double inv_flattening, MemorySegment prime_meridian_name, double prime_meridian_offset, MemorySegment angular_units, double angular_units_conv, MemorySegment linear_units, double linear_units_conv) {
        var mh$ = proj_create_geocentric_crs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_create_geocentric_crs", ctx, crs_name, datum_name, ellps_name, semi_major_metre, inv_flattening, prime_meridian_name, prime_meridian_offset, angular_units, angular_units_conv, linear_units, linear_units_conv);
            }
            return (MemorySegment)mh$.invokeExact(ctx, crs_name, datum_name, ellps_name, semi_major_metre, inv_flattening, prime_meridian_name, prime_meridian_offset, angular_units, angular_units_conv, linear_units, linear_units_conv);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_create_geocentric_crs_from_datum {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_create_geocentric_crs_from_datum");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ *proj_create_geocentric_crs_from_datum(PJ_CONTEXT *ctx, const char *crs_name, const PJ *datum_or_datum_ensemble, const char *linear_units, double linear_units_conv)
     * }
     */
    public static FunctionDescriptor proj_create_geocentric_crs_from_datum$descriptor() {
        return proj_create_geocentric_crs_from_datum.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ *proj_create_geocentric_crs_from_datum(PJ_CONTEXT *ctx, const char *crs_name, const PJ *datum_or_datum_ensemble, const char *linear_units, double linear_units_conv)
     * }
     */
    public static MethodHandle proj_create_geocentric_crs_from_datum$handle() {
        return proj_create_geocentric_crs_from_datum.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ *proj_create_geocentric_crs_from_datum(PJ_CONTEXT *ctx, const char *crs_name, const PJ *datum_or_datum_ensemble, const char *linear_units, double linear_units_conv)
     * }
     */
    public static MemorySegment proj_create_geocentric_crs_from_datum$address() {
        return proj_create_geocentric_crs_from_datum.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ *proj_create_geocentric_crs_from_datum(PJ_CONTEXT *ctx, const char *crs_name, const PJ *datum_or_datum_ensemble, const char *linear_units, double linear_units_conv)
     * }
     */
    public static MemorySegment proj_create_geocentric_crs_from_datum(MemorySegment ctx, MemorySegment crs_name, MemorySegment datum_or_datum_ensemble, MemorySegment linear_units, double linear_units_conv) {
        var mh$ = proj_create_geocentric_crs_from_datum.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_create_geocentric_crs_from_datum", ctx, crs_name, datum_or_datum_ensemble, linear_units, linear_units_conv);
            }
            return (MemorySegment)mh$.invokeExact(ctx, crs_name, datum_or_datum_ensemble, linear_units, linear_units_conv);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_create_derived_geographic_crs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_create_derived_geographic_crs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ *proj_create_derived_geographic_crs(PJ_CONTEXT *ctx, const char *crs_name, const PJ *base_geographic_crs, const PJ *conversion, const PJ *ellipsoidal_cs)
     * }
     */
    public static FunctionDescriptor proj_create_derived_geographic_crs$descriptor() {
        return proj_create_derived_geographic_crs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ *proj_create_derived_geographic_crs(PJ_CONTEXT *ctx, const char *crs_name, const PJ *base_geographic_crs, const PJ *conversion, const PJ *ellipsoidal_cs)
     * }
     */
    public static MethodHandle proj_create_derived_geographic_crs$handle() {
        return proj_create_derived_geographic_crs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ *proj_create_derived_geographic_crs(PJ_CONTEXT *ctx, const char *crs_name, const PJ *base_geographic_crs, const PJ *conversion, const PJ *ellipsoidal_cs)
     * }
     */
    public static MemorySegment proj_create_derived_geographic_crs$address() {
        return proj_create_derived_geographic_crs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ *proj_create_derived_geographic_crs(PJ_CONTEXT *ctx, const char *crs_name, const PJ *base_geographic_crs, const PJ *conversion, const PJ *ellipsoidal_cs)
     * }
     */
    public static MemorySegment proj_create_derived_geographic_crs(MemorySegment ctx, MemorySegment crs_name, MemorySegment base_geographic_crs, MemorySegment conversion, MemorySegment ellipsoidal_cs) {
        var mh$ = proj_create_derived_geographic_crs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_create_derived_geographic_crs", ctx, crs_name, base_geographic_crs, conversion, ellipsoidal_cs);
            }
            return (MemorySegment)mh$.invokeExact(ctx, crs_name, base_geographic_crs, conversion, ellipsoidal_cs);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_is_derived_crs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_INT,
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_is_derived_crs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int proj_is_derived_crs(PJ_CONTEXT *ctx, const PJ *crs)
     * }
     */
    public static FunctionDescriptor proj_is_derived_crs$descriptor() {
        return proj_is_derived_crs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int proj_is_derived_crs(PJ_CONTEXT *ctx, const PJ *crs)
     * }
     */
    public static MethodHandle proj_is_derived_crs$handle() {
        return proj_is_derived_crs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int proj_is_derived_crs(PJ_CONTEXT *ctx, const PJ *crs)
     * }
     */
    public static MemorySegment proj_is_derived_crs$address() {
        return proj_is_derived_crs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int proj_is_derived_crs(PJ_CONTEXT *ctx, const PJ *crs)
     * }
     */
    public static int proj_is_derived_crs(MemorySegment ctx, MemorySegment crs) {
        var mh$ = proj_is_derived_crs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_is_derived_crs", ctx, crs);
            }
            return (int)mh$.invokeExact(ctx, crs);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_alter_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_alter_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ *proj_alter_name(PJ_CONTEXT *ctx, const PJ *obj, const char *name)
     * }
     */
    public static FunctionDescriptor proj_alter_name$descriptor() {
        return proj_alter_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ *proj_alter_name(PJ_CONTEXT *ctx, const PJ *obj, const char *name)
     * }
     */
    public static MethodHandle proj_alter_name$handle() {
        return proj_alter_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ *proj_alter_name(PJ_CONTEXT *ctx, const PJ *obj, const char *name)
     * }
     */
    public static MemorySegment proj_alter_name$address() {
        return proj_alter_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ *proj_alter_name(PJ_CONTEXT *ctx, const PJ *obj, const char *name)
     * }
     */
    public static MemorySegment proj_alter_name(MemorySegment ctx, MemorySegment obj, MemorySegment name) {
        var mh$ = proj_alter_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_alter_name", ctx, obj, name);
            }
            return (MemorySegment)mh$.invokeExact(ctx, obj, name);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_alter_id {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_alter_id");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ *proj_alter_id(PJ_CONTEXT *ctx, const PJ *obj, const char *auth_name, const char *code)
     * }
     */
    public static FunctionDescriptor proj_alter_id$descriptor() {
        return proj_alter_id.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ *proj_alter_id(PJ_CONTEXT *ctx, const PJ *obj, const char *auth_name, const char *code)
     * }
     */
    public static MethodHandle proj_alter_id$handle() {
        return proj_alter_id.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ *proj_alter_id(PJ_CONTEXT *ctx, const PJ *obj, const char *auth_name, const char *code)
     * }
     */
    public static MemorySegment proj_alter_id$address() {
        return proj_alter_id.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ *proj_alter_id(PJ_CONTEXT *ctx, const PJ *obj, const char *auth_name, const char *code)
     * }
     */
    public static MemorySegment proj_alter_id(MemorySegment ctx, MemorySegment obj, MemorySegment auth_name, MemorySegment code) {
        var mh$ = proj_alter_id.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_alter_id", ctx, obj, auth_name, code);
            }
            return (MemorySegment)mh$.invokeExact(ctx, obj, auth_name, code);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_crs_alter_geodetic_crs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_crs_alter_geodetic_crs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ *proj_crs_alter_geodetic_crs(PJ_CONTEXT *ctx, const PJ *obj, const PJ *new_geod_crs)
     * }
     */
    public static FunctionDescriptor proj_crs_alter_geodetic_crs$descriptor() {
        return proj_crs_alter_geodetic_crs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ *proj_crs_alter_geodetic_crs(PJ_CONTEXT *ctx, const PJ *obj, const PJ *new_geod_crs)
     * }
     */
    public static MethodHandle proj_crs_alter_geodetic_crs$handle() {
        return proj_crs_alter_geodetic_crs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ *proj_crs_alter_geodetic_crs(PJ_CONTEXT *ctx, const PJ *obj, const PJ *new_geod_crs)
     * }
     */
    public static MemorySegment proj_crs_alter_geodetic_crs$address() {
        return proj_crs_alter_geodetic_crs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ *proj_crs_alter_geodetic_crs(PJ_CONTEXT *ctx, const PJ *obj, const PJ *new_geod_crs)
     * }
     */
    public static MemorySegment proj_crs_alter_geodetic_crs(MemorySegment ctx, MemorySegment obj, MemorySegment new_geod_crs) {
        var mh$ = proj_crs_alter_geodetic_crs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_crs_alter_geodetic_crs", ctx, obj, new_geod_crs);
            }
            return (MemorySegment)mh$.invokeExact(ctx, obj, new_geod_crs);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_crs_alter_cs_angular_unit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_crs_alter_cs_angular_unit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ *proj_crs_alter_cs_angular_unit(PJ_CONTEXT *ctx, const PJ *obj, const char *angular_units, double angular_units_conv, const char *unit_auth_name, const char *unit_code)
     * }
     */
    public static FunctionDescriptor proj_crs_alter_cs_angular_unit$descriptor() {
        return proj_crs_alter_cs_angular_unit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ *proj_crs_alter_cs_angular_unit(PJ_CONTEXT *ctx, const PJ *obj, const char *angular_units, double angular_units_conv, const char *unit_auth_name, const char *unit_code)
     * }
     */
    public static MethodHandle proj_crs_alter_cs_angular_unit$handle() {
        return proj_crs_alter_cs_angular_unit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ *proj_crs_alter_cs_angular_unit(PJ_CONTEXT *ctx, const PJ *obj, const char *angular_units, double angular_units_conv, const char *unit_auth_name, const char *unit_code)
     * }
     */
    public static MemorySegment proj_crs_alter_cs_angular_unit$address() {
        return proj_crs_alter_cs_angular_unit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ *proj_crs_alter_cs_angular_unit(PJ_CONTEXT *ctx, const PJ *obj, const char *angular_units, double angular_units_conv, const char *unit_auth_name, const char *unit_code)
     * }
     */
    public static MemorySegment proj_crs_alter_cs_angular_unit(MemorySegment ctx, MemorySegment obj, MemorySegment angular_units, double angular_units_conv, MemorySegment unit_auth_name, MemorySegment unit_code) {
        var mh$ = proj_crs_alter_cs_angular_unit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_crs_alter_cs_angular_unit", ctx, obj, angular_units, angular_units_conv, unit_auth_name, unit_code);
            }
            return (MemorySegment)mh$.invokeExact(ctx, obj, angular_units, angular_units_conv, unit_auth_name, unit_code);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_crs_alter_cs_linear_unit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_crs_alter_cs_linear_unit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ *proj_crs_alter_cs_linear_unit(PJ_CONTEXT *ctx, const PJ *obj, const char *linear_units, double linear_units_conv, const char *unit_auth_name, const char *unit_code)
     * }
     */
    public static FunctionDescriptor proj_crs_alter_cs_linear_unit$descriptor() {
        return proj_crs_alter_cs_linear_unit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ *proj_crs_alter_cs_linear_unit(PJ_CONTEXT *ctx, const PJ *obj, const char *linear_units, double linear_units_conv, const char *unit_auth_name, const char *unit_code)
     * }
     */
    public static MethodHandle proj_crs_alter_cs_linear_unit$handle() {
        return proj_crs_alter_cs_linear_unit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ *proj_crs_alter_cs_linear_unit(PJ_CONTEXT *ctx, const PJ *obj, const char *linear_units, double linear_units_conv, const char *unit_auth_name, const char *unit_code)
     * }
     */
    public static MemorySegment proj_crs_alter_cs_linear_unit$address() {
        return proj_crs_alter_cs_linear_unit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ *proj_crs_alter_cs_linear_unit(PJ_CONTEXT *ctx, const PJ *obj, const char *linear_units, double linear_units_conv, const char *unit_auth_name, const char *unit_code)
     * }
     */
    public static MemorySegment proj_crs_alter_cs_linear_unit(MemorySegment ctx, MemorySegment obj, MemorySegment linear_units, double linear_units_conv, MemorySegment unit_auth_name, MemorySegment unit_code) {
        var mh$ = proj_crs_alter_cs_linear_unit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_crs_alter_cs_linear_unit", ctx, obj, linear_units, linear_units_conv, unit_auth_name, unit_code);
            }
            return (MemorySegment)mh$.invokeExact(ctx, obj, linear_units, linear_units_conv, unit_auth_name, unit_code);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_crs_alter_parameters_linear_unit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_crs_alter_parameters_linear_unit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ *proj_crs_alter_parameters_linear_unit(PJ_CONTEXT *ctx, const PJ *obj, const char *linear_units, double linear_units_conv, const char *unit_auth_name, const char *unit_code, int convert_to_new_unit)
     * }
     */
    public static FunctionDescriptor proj_crs_alter_parameters_linear_unit$descriptor() {
        return proj_crs_alter_parameters_linear_unit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ *proj_crs_alter_parameters_linear_unit(PJ_CONTEXT *ctx, const PJ *obj, const char *linear_units, double linear_units_conv, const char *unit_auth_name, const char *unit_code, int convert_to_new_unit)
     * }
     */
    public static MethodHandle proj_crs_alter_parameters_linear_unit$handle() {
        return proj_crs_alter_parameters_linear_unit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ *proj_crs_alter_parameters_linear_unit(PJ_CONTEXT *ctx, const PJ *obj, const char *linear_units, double linear_units_conv, const char *unit_auth_name, const char *unit_code, int convert_to_new_unit)
     * }
     */
    public static MemorySegment proj_crs_alter_parameters_linear_unit$address() {
        return proj_crs_alter_parameters_linear_unit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ *proj_crs_alter_parameters_linear_unit(PJ_CONTEXT *ctx, const PJ *obj, const char *linear_units, double linear_units_conv, const char *unit_auth_name, const char *unit_code, int convert_to_new_unit)
     * }
     */
    public static MemorySegment proj_crs_alter_parameters_linear_unit(MemorySegment ctx, MemorySegment obj, MemorySegment linear_units, double linear_units_conv, MemorySegment unit_auth_name, MemorySegment unit_code, int convert_to_new_unit) {
        var mh$ = proj_crs_alter_parameters_linear_unit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_crs_alter_parameters_linear_unit", ctx, obj, linear_units, linear_units_conv, unit_auth_name, unit_code, convert_to_new_unit);
            }
            return (MemorySegment)mh$.invokeExact(ctx, obj, linear_units, linear_units_conv, unit_auth_name, unit_code, convert_to_new_unit);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_crs_promote_to_3D {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_crs_promote_to_3D");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ *proj_crs_promote_to_3D(PJ_CONTEXT *ctx, const char *crs_3D_name, const PJ *crs_2D)
     * }
     */
    public static FunctionDescriptor proj_crs_promote_to_3D$descriptor() {
        return proj_crs_promote_to_3D.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ *proj_crs_promote_to_3D(PJ_CONTEXT *ctx, const char *crs_3D_name, const PJ *crs_2D)
     * }
     */
    public static MethodHandle proj_crs_promote_to_3D$handle() {
        return proj_crs_promote_to_3D.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ *proj_crs_promote_to_3D(PJ_CONTEXT *ctx, const char *crs_3D_name, const PJ *crs_2D)
     * }
     */
    public static MemorySegment proj_crs_promote_to_3D$address() {
        return proj_crs_promote_to_3D.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ *proj_crs_promote_to_3D(PJ_CONTEXT *ctx, const char *crs_3D_name, const PJ *crs_2D)
     * }
     */
    public static MemorySegment proj_crs_promote_to_3D(MemorySegment ctx, MemorySegment crs_3D_name, MemorySegment crs_2D) {
        var mh$ = proj_crs_promote_to_3D.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_crs_promote_to_3D", ctx, crs_3D_name, crs_2D);
            }
            return (MemorySegment)mh$.invokeExact(ctx, crs_3D_name, crs_2D);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_crs_create_projected_3D_crs_from_2D {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_crs_create_projected_3D_crs_from_2D");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ *proj_crs_create_projected_3D_crs_from_2D(PJ_CONTEXT *ctx, const char *crs_name, const PJ *projected_2D_crs, const PJ *geog_3D_crs)
     * }
     */
    public static FunctionDescriptor proj_crs_create_projected_3D_crs_from_2D$descriptor() {
        return proj_crs_create_projected_3D_crs_from_2D.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ *proj_crs_create_projected_3D_crs_from_2D(PJ_CONTEXT *ctx, const char *crs_name, const PJ *projected_2D_crs, const PJ *geog_3D_crs)
     * }
     */
    public static MethodHandle proj_crs_create_projected_3D_crs_from_2D$handle() {
        return proj_crs_create_projected_3D_crs_from_2D.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ *proj_crs_create_projected_3D_crs_from_2D(PJ_CONTEXT *ctx, const char *crs_name, const PJ *projected_2D_crs, const PJ *geog_3D_crs)
     * }
     */
    public static MemorySegment proj_crs_create_projected_3D_crs_from_2D$address() {
        return proj_crs_create_projected_3D_crs_from_2D.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ *proj_crs_create_projected_3D_crs_from_2D(PJ_CONTEXT *ctx, const char *crs_name, const PJ *projected_2D_crs, const PJ *geog_3D_crs)
     * }
     */
    public static MemorySegment proj_crs_create_projected_3D_crs_from_2D(MemorySegment ctx, MemorySegment crs_name, MemorySegment projected_2D_crs, MemorySegment geog_3D_crs) {
        var mh$ = proj_crs_create_projected_3D_crs_from_2D.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_crs_create_projected_3D_crs_from_2D", ctx, crs_name, projected_2D_crs, geog_3D_crs);
            }
            return (MemorySegment)mh$.invokeExact(ctx, crs_name, projected_2D_crs, geog_3D_crs);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_crs_demote_to_2D {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_crs_demote_to_2D");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ *proj_crs_demote_to_2D(PJ_CONTEXT *ctx, const char *crs_2D_name, const PJ *crs_3D)
     * }
     */
    public static FunctionDescriptor proj_crs_demote_to_2D$descriptor() {
        return proj_crs_demote_to_2D.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ *proj_crs_demote_to_2D(PJ_CONTEXT *ctx, const char *crs_2D_name, const PJ *crs_3D)
     * }
     */
    public static MethodHandle proj_crs_demote_to_2D$handle() {
        return proj_crs_demote_to_2D.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ *proj_crs_demote_to_2D(PJ_CONTEXT *ctx, const char *crs_2D_name, const PJ *crs_3D)
     * }
     */
    public static MemorySegment proj_crs_demote_to_2D$address() {
        return proj_crs_demote_to_2D.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ *proj_crs_demote_to_2D(PJ_CONTEXT *ctx, const char *crs_2D_name, const PJ *crs_3D)
     * }
     */
    public static MemorySegment proj_crs_demote_to_2D(MemorySegment ctx, MemorySegment crs_2D_name, MemorySegment crs_3D) {
        var mh$ = proj_crs_demote_to_2D.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_crs_demote_to_2D", ctx, crs_2D_name, crs_3D);
            }
            return (MemorySegment)mh$.invokeExact(ctx, crs_2D_name, crs_3D);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_create_engineering_crs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_create_engineering_crs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ *proj_create_engineering_crs(PJ_CONTEXT *ctx, const char *crsName)
     * }
     */
    public static FunctionDescriptor proj_create_engineering_crs$descriptor() {
        return proj_create_engineering_crs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ *proj_create_engineering_crs(PJ_CONTEXT *ctx, const char *crsName)
     * }
     */
    public static MethodHandle proj_create_engineering_crs$handle() {
        return proj_create_engineering_crs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ *proj_create_engineering_crs(PJ_CONTEXT *ctx, const char *crsName)
     * }
     */
    public static MemorySegment proj_create_engineering_crs$address() {
        return proj_create_engineering_crs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ *proj_create_engineering_crs(PJ_CONTEXT *ctx, const char *crsName)
     * }
     */
    public static MemorySegment proj_create_engineering_crs(MemorySegment ctx, MemorySegment crsName) {
        var mh$ = proj_create_engineering_crs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_create_engineering_crs", ctx, crsName);
            }
            return (MemorySegment)mh$.invokeExact(ctx, crsName);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_create_vertical_crs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_create_vertical_crs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ *proj_create_vertical_crs(PJ_CONTEXT *ctx, const char *crs_name, const char *datum_name, const char *linear_units, double linear_units_conv)
     * }
     */
    public static FunctionDescriptor proj_create_vertical_crs$descriptor() {
        return proj_create_vertical_crs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ *proj_create_vertical_crs(PJ_CONTEXT *ctx, const char *crs_name, const char *datum_name, const char *linear_units, double linear_units_conv)
     * }
     */
    public static MethodHandle proj_create_vertical_crs$handle() {
        return proj_create_vertical_crs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ *proj_create_vertical_crs(PJ_CONTEXT *ctx, const char *crs_name, const char *datum_name, const char *linear_units, double linear_units_conv)
     * }
     */
    public static MemorySegment proj_create_vertical_crs$address() {
        return proj_create_vertical_crs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ *proj_create_vertical_crs(PJ_CONTEXT *ctx, const char *crs_name, const char *datum_name, const char *linear_units, double linear_units_conv)
     * }
     */
    public static MemorySegment proj_create_vertical_crs(MemorySegment ctx, MemorySegment crs_name, MemorySegment datum_name, MemorySegment linear_units, double linear_units_conv) {
        var mh$ = proj_create_vertical_crs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_create_vertical_crs", ctx, crs_name, datum_name, linear_units, linear_units_conv);
            }
            return (MemorySegment)mh$.invokeExact(ctx, crs_name, datum_name, linear_units, linear_units_conv);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_create_vertical_crs_ex {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_create_vertical_crs_ex");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ *proj_create_vertical_crs_ex(PJ_CONTEXT *ctx, const char *crs_name, const char *datum_name, const char *datum_auth_name, const char *datum_code, const char *linear_units, double linear_units_conv, const char *geoid_model_name, const char *geoid_model_auth_name, const char *geoid_model_code, const PJ *geoid_geog_crs, const char *const *options)
     * }
     */
    public static FunctionDescriptor proj_create_vertical_crs_ex$descriptor() {
        return proj_create_vertical_crs_ex.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ *proj_create_vertical_crs_ex(PJ_CONTEXT *ctx, const char *crs_name, const char *datum_name, const char *datum_auth_name, const char *datum_code, const char *linear_units, double linear_units_conv, const char *geoid_model_name, const char *geoid_model_auth_name, const char *geoid_model_code, const PJ *geoid_geog_crs, const char *const *options)
     * }
     */
    public static MethodHandle proj_create_vertical_crs_ex$handle() {
        return proj_create_vertical_crs_ex.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ *proj_create_vertical_crs_ex(PJ_CONTEXT *ctx, const char *crs_name, const char *datum_name, const char *datum_auth_name, const char *datum_code, const char *linear_units, double linear_units_conv, const char *geoid_model_name, const char *geoid_model_auth_name, const char *geoid_model_code, const PJ *geoid_geog_crs, const char *const *options)
     * }
     */
    public static MemorySegment proj_create_vertical_crs_ex$address() {
        return proj_create_vertical_crs_ex.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ *proj_create_vertical_crs_ex(PJ_CONTEXT *ctx, const char *crs_name, const char *datum_name, const char *datum_auth_name, const char *datum_code, const char *linear_units, double linear_units_conv, const char *geoid_model_name, const char *geoid_model_auth_name, const char *geoid_model_code, const PJ *geoid_geog_crs, const char *const *options)
     * }
     */
    public static MemorySegment proj_create_vertical_crs_ex(MemorySegment ctx, MemorySegment crs_name, MemorySegment datum_name, MemorySegment datum_auth_name, MemorySegment datum_code, MemorySegment linear_units, double linear_units_conv, MemorySegment geoid_model_name, MemorySegment geoid_model_auth_name, MemorySegment geoid_model_code, MemorySegment geoid_geog_crs, MemorySegment options) {
        var mh$ = proj_create_vertical_crs_ex.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_create_vertical_crs_ex", ctx, crs_name, datum_name, datum_auth_name, datum_code, linear_units, linear_units_conv, geoid_model_name, geoid_model_auth_name, geoid_model_code, geoid_geog_crs, options);
            }
            return (MemorySegment)mh$.invokeExact(ctx, crs_name, datum_name, datum_auth_name, datum_code, linear_units, linear_units_conv, geoid_model_name, geoid_model_auth_name, geoid_model_code, geoid_geog_crs, options);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_create_compound_crs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_create_compound_crs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ *proj_create_compound_crs(PJ_CONTEXT *ctx, const char *crs_name, const PJ *horiz_crs, const PJ *vert_crs)
     * }
     */
    public static FunctionDescriptor proj_create_compound_crs$descriptor() {
        return proj_create_compound_crs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ *proj_create_compound_crs(PJ_CONTEXT *ctx, const char *crs_name, const PJ *horiz_crs, const PJ *vert_crs)
     * }
     */
    public static MethodHandle proj_create_compound_crs$handle() {
        return proj_create_compound_crs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ *proj_create_compound_crs(PJ_CONTEXT *ctx, const char *crs_name, const PJ *horiz_crs, const PJ *vert_crs)
     * }
     */
    public static MemorySegment proj_create_compound_crs$address() {
        return proj_create_compound_crs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ *proj_create_compound_crs(PJ_CONTEXT *ctx, const char *crs_name, const PJ *horiz_crs, const PJ *vert_crs)
     * }
     */
    public static MemorySegment proj_create_compound_crs(MemorySegment ctx, MemorySegment crs_name, MemorySegment horiz_crs, MemorySegment vert_crs) {
        var mh$ = proj_create_compound_crs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_create_compound_crs", ctx, crs_name, horiz_crs, vert_crs);
            }
            return (MemorySegment)mh$.invokeExact(ctx, crs_name, horiz_crs, vert_crs);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_create_conversion {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_INT,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_create_conversion");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion(PJ_CONTEXT *ctx, const char *name, const char *auth_name, const char *code, const char *method_name, const char *method_auth_name, const char *method_code, int param_count, const PJ_PARAM_DESCRIPTION *params)
     * }
     */
    public static FunctionDescriptor proj_create_conversion$descriptor() {
        return proj_create_conversion.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion(PJ_CONTEXT *ctx, const char *name, const char *auth_name, const char *code, const char *method_name, const char *method_auth_name, const char *method_code, int param_count, const PJ_PARAM_DESCRIPTION *params)
     * }
     */
    public static MethodHandle proj_create_conversion$handle() {
        return proj_create_conversion.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion(PJ_CONTEXT *ctx, const char *name, const char *auth_name, const char *code, const char *method_name, const char *method_auth_name, const char *method_code, int param_count, const PJ_PARAM_DESCRIPTION *params)
     * }
     */
    public static MemorySegment proj_create_conversion$address() {
        return proj_create_conversion.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ *proj_create_conversion(PJ_CONTEXT *ctx, const char *name, const char *auth_name, const char *code, const char *method_name, const char *method_auth_name, const char *method_code, int param_count, const PJ_PARAM_DESCRIPTION *params)
     * }
     */
    public static MemorySegment proj_create_conversion(MemorySegment ctx, MemorySegment name, MemorySegment auth_name, MemorySegment code, MemorySegment method_name, MemorySegment method_auth_name, MemorySegment method_code, int param_count, MemorySegment params) {
        var mh$ = proj_create_conversion.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_create_conversion", ctx, name, auth_name, code, method_name, method_auth_name, method_code, param_count, params);
            }
            return (MemorySegment)mh$.invokeExact(ctx, name, auth_name, code, method_name, method_auth_name, method_code, param_count, params);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_create_transformation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_INT,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_create_transformation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ *proj_create_transformation(PJ_CONTEXT *ctx, const char *name, const char *auth_name, const char *code, const PJ *source_crs, const PJ *target_crs, const PJ *interpolation_crs, const char *method_name, const char *method_auth_name, const char *method_code, int param_count, const PJ_PARAM_DESCRIPTION *params, double accuracy)
     * }
     */
    public static FunctionDescriptor proj_create_transformation$descriptor() {
        return proj_create_transformation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ *proj_create_transformation(PJ_CONTEXT *ctx, const char *name, const char *auth_name, const char *code, const PJ *source_crs, const PJ *target_crs, const PJ *interpolation_crs, const char *method_name, const char *method_auth_name, const char *method_code, int param_count, const PJ_PARAM_DESCRIPTION *params, double accuracy)
     * }
     */
    public static MethodHandle proj_create_transformation$handle() {
        return proj_create_transformation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ *proj_create_transformation(PJ_CONTEXT *ctx, const char *name, const char *auth_name, const char *code, const PJ *source_crs, const PJ *target_crs, const PJ *interpolation_crs, const char *method_name, const char *method_auth_name, const char *method_code, int param_count, const PJ_PARAM_DESCRIPTION *params, double accuracy)
     * }
     */
    public static MemorySegment proj_create_transformation$address() {
        return proj_create_transformation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ *proj_create_transformation(PJ_CONTEXT *ctx, const char *name, const char *auth_name, const char *code, const PJ *source_crs, const PJ *target_crs, const PJ *interpolation_crs, const char *method_name, const char *method_auth_name, const char *method_code, int param_count, const PJ_PARAM_DESCRIPTION *params, double accuracy)
     * }
     */
    public static MemorySegment proj_create_transformation(MemorySegment ctx, MemorySegment name, MemorySegment auth_name, MemorySegment code, MemorySegment source_crs, MemorySegment target_crs, MemorySegment interpolation_crs, MemorySegment method_name, MemorySegment method_auth_name, MemorySegment method_code, int param_count, MemorySegment params, double accuracy) {
        var mh$ = proj_create_transformation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_create_transformation", ctx, name, auth_name, code, source_crs, target_crs, interpolation_crs, method_name, method_auth_name, method_code, param_count, params, accuracy);
            }
            return (MemorySegment)mh$.invokeExact(ctx, name, auth_name, code, source_crs, target_crs, interpolation_crs, method_name, method_auth_name, method_code, param_count, params, accuracy);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_convert_conversion_to_other_method {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_INT,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_convert_conversion_to_other_method");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ *proj_convert_conversion_to_other_method(PJ_CONTEXT *ctx, const PJ *conversion, int new_method_epsg_code, const char *new_method_name)
     * }
     */
    public static FunctionDescriptor proj_convert_conversion_to_other_method$descriptor() {
        return proj_convert_conversion_to_other_method.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ *proj_convert_conversion_to_other_method(PJ_CONTEXT *ctx, const PJ *conversion, int new_method_epsg_code, const char *new_method_name)
     * }
     */
    public static MethodHandle proj_convert_conversion_to_other_method$handle() {
        return proj_convert_conversion_to_other_method.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ *proj_convert_conversion_to_other_method(PJ_CONTEXT *ctx, const PJ *conversion, int new_method_epsg_code, const char *new_method_name)
     * }
     */
    public static MemorySegment proj_convert_conversion_to_other_method$address() {
        return proj_convert_conversion_to_other_method.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ *proj_convert_conversion_to_other_method(PJ_CONTEXT *ctx, const PJ *conversion, int new_method_epsg_code, const char *new_method_name)
     * }
     */
    public static MemorySegment proj_convert_conversion_to_other_method(MemorySegment ctx, MemorySegment conversion, int new_method_epsg_code, MemorySegment new_method_name) {
        var mh$ = proj_convert_conversion_to_other_method.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_convert_conversion_to_other_method", ctx, conversion, new_method_epsg_code, new_method_name);
            }
            return (MemorySegment)mh$.invokeExact(ctx, conversion, new_method_epsg_code, new_method_name);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_create_projected_crs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_create_projected_crs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ *proj_create_projected_crs(PJ_CONTEXT *ctx, const char *crs_name, const PJ *geodetic_crs, const PJ *conversion, const PJ *coordinate_system)
     * }
     */
    public static FunctionDescriptor proj_create_projected_crs$descriptor() {
        return proj_create_projected_crs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ *proj_create_projected_crs(PJ_CONTEXT *ctx, const char *crs_name, const PJ *geodetic_crs, const PJ *conversion, const PJ *coordinate_system)
     * }
     */
    public static MethodHandle proj_create_projected_crs$handle() {
        return proj_create_projected_crs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ *proj_create_projected_crs(PJ_CONTEXT *ctx, const char *crs_name, const PJ *geodetic_crs, const PJ *conversion, const PJ *coordinate_system)
     * }
     */
    public static MemorySegment proj_create_projected_crs$address() {
        return proj_create_projected_crs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ *proj_create_projected_crs(PJ_CONTEXT *ctx, const char *crs_name, const PJ *geodetic_crs, const PJ *conversion, const PJ *coordinate_system)
     * }
     */
    public static MemorySegment proj_create_projected_crs(MemorySegment ctx, MemorySegment crs_name, MemorySegment geodetic_crs, MemorySegment conversion, MemorySegment coordinate_system) {
        var mh$ = proj_create_projected_crs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_create_projected_crs", ctx, crs_name, geodetic_crs, conversion, coordinate_system);
            }
            return (MemorySegment)mh$.invokeExact(ctx, crs_name, geodetic_crs, conversion, coordinate_system);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_crs_create_bound_crs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_crs_create_bound_crs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ *proj_crs_create_bound_crs(PJ_CONTEXT *ctx, const PJ *base_crs, const PJ *hub_crs, const PJ *transformation)
     * }
     */
    public static FunctionDescriptor proj_crs_create_bound_crs$descriptor() {
        return proj_crs_create_bound_crs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ *proj_crs_create_bound_crs(PJ_CONTEXT *ctx, const PJ *base_crs, const PJ *hub_crs, const PJ *transformation)
     * }
     */
    public static MethodHandle proj_crs_create_bound_crs$handle() {
        return proj_crs_create_bound_crs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ *proj_crs_create_bound_crs(PJ_CONTEXT *ctx, const PJ *base_crs, const PJ *hub_crs, const PJ *transformation)
     * }
     */
    public static MemorySegment proj_crs_create_bound_crs$address() {
        return proj_crs_create_bound_crs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ *proj_crs_create_bound_crs(PJ_CONTEXT *ctx, const PJ *base_crs, const PJ *hub_crs, const PJ *transformation)
     * }
     */
    public static MemorySegment proj_crs_create_bound_crs(MemorySegment ctx, MemorySegment base_crs, MemorySegment hub_crs, MemorySegment transformation) {
        var mh$ = proj_crs_create_bound_crs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_crs_create_bound_crs", ctx, base_crs, hub_crs, transformation);
            }
            return (MemorySegment)mh$.invokeExact(ctx, base_crs, hub_crs, transformation);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_crs_create_bound_crs_to_WGS84 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_crs_create_bound_crs_to_WGS84");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ *proj_crs_create_bound_crs_to_WGS84(PJ_CONTEXT *ctx, const PJ *crs, const char *const *options)
     * }
     */
    public static FunctionDescriptor proj_crs_create_bound_crs_to_WGS84$descriptor() {
        return proj_crs_create_bound_crs_to_WGS84.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ *proj_crs_create_bound_crs_to_WGS84(PJ_CONTEXT *ctx, const PJ *crs, const char *const *options)
     * }
     */
    public static MethodHandle proj_crs_create_bound_crs_to_WGS84$handle() {
        return proj_crs_create_bound_crs_to_WGS84.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ *proj_crs_create_bound_crs_to_WGS84(PJ_CONTEXT *ctx, const PJ *crs, const char *const *options)
     * }
     */
    public static MemorySegment proj_crs_create_bound_crs_to_WGS84$address() {
        return proj_crs_create_bound_crs_to_WGS84.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ *proj_crs_create_bound_crs_to_WGS84(PJ_CONTEXT *ctx, const PJ *crs, const char *const *options)
     * }
     */
    public static MemorySegment proj_crs_create_bound_crs_to_WGS84(MemorySegment ctx, MemorySegment crs, MemorySegment options) {
        var mh$ = proj_crs_create_bound_crs_to_WGS84.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_crs_create_bound_crs_to_WGS84", ctx, crs, options);
            }
            return (MemorySegment)mh$.invokeExact(ctx, crs, options);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_crs_create_bound_vertical_crs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_crs_create_bound_vertical_crs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ *proj_crs_create_bound_vertical_crs(PJ_CONTEXT *ctx, const PJ *vert_crs, const PJ *hub_geographic_3D_crs, const char *grid_name)
     * }
     */
    public static FunctionDescriptor proj_crs_create_bound_vertical_crs$descriptor() {
        return proj_crs_create_bound_vertical_crs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ *proj_crs_create_bound_vertical_crs(PJ_CONTEXT *ctx, const PJ *vert_crs, const PJ *hub_geographic_3D_crs, const char *grid_name)
     * }
     */
    public static MethodHandle proj_crs_create_bound_vertical_crs$handle() {
        return proj_crs_create_bound_vertical_crs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ *proj_crs_create_bound_vertical_crs(PJ_CONTEXT *ctx, const PJ *vert_crs, const PJ *hub_geographic_3D_crs, const char *grid_name)
     * }
     */
    public static MemorySegment proj_crs_create_bound_vertical_crs$address() {
        return proj_crs_create_bound_vertical_crs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ *proj_crs_create_bound_vertical_crs(PJ_CONTEXT *ctx, const PJ *vert_crs, const PJ *hub_geographic_3D_crs, const char *grid_name)
     * }
     */
    public static MemorySegment proj_crs_create_bound_vertical_crs(MemorySegment ctx, MemorySegment vert_crs, MemorySegment hub_geographic_3D_crs, MemorySegment grid_name) {
        var mh$ = proj_crs_create_bound_vertical_crs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_crs_create_bound_vertical_crs", ctx, vert_crs, hub_geographic_3D_crs, grid_name);
            }
            return (MemorySegment)mh$.invokeExact(ctx, vert_crs, hub_geographic_3D_crs, grid_name);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_create_conversion_utm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_INT,
            proj_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_create_conversion_utm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_utm(PJ_CONTEXT *ctx, int zone, int north)
     * }
     */
    public static FunctionDescriptor proj_create_conversion_utm$descriptor() {
        return proj_create_conversion_utm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_utm(PJ_CONTEXT *ctx, int zone, int north)
     * }
     */
    public static MethodHandle proj_create_conversion_utm$handle() {
        return proj_create_conversion_utm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_utm(PJ_CONTEXT *ctx, int zone, int north)
     * }
     */
    public static MemorySegment proj_create_conversion_utm$address() {
        return proj_create_conversion_utm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ *proj_create_conversion_utm(PJ_CONTEXT *ctx, int zone, int north)
     * }
     */
    public static MemorySegment proj_create_conversion_utm(MemorySegment ctx, int zone, int north) {
        var mh$ = proj_create_conversion_utm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_create_conversion_utm", ctx, zone, north);
            }
            return (MemorySegment)mh$.invokeExact(ctx, zone, north);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_create_conversion_transverse_mercator {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_create_conversion_transverse_mercator");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_transverse_mercator(PJ_CONTEXT *ctx, double center_lat, double center_long, double scale, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static FunctionDescriptor proj_create_conversion_transverse_mercator$descriptor() {
        return proj_create_conversion_transverse_mercator.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_transverse_mercator(PJ_CONTEXT *ctx, double center_lat, double center_long, double scale, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MethodHandle proj_create_conversion_transverse_mercator$handle() {
        return proj_create_conversion_transverse_mercator.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_transverse_mercator(PJ_CONTEXT *ctx, double center_lat, double center_long, double scale, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MemorySegment proj_create_conversion_transverse_mercator$address() {
        return proj_create_conversion_transverse_mercator.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ *proj_create_conversion_transverse_mercator(PJ_CONTEXT *ctx, double center_lat, double center_long, double scale, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MemorySegment proj_create_conversion_transverse_mercator(MemorySegment ctx, double center_lat, double center_long, double scale, double false_easting, double false_northing, MemorySegment ang_unit_name, double ang_unit_conv_factor, MemorySegment linear_unit_name, double linear_unit_conv_factor) {
        var mh$ = proj_create_conversion_transverse_mercator.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_create_conversion_transverse_mercator", ctx, center_lat, center_long, scale, false_easting, false_northing, ang_unit_name, ang_unit_conv_factor, linear_unit_name, linear_unit_conv_factor);
            }
            return (MemorySegment)mh$.invokeExact(ctx, center_lat, center_long, scale, false_easting, false_northing, ang_unit_name, ang_unit_conv_factor, linear_unit_name, linear_unit_conv_factor);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_create_conversion_gauss_schreiber_transverse_mercator {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_create_conversion_gauss_schreiber_transverse_mercator");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_gauss_schreiber_transverse_mercator(PJ_CONTEXT *ctx, double center_lat, double center_long, double scale, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static FunctionDescriptor proj_create_conversion_gauss_schreiber_transverse_mercator$descriptor() {
        return proj_create_conversion_gauss_schreiber_transverse_mercator.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_gauss_schreiber_transverse_mercator(PJ_CONTEXT *ctx, double center_lat, double center_long, double scale, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MethodHandle proj_create_conversion_gauss_schreiber_transverse_mercator$handle() {
        return proj_create_conversion_gauss_schreiber_transverse_mercator.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_gauss_schreiber_transverse_mercator(PJ_CONTEXT *ctx, double center_lat, double center_long, double scale, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MemorySegment proj_create_conversion_gauss_schreiber_transverse_mercator$address() {
        return proj_create_conversion_gauss_schreiber_transverse_mercator.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ *proj_create_conversion_gauss_schreiber_transverse_mercator(PJ_CONTEXT *ctx, double center_lat, double center_long, double scale, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MemorySegment proj_create_conversion_gauss_schreiber_transverse_mercator(MemorySegment ctx, double center_lat, double center_long, double scale, double false_easting, double false_northing, MemorySegment ang_unit_name, double ang_unit_conv_factor, MemorySegment linear_unit_name, double linear_unit_conv_factor) {
        var mh$ = proj_create_conversion_gauss_schreiber_transverse_mercator.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_create_conversion_gauss_schreiber_transverse_mercator", ctx, center_lat, center_long, scale, false_easting, false_northing, ang_unit_name, ang_unit_conv_factor, linear_unit_name, linear_unit_conv_factor);
            }
            return (MemorySegment)mh$.invokeExact(ctx, center_lat, center_long, scale, false_easting, false_northing, ang_unit_name, ang_unit_conv_factor, linear_unit_name, linear_unit_conv_factor);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_create_conversion_transverse_mercator_south_oriented {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_create_conversion_transverse_mercator_south_oriented");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_transverse_mercator_south_oriented(PJ_CONTEXT *ctx, double center_lat, double center_long, double scale, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static FunctionDescriptor proj_create_conversion_transverse_mercator_south_oriented$descriptor() {
        return proj_create_conversion_transverse_mercator_south_oriented.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_transverse_mercator_south_oriented(PJ_CONTEXT *ctx, double center_lat, double center_long, double scale, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MethodHandle proj_create_conversion_transverse_mercator_south_oriented$handle() {
        return proj_create_conversion_transverse_mercator_south_oriented.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_transverse_mercator_south_oriented(PJ_CONTEXT *ctx, double center_lat, double center_long, double scale, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MemorySegment proj_create_conversion_transverse_mercator_south_oriented$address() {
        return proj_create_conversion_transverse_mercator_south_oriented.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ *proj_create_conversion_transverse_mercator_south_oriented(PJ_CONTEXT *ctx, double center_lat, double center_long, double scale, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MemorySegment proj_create_conversion_transverse_mercator_south_oriented(MemorySegment ctx, double center_lat, double center_long, double scale, double false_easting, double false_northing, MemorySegment ang_unit_name, double ang_unit_conv_factor, MemorySegment linear_unit_name, double linear_unit_conv_factor) {
        var mh$ = proj_create_conversion_transverse_mercator_south_oriented.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_create_conversion_transverse_mercator_south_oriented", ctx, center_lat, center_long, scale, false_easting, false_northing, ang_unit_name, ang_unit_conv_factor, linear_unit_name, linear_unit_conv_factor);
            }
            return (MemorySegment)mh$.invokeExact(ctx, center_lat, center_long, scale, false_easting, false_northing, ang_unit_name, ang_unit_conv_factor, linear_unit_name, linear_unit_conv_factor);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_create_conversion_two_point_equidistant {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_create_conversion_two_point_equidistant");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_two_point_equidistant(PJ_CONTEXT *ctx, double latitude_first_point, double longitude_first_point, double latitude_second_point, double longitude_secon_point, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static FunctionDescriptor proj_create_conversion_two_point_equidistant$descriptor() {
        return proj_create_conversion_two_point_equidistant.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_two_point_equidistant(PJ_CONTEXT *ctx, double latitude_first_point, double longitude_first_point, double latitude_second_point, double longitude_secon_point, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MethodHandle proj_create_conversion_two_point_equidistant$handle() {
        return proj_create_conversion_two_point_equidistant.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_two_point_equidistant(PJ_CONTEXT *ctx, double latitude_first_point, double longitude_first_point, double latitude_second_point, double longitude_secon_point, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MemorySegment proj_create_conversion_two_point_equidistant$address() {
        return proj_create_conversion_two_point_equidistant.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ *proj_create_conversion_two_point_equidistant(PJ_CONTEXT *ctx, double latitude_first_point, double longitude_first_point, double latitude_second_point, double longitude_secon_point, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MemorySegment proj_create_conversion_two_point_equidistant(MemorySegment ctx, double latitude_first_point, double longitude_first_point, double latitude_second_point, double longitude_secon_point, double false_easting, double false_northing, MemorySegment ang_unit_name, double ang_unit_conv_factor, MemorySegment linear_unit_name, double linear_unit_conv_factor) {
        var mh$ = proj_create_conversion_two_point_equidistant.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_create_conversion_two_point_equidistant", ctx, latitude_first_point, longitude_first_point, latitude_second_point, longitude_secon_point, false_easting, false_northing, ang_unit_name, ang_unit_conv_factor, linear_unit_name, linear_unit_conv_factor);
            }
            return (MemorySegment)mh$.invokeExact(ctx, latitude_first_point, longitude_first_point, latitude_second_point, longitude_secon_point, false_easting, false_northing, ang_unit_name, ang_unit_conv_factor, linear_unit_name, linear_unit_conv_factor);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_create_conversion_tunisia_mapping_grid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_create_conversion_tunisia_mapping_grid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_tunisia_mapping_grid(PJ_CONTEXT *ctx, double center_lat, double center_long, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static FunctionDescriptor proj_create_conversion_tunisia_mapping_grid$descriptor() {
        return proj_create_conversion_tunisia_mapping_grid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_tunisia_mapping_grid(PJ_CONTEXT *ctx, double center_lat, double center_long, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MethodHandle proj_create_conversion_tunisia_mapping_grid$handle() {
        return proj_create_conversion_tunisia_mapping_grid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_tunisia_mapping_grid(PJ_CONTEXT *ctx, double center_lat, double center_long, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MemorySegment proj_create_conversion_tunisia_mapping_grid$address() {
        return proj_create_conversion_tunisia_mapping_grid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ *proj_create_conversion_tunisia_mapping_grid(PJ_CONTEXT *ctx, double center_lat, double center_long, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MemorySegment proj_create_conversion_tunisia_mapping_grid(MemorySegment ctx, double center_lat, double center_long, double false_easting, double false_northing, MemorySegment ang_unit_name, double ang_unit_conv_factor, MemorySegment linear_unit_name, double linear_unit_conv_factor) {
        var mh$ = proj_create_conversion_tunisia_mapping_grid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_create_conversion_tunisia_mapping_grid", ctx, center_lat, center_long, false_easting, false_northing, ang_unit_name, ang_unit_conv_factor, linear_unit_name, linear_unit_conv_factor);
            }
            return (MemorySegment)mh$.invokeExact(ctx, center_lat, center_long, false_easting, false_northing, ang_unit_name, ang_unit_conv_factor, linear_unit_name, linear_unit_conv_factor);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_create_conversion_tunisia_mining_grid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_create_conversion_tunisia_mining_grid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_tunisia_mining_grid(PJ_CONTEXT *ctx, double center_lat, double center_long, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static FunctionDescriptor proj_create_conversion_tunisia_mining_grid$descriptor() {
        return proj_create_conversion_tunisia_mining_grid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_tunisia_mining_grid(PJ_CONTEXT *ctx, double center_lat, double center_long, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MethodHandle proj_create_conversion_tunisia_mining_grid$handle() {
        return proj_create_conversion_tunisia_mining_grid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_tunisia_mining_grid(PJ_CONTEXT *ctx, double center_lat, double center_long, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MemorySegment proj_create_conversion_tunisia_mining_grid$address() {
        return proj_create_conversion_tunisia_mining_grid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ *proj_create_conversion_tunisia_mining_grid(PJ_CONTEXT *ctx, double center_lat, double center_long, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MemorySegment proj_create_conversion_tunisia_mining_grid(MemorySegment ctx, double center_lat, double center_long, double false_easting, double false_northing, MemorySegment ang_unit_name, double ang_unit_conv_factor, MemorySegment linear_unit_name, double linear_unit_conv_factor) {
        var mh$ = proj_create_conversion_tunisia_mining_grid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_create_conversion_tunisia_mining_grid", ctx, center_lat, center_long, false_easting, false_northing, ang_unit_name, ang_unit_conv_factor, linear_unit_name, linear_unit_conv_factor);
            }
            return (MemorySegment)mh$.invokeExact(ctx, center_lat, center_long, false_easting, false_northing, ang_unit_name, ang_unit_conv_factor, linear_unit_name, linear_unit_conv_factor);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_create_conversion_albers_equal_area {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_create_conversion_albers_equal_area");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_albers_equal_area(PJ_CONTEXT *ctx, double latitude_false_origin, double longitude_false_origin, double latitude_first_parallel, double latitude_second_parallel, double easting_false_origin, double northing_false_origin, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static FunctionDescriptor proj_create_conversion_albers_equal_area$descriptor() {
        return proj_create_conversion_albers_equal_area.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_albers_equal_area(PJ_CONTEXT *ctx, double latitude_false_origin, double longitude_false_origin, double latitude_first_parallel, double latitude_second_parallel, double easting_false_origin, double northing_false_origin, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MethodHandle proj_create_conversion_albers_equal_area$handle() {
        return proj_create_conversion_albers_equal_area.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_albers_equal_area(PJ_CONTEXT *ctx, double latitude_false_origin, double longitude_false_origin, double latitude_first_parallel, double latitude_second_parallel, double easting_false_origin, double northing_false_origin, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MemorySegment proj_create_conversion_albers_equal_area$address() {
        return proj_create_conversion_albers_equal_area.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ *proj_create_conversion_albers_equal_area(PJ_CONTEXT *ctx, double latitude_false_origin, double longitude_false_origin, double latitude_first_parallel, double latitude_second_parallel, double easting_false_origin, double northing_false_origin, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MemorySegment proj_create_conversion_albers_equal_area(MemorySegment ctx, double latitude_false_origin, double longitude_false_origin, double latitude_first_parallel, double latitude_second_parallel, double easting_false_origin, double northing_false_origin, MemorySegment ang_unit_name, double ang_unit_conv_factor, MemorySegment linear_unit_name, double linear_unit_conv_factor) {
        var mh$ = proj_create_conversion_albers_equal_area.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_create_conversion_albers_equal_area", ctx, latitude_false_origin, longitude_false_origin, latitude_first_parallel, latitude_second_parallel, easting_false_origin, northing_false_origin, ang_unit_name, ang_unit_conv_factor, linear_unit_name, linear_unit_conv_factor);
            }
            return (MemorySegment)mh$.invokeExact(ctx, latitude_false_origin, longitude_false_origin, latitude_first_parallel, latitude_second_parallel, easting_false_origin, northing_false_origin, ang_unit_name, ang_unit_conv_factor, linear_unit_name, linear_unit_conv_factor);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_create_conversion_lambert_conic_conformal_1sp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_create_conversion_lambert_conic_conformal_1sp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_lambert_conic_conformal_1sp(PJ_CONTEXT *ctx, double center_lat, double center_long, double scale, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static FunctionDescriptor proj_create_conversion_lambert_conic_conformal_1sp$descriptor() {
        return proj_create_conversion_lambert_conic_conformal_1sp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_lambert_conic_conformal_1sp(PJ_CONTEXT *ctx, double center_lat, double center_long, double scale, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MethodHandle proj_create_conversion_lambert_conic_conformal_1sp$handle() {
        return proj_create_conversion_lambert_conic_conformal_1sp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_lambert_conic_conformal_1sp(PJ_CONTEXT *ctx, double center_lat, double center_long, double scale, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MemorySegment proj_create_conversion_lambert_conic_conformal_1sp$address() {
        return proj_create_conversion_lambert_conic_conformal_1sp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ *proj_create_conversion_lambert_conic_conformal_1sp(PJ_CONTEXT *ctx, double center_lat, double center_long, double scale, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MemorySegment proj_create_conversion_lambert_conic_conformal_1sp(MemorySegment ctx, double center_lat, double center_long, double scale, double false_easting, double false_northing, MemorySegment ang_unit_name, double ang_unit_conv_factor, MemorySegment linear_unit_name, double linear_unit_conv_factor) {
        var mh$ = proj_create_conversion_lambert_conic_conformal_1sp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_create_conversion_lambert_conic_conformal_1sp", ctx, center_lat, center_long, scale, false_easting, false_northing, ang_unit_name, ang_unit_conv_factor, linear_unit_name, linear_unit_conv_factor);
            }
            return (MemorySegment)mh$.invokeExact(ctx, center_lat, center_long, scale, false_easting, false_northing, ang_unit_name, ang_unit_conv_factor, linear_unit_name, linear_unit_conv_factor);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_create_conversion_lambert_conic_conformal_1sp_variant_b {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_create_conversion_lambert_conic_conformal_1sp_variant_b");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_lambert_conic_conformal_1sp_variant_b(PJ_CONTEXT *ctx, double latitude_nat_origin, double scale, double latitude_false_origin, double longitude_false_origin, double easting_false_origin, double northing_false_origin, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static FunctionDescriptor proj_create_conversion_lambert_conic_conformal_1sp_variant_b$descriptor() {
        return proj_create_conversion_lambert_conic_conformal_1sp_variant_b.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_lambert_conic_conformal_1sp_variant_b(PJ_CONTEXT *ctx, double latitude_nat_origin, double scale, double latitude_false_origin, double longitude_false_origin, double easting_false_origin, double northing_false_origin, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MethodHandle proj_create_conversion_lambert_conic_conformal_1sp_variant_b$handle() {
        return proj_create_conversion_lambert_conic_conformal_1sp_variant_b.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_lambert_conic_conformal_1sp_variant_b(PJ_CONTEXT *ctx, double latitude_nat_origin, double scale, double latitude_false_origin, double longitude_false_origin, double easting_false_origin, double northing_false_origin, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MemorySegment proj_create_conversion_lambert_conic_conformal_1sp_variant_b$address() {
        return proj_create_conversion_lambert_conic_conformal_1sp_variant_b.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ *proj_create_conversion_lambert_conic_conformal_1sp_variant_b(PJ_CONTEXT *ctx, double latitude_nat_origin, double scale, double latitude_false_origin, double longitude_false_origin, double easting_false_origin, double northing_false_origin, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MemorySegment proj_create_conversion_lambert_conic_conformal_1sp_variant_b(MemorySegment ctx, double latitude_nat_origin, double scale, double latitude_false_origin, double longitude_false_origin, double easting_false_origin, double northing_false_origin, MemorySegment ang_unit_name, double ang_unit_conv_factor, MemorySegment linear_unit_name, double linear_unit_conv_factor) {
        var mh$ = proj_create_conversion_lambert_conic_conformal_1sp_variant_b.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_create_conversion_lambert_conic_conformal_1sp_variant_b", ctx, latitude_nat_origin, scale, latitude_false_origin, longitude_false_origin, easting_false_origin, northing_false_origin, ang_unit_name, ang_unit_conv_factor, linear_unit_name, linear_unit_conv_factor);
            }
            return (MemorySegment)mh$.invokeExact(ctx, latitude_nat_origin, scale, latitude_false_origin, longitude_false_origin, easting_false_origin, northing_false_origin, ang_unit_name, ang_unit_conv_factor, linear_unit_name, linear_unit_conv_factor);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_create_conversion_lambert_conic_conformal_2sp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_create_conversion_lambert_conic_conformal_2sp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_lambert_conic_conformal_2sp(PJ_CONTEXT *ctx, double latitude_false_origin, double longitude_false_origin, double latitude_first_parallel, double latitude_second_parallel, double easting_false_origin, double northing_false_origin, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static FunctionDescriptor proj_create_conversion_lambert_conic_conformal_2sp$descriptor() {
        return proj_create_conversion_lambert_conic_conformal_2sp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_lambert_conic_conformal_2sp(PJ_CONTEXT *ctx, double latitude_false_origin, double longitude_false_origin, double latitude_first_parallel, double latitude_second_parallel, double easting_false_origin, double northing_false_origin, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MethodHandle proj_create_conversion_lambert_conic_conformal_2sp$handle() {
        return proj_create_conversion_lambert_conic_conformal_2sp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_lambert_conic_conformal_2sp(PJ_CONTEXT *ctx, double latitude_false_origin, double longitude_false_origin, double latitude_first_parallel, double latitude_second_parallel, double easting_false_origin, double northing_false_origin, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MemorySegment proj_create_conversion_lambert_conic_conformal_2sp$address() {
        return proj_create_conversion_lambert_conic_conformal_2sp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ *proj_create_conversion_lambert_conic_conformal_2sp(PJ_CONTEXT *ctx, double latitude_false_origin, double longitude_false_origin, double latitude_first_parallel, double latitude_second_parallel, double easting_false_origin, double northing_false_origin, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MemorySegment proj_create_conversion_lambert_conic_conformal_2sp(MemorySegment ctx, double latitude_false_origin, double longitude_false_origin, double latitude_first_parallel, double latitude_second_parallel, double easting_false_origin, double northing_false_origin, MemorySegment ang_unit_name, double ang_unit_conv_factor, MemorySegment linear_unit_name, double linear_unit_conv_factor) {
        var mh$ = proj_create_conversion_lambert_conic_conformal_2sp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_create_conversion_lambert_conic_conformal_2sp", ctx, latitude_false_origin, longitude_false_origin, latitude_first_parallel, latitude_second_parallel, easting_false_origin, northing_false_origin, ang_unit_name, ang_unit_conv_factor, linear_unit_name, linear_unit_conv_factor);
            }
            return (MemorySegment)mh$.invokeExact(ctx, latitude_false_origin, longitude_false_origin, latitude_first_parallel, latitude_second_parallel, easting_false_origin, northing_false_origin, ang_unit_name, ang_unit_conv_factor, linear_unit_name, linear_unit_conv_factor);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_create_conversion_lambert_conic_conformal_2sp_michigan {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_create_conversion_lambert_conic_conformal_2sp_michigan");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_lambert_conic_conformal_2sp_michigan(PJ_CONTEXT *ctx, double latitude_false_origin, double longitude_false_origin, double latitude_first_parallel, double latitude_second_parallel, double easting_false_origin, double northing_false_origin, double ellipsoid_scaling_factor, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static FunctionDescriptor proj_create_conversion_lambert_conic_conformal_2sp_michigan$descriptor() {
        return proj_create_conversion_lambert_conic_conformal_2sp_michigan.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_lambert_conic_conformal_2sp_michigan(PJ_CONTEXT *ctx, double latitude_false_origin, double longitude_false_origin, double latitude_first_parallel, double latitude_second_parallel, double easting_false_origin, double northing_false_origin, double ellipsoid_scaling_factor, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MethodHandle proj_create_conversion_lambert_conic_conformal_2sp_michigan$handle() {
        return proj_create_conversion_lambert_conic_conformal_2sp_michigan.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_lambert_conic_conformal_2sp_michigan(PJ_CONTEXT *ctx, double latitude_false_origin, double longitude_false_origin, double latitude_first_parallel, double latitude_second_parallel, double easting_false_origin, double northing_false_origin, double ellipsoid_scaling_factor, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MemorySegment proj_create_conversion_lambert_conic_conformal_2sp_michigan$address() {
        return proj_create_conversion_lambert_conic_conformal_2sp_michigan.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ *proj_create_conversion_lambert_conic_conformal_2sp_michigan(PJ_CONTEXT *ctx, double latitude_false_origin, double longitude_false_origin, double latitude_first_parallel, double latitude_second_parallel, double easting_false_origin, double northing_false_origin, double ellipsoid_scaling_factor, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MemorySegment proj_create_conversion_lambert_conic_conformal_2sp_michigan(MemorySegment ctx, double latitude_false_origin, double longitude_false_origin, double latitude_first_parallel, double latitude_second_parallel, double easting_false_origin, double northing_false_origin, double ellipsoid_scaling_factor, MemorySegment ang_unit_name, double ang_unit_conv_factor, MemorySegment linear_unit_name, double linear_unit_conv_factor) {
        var mh$ = proj_create_conversion_lambert_conic_conformal_2sp_michigan.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_create_conversion_lambert_conic_conformal_2sp_michigan", ctx, latitude_false_origin, longitude_false_origin, latitude_first_parallel, latitude_second_parallel, easting_false_origin, northing_false_origin, ellipsoid_scaling_factor, ang_unit_name, ang_unit_conv_factor, linear_unit_name, linear_unit_conv_factor);
            }
            return (MemorySegment)mh$.invokeExact(ctx, latitude_false_origin, longitude_false_origin, latitude_first_parallel, latitude_second_parallel, easting_false_origin, northing_false_origin, ellipsoid_scaling_factor, ang_unit_name, ang_unit_conv_factor, linear_unit_name, linear_unit_conv_factor);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_create_conversion_lambert_conic_conformal_2sp_belgium {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_create_conversion_lambert_conic_conformal_2sp_belgium");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_lambert_conic_conformal_2sp_belgium(PJ_CONTEXT *ctx, double latitude_false_origin, double longitude_false_origin, double latitude_first_parallel, double latitude_second_parallel, double easting_false_origin, double northing_false_origin, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static FunctionDescriptor proj_create_conversion_lambert_conic_conformal_2sp_belgium$descriptor() {
        return proj_create_conversion_lambert_conic_conformal_2sp_belgium.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_lambert_conic_conformal_2sp_belgium(PJ_CONTEXT *ctx, double latitude_false_origin, double longitude_false_origin, double latitude_first_parallel, double latitude_second_parallel, double easting_false_origin, double northing_false_origin, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MethodHandle proj_create_conversion_lambert_conic_conformal_2sp_belgium$handle() {
        return proj_create_conversion_lambert_conic_conformal_2sp_belgium.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_lambert_conic_conformal_2sp_belgium(PJ_CONTEXT *ctx, double latitude_false_origin, double longitude_false_origin, double latitude_first_parallel, double latitude_second_parallel, double easting_false_origin, double northing_false_origin, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MemorySegment proj_create_conversion_lambert_conic_conformal_2sp_belgium$address() {
        return proj_create_conversion_lambert_conic_conformal_2sp_belgium.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ *proj_create_conversion_lambert_conic_conformal_2sp_belgium(PJ_CONTEXT *ctx, double latitude_false_origin, double longitude_false_origin, double latitude_first_parallel, double latitude_second_parallel, double easting_false_origin, double northing_false_origin, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MemorySegment proj_create_conversion_lambert_conic_conformal_2sp_belgium(MemorySegment ctx, double latitude_false_origin, double longitude_false_origin, double latitude_first_parallel, double latitude_second_parallel, double easting_false_origin, double northing_false_origin, MemorySegment ang_unit_name, double ang_unit_conv_factor, MemorySegment linear_unit_name, double linear_unit_conv_factor) {
        var mh$ = proj_create_conversion_lambert_conic_conformal_2sp_belgium.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_create_conversion_lambert_conic_conformal_2sp_belgium", ctx, latitude_false_origin, longitude_false_origin, latitude_first_parallel, latitude_second_parallel, easting_false_origin, northing_false_origin, ang_unit_name, ang_unit_conv_factor, linear_unit_name, linear_unit_conv_factor);
            }
            return (MemorySegment)mh$.invokeExact(ctx, latitude_false_origin, longitude_false_origin, latitude_first_parallel, latitude_second_parallel, easting_false_origin, northing_false_origin, ang_unit_name, ang_unit_conv_factor, linear_unit_name, linear_unit_conv_factor);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_create_conversion_azimuthal_equidistant {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_create_conversion_azimuthal_equidistant");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_azimuthal_equidistant(PJ_CONTEXT *ctx, double latitude_nat_origin, double longitude_nat_origin, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static FunctionDescriptor proj_create_conversion_azimuthal_equidistant$descriptor() {
        return proj_create_conversion_azimuthal_equidistant.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_azimuthal_equidistant(PJ_CONTEXT *ctx, double latitude_nat_origin, double longitude_nat_origin, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MethodHandle proj_create_conversion_azimuthal_equidistant$handle() {
        return proj_create_conversion_azimuthal_equidistant.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_azimuthal_equidistant(PJ_CONTEXT *ctx, double latitude_nat_origin, double longitude_nat_origin, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MemorySegment proj_create_conversion_azimuthal_equidistant$address() {
        return proj_create_conversion_azimuthal_equidistant.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ *proj_create_conversion_azimuthal_equidistant(PJ_CONTEXT *ctx, double latitude_nat_origin, double longitude_nat_origin, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MemorySegment proj_create_conversion_azimuthal_equidistant(MemorySegment ctx, double latitude_nat_origin, double longitude_nat_origin, double false_easting, double false_northing, MemorySegment ang_unit_name, double ang_unit_conv_factor, MemorySegment linear_unit_name, double linear_unit_conv_factor) {
        var mh$ = proj_create_conversion_azimuthal_equidistant.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_create_conversion_azimuthal_equidistant", ctx, latitude_nat_origin, longitude_nat_origin, false_easting, false_northing, ang_unit_name, ang_unit_conv_factor, linear_unit_name, linear_unit_conv_factor);
            }
            return (MemorySegment)mh$.invokeExact(ctx, latitude_nat_origin, longitude_nat_origin, false_easting, false_northing, ang_unit_name, ang_unit_conv_factor, linear_unit_name, linear_unit_conv_factor);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_create_conversion_guam_projection {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_create_conversion_guam_projection");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_guam_projection(PJ_CONTEXT *ctx, double latitude_nat_origin, double longitude_nat_origin, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static FunctionDescriptor proj_create_conversion_guam_projection$descriptor() {
        return proj_create_conversion_guam_projection.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_guam_projection(PJ_CONTEXT *ctx, double latitude_nat_origin, double longitude_nat_origin, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MethodHandle proj_create_conversion_guam_projection$handle() {
        return proj_create_conversion_guam_projection.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_guam_projection(PJ_CONTEXT *ctx, double latitude_nat_origin, double longitude_nat_origin, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MemorySegment proj_create_conversion_guam_projection$address() {
        return proj_create_conversion_guam_projection.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ *proj_create_conversion_guam_projection(PJ_CONTEXT *ctx, double latitude_nat_origin, double longitude_nat_origin, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MemorySegment proj_create_conversion_guam_projection(MemorySegment ctx, double latitude_nat_origin, double longitude_nat_origin, double false_easting, double false_northing, MemorySegment ang_unit_name, double ang_unit_conv_factor, MemorySegment linear_unit_name, double linear_unit_conv_factor) {
        var mh$ = proj_create_conversion_guam_projection.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_create_conversion_guam_projection", ctx, latitude_nat_origin, longitude_nat_origin, false_easting, false_northing, ang_unit_name, ang_unit_conv_factor, linear_unit_name, linear_unit_conv_factor);
            }
            return (MemorySegment)mh$.invokeExact(ctx, latitude_nat_origin, longitude_nat_origin, false_easting, false_northing, ang_unit_name, ang_unit_conv_factor, linear_unit_name, linear_unit_conv_factor);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_create_conversion_bonne {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_create_conversion_bonne");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_bonne(PJ_CONTEXT *ctx, double latitude_nat_origin, double longitude_nat_origin, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static FunctionDescriptor proj_create_conversion_bonne$descriptor() {
        return proj_create_conversion_bonne.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_bonne(PJ_CONTEXT *ctx, double latitude_nat_origin, double longitude_nat_origin, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MethodHandle proj_create_conversion_bonne$handle() {
        return proj_create_conversion_bonne.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_bonne(PJ_CONTEXT *ctx, double latitude_nat_origin, double longitude_nat_origin, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MemorySegment proj_create_conversion_bonne$address() {
        return proj_create_conversion_bonne.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ *proj_create_conversion_bonne(PJ_CONTEXT *ctx, double latitude_nat_origin, double longitude_nat_origin, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MemorySegment proj_create_conversion_bonne(MemorySegment ctx, double latitude_nat_origin, double longitude_nat_origin, double false_easting, double false_northing, MemorySegment ang_unit_name, double ang_unit_conv_factor, MemorySegment linear_unit_name, double linear_unit_conv_factor) {
        var mh$ = proj_create_conversion_bonne.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_create_conversion_bonne", ctx, latitude_nat_origin, longitude_nat_origin, false_easting, false_northing, ang_unit_name, ang_unit_conv_factor, linear_unit_name, linear_unit_conv_factor);
            }
            return (MemorySegment)mh$.invokeExact(ctx, latitude_nat_origin, longitude_nat_origin, false_easting, false_northing, ang_unit_name, ang_unit_conv_factor, linear_unit_name, linear_unit_conv_factor);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_create_conversion_lambert_cylindrical_equal_area_spherical {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_create_conversion_lambert_cylindrical_equal_area_spherical");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_lambert_cylindrical_equal_area_spherical(PJ_CONTEXT *ctx, double latitude_first_parallel, double longitude_nat_origin, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static FunctionDescriptor proj_create_conversion_lambert_cylindrical_equal_area_spherical$descriptor() {
        return proj_create_conversion_lambert_cylindrical_equal_area_spherical.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_lambert_cylindrical_equal_area_spherical(PJ_CONTEXT *ctx, double latitude_first_parallel, double longitude_nat_origin, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MethodHandle proj_create_conversion_lambert_cylindrical_equal_area_spherical$handle() {
        return proj_create_conversion_lambert_cylindrical_equal_area_spherical.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_lambert_cylindrical_equal_area_spherical(PJ_CONTEXT *ctx, double latitude_first_parallel, double longitude_nat_origin, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MemorySegment proj_create_conversion_lambert_cylindrical_equal_area_spherical$address() {
        return proj_create_conversion_lambert_cylindrical_equal_area_spherical.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ *proj_create_conversion_lambert_cylindrical_equal_area_spherical(PJ_CONTEXT *ctx, double latitude_first_parallel, double longitude_nat_origin, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MemorySegment proj_create_conversion_lambert_cylindrical_equal_area_spherical(MemorySegment ctx, double latitude_first_parallel, double longitude_nat_origin, double false_easting, double false_northing, MemorySegment ang_unit_name, double ang_unit_conv_factor, MemorySegment linear_unit_name, double linear_unit_conv_factor) {
        var mh$ = proj_create_conversion_lambert_cylindrical_equal_area_spherical.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_create_conversion_lambert_cylindrical_equal_area_spherical", ctx, latitude_first_parallel, longitude_nat_origin, false_easting, false_northing, ang_unit_name, ang_unit_conv_factor, linear_unit_name, linear_unit_conv_factor);
            }
            return (MemorySegment)mh$.invokeExact(ctx, latitude_first_parallel, longitude_nat_origin, false_easting, false_northing, ang_unit_name, ang_unit_conv_factor, linear_unit_name, linear_unit_conv_factor);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_create_conversion_lambert_cylindrical_equal_area {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_create_conversion_lambert_cylindrical_equal_area");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_lambert_cylindrical_equal_area(PJ_CONTEXT *ctx, double latitude_first_parallel, double longitude_nat_origin, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static FunctionDescriptor proj_create_conversion_lambert_cylindrical_equal_area$descriptor() {
        return proj_create_conversion_lambert_cylindrical_equal_area.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_lambert_cylindrical_equal_area(PJ_CONTEXT *ctx, double latitude_first_parallel, double longitude_nat_origin, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MethodHandle proj_create_conversion_lambert_cylindrical_equal_area$handle() {
        return proj_create_conversion_lambert_cylindrical_equal_area.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_lambert_cylindrical_equal_area(PJ_CONTEXT *ctx, double latitude_first_parallel, double longitude_nat_origin, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MemorySegment proj_create_conversion_lambert_cylindrical_equal_area$address() {
        return proj_create_conversion_lambert_cylindrical_equal_area.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ *proj_create_conversion_lambert_cylindrical_equal_area(PJ_CONTEXT *ctx, double latitude_first_parallel, double longitude_nat_origin, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MemorySegment proj_create_conversion_lambert_cylindrical_equal_area(MemorySegment ctx, double latitude_first_parallel, double longitude_nat_origin, double false_easting, double false_northing, MemorySegment ang_unit_name, double ang_unit_conv_factor, MemorySegment linear_unit_name, double linear_unit_conv_factor) {
        var mh$ = proj_create_conversion_lambert_cylindrical_equal_area.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_create_conversion_lambert_cylindrical_equal_area", ctx, latitude_first_parallel, longitude_nat_origin, false_easting, false_northing, ang_unit_name, ang_unit_conv_factor, linear_unit_name, linear_unit_conv_factor);
            }
            return (MemorySegment)mh$.invokeExact(ctx, latitude_first_parallel, longitude_nat_origin, false_easting, false_northing, ang_unit_name, ang_unit_conv_factor, linear_unit_name, linear_unit_conv_factor);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_create_conversion_cassini_soldner {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_create_conversion_cassini_soldner");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_cassini_soldner(PJ_CONTEXT *ctx, double center_lat, double center_long, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static FunctionDescriptor proj_create_conversion_cassini_soldner$descriptor() {
        return proj_create_conversion_cassini_soldner.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_cassini_soldner(PJ_CONTEXT *ctx, double center_lat, double center_long, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MethodHandle proj_create_conversion_cassini_soldner$handle() {
        return proj_create_conversion_cassini_soldner.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_cassini_soldner(PJ_CONTEXT *ctx, double center_lat, double center_long, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MemorySegment proj_create_conversion_cassini_soldner$address() {
        return proj_create_conversion_cassini_soldner.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ *proj_create_conversion_cassini_soldner(PJ_CONTEXT *ctx, double center_lat, double center_long, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MemorySegment proj_create_conversion_cassini_soldner(MemorySegment ctx, double center_lat, double center_long, double false_easting, double false_northing, MemorySegment ang_unit_name, double ang_unit_conv_factor, MemorySegment linear_unit_name, double linear_unit_conv_factor) {
        var mh$ = proj_create_conversion_cassini_soldner.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_create_conversion_cassini_soldner", ctx, center_lat, center_long, false_easting, false_northing, ang_unit_name, ang_unit_conv_factor, linear_unit_name, linear_unit_conv_factor);
            }
            return (MemorySegment)mh$.invokeExact(ctx, center_lat, center_long, false_easting, false_northing, ang_unit_name, ang_unit_conv_factor, linear_unit_name, linear_unit_conv_factor);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_create_conversion_equidistant_conic {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_create_conversion_equidistant_conic");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_equidistant_conic(PJ_CONTEXT *ctx, double center_lat, double center_long, double latitude_first_parallel, double latitude_second_parallel, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static FunctionDescriptor proj_create_conversion_equidistant_conic$descriptor() {
        return proj_create_conversion_equidistant_conic.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_equidistant_conic(PJ_CONTEXT *ctx, double center_lat, double center_long, double latitude_first_parallel, double latitude_second_parallel, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MethodHandle proj_create_conversion_equidistant_conic$handle() {
        return proj_create_conversion_equidistant_conic.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_equidistant_conic(PJ_CONTEXT *ctx, double center_lat, double center_long, double latitude_first_parallel, double latitude_second_parallel, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MemorySegment proj_create_conversion_equidistant_conic$address() {
        return proj_create_conversion_equidistant_conic.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ *proj_create_conversion_equidistant_conic(PJ_CONTEXT *ctx, double center_lat, double center_long, double latitude_first_parallel, double latitude_second_parallel, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MemorySegment proj_create_conversion_equidistant_conic(MemorySegment ctx, double center_lat, double center_long, double latitude_first_parallel, double latitude_second_parallel, double false_easting, double false_northing, MemorySegment ang_unit_name, double ang_unit_conv_factor, MemorySegment linear_unit_name, double linear_unit_conv_factor) {
        var mh$ = proj_create_conversion_equidistant_conic.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_create_conversion_equidistant_conic", ctx, center_lat, center_long, latitude_first_parallel, latitude_second_parallel, false_easting, false_northing, ang_unit_name, ang_unit_conv_factor, linear_unit_name, linear_unit_conv_factor);
            }
            return (MemorySegment)mh$.invokeExact(ctx, center_lat, center_long, latitude_first_parallel, latitude_second_parallel, false_easting, false_northing, ang_unit_name, ang_unit_conv_factor, linear_unit_name, linear_unit_conv_factor);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_create_conversion_eckert_i {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_create_conversion_eckert_i");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_eckert_i(PJ_CONTEXT *ctx, double center_long, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static FunctionDescriptor proj_create_conversion_eckert_i$descriptor() {
        return proj_create_conversion_eckert_i.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_eckert_i(PJ_CONTEXT *ctx, double center_long, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MethodHandle proj_create_conversion_eckert_i$handle() {
        return proj_create_conversion_eckert_i.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_eckert_i(PJ_CONTEXT *ctx, double center_long, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MemorySegment proj_create_conversion_eckert_i$address() {
        return proj_create_conversion_eckert_i.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ *proj_create_conversion_eckert_i(PJ_CONTEXT *ctx, double center_long, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MemorySegment proj_create_conversion_eckert_i(MemorySegment ctx, double center_long, double false_easting, double false_northing, MemorySegment ang_unit_name, double ang_unit_conv_factor, MemorySegment linear_unit_name, double linear_unit_conv_factor) {
        var mh$ = proj_create_conversion_eckert_i.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_create_conversion_eckert_i", ctx, center_long, false_easting, false_northing, ang_unit_name, ang_unit_conv_factor, linear_unit_name, linear_unit_conv_factor);
            }
            return (MemorySegment)mh$.invokeExact(ctx, center_long, false_easting, false_northing, ang_unit_name, ang_unit_conv_factor, linear_unit_name, linear_unit_conv_factor);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_create_conversion_eckert_ii {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_create_conversion_eckert_ii");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_eckert_ii(PJ_CONTEXT *ctx, double center_long, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static FunctionDescriptor proj_create_conversion_eckert_ii$descriptor() {
        return proj_create_conversion_eckert_ii.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_eckert_ii(PJ_CONTEXT *ctx, double center_long, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MethodHandle proj_create_conversion_eckert_ii$handle() {
        return proj_create_conversion_eckert_ii.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_eckert_ii(PJ_CONTEXT *ctx, double center_long, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MemorySegment proj_create_conversion_eckert_ii$address() {
        return proj_create_conversion_eckert_ii.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ *proj_create_conversion_eckert_ii(PJ_CONTEXT *ctx, double center_long, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MemorySegment proj_create_conversion_eckert_ii(MemorySegment ctx, double center_long, double false_easting, double false_northing, MemorySegment ang_unit_name, double ang_unit_conv_factor, MemorySegment linear_unit_name, double linear_unit_conv_factor) {
        var mh$ = proj_create_conversion_eckert_ii.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_create_conversion_eckert_ii", ctx, center_long, false_easting, false_northing, ang_unit_name, ang_unit_conv_factor, linear_unit_name, linear_unit_conv_factor);
            }
            return (MemorySegment)mh$.invokeExact(ctx, center_long, false_easting, false_northing, ang_unit_name, ang_unit_conv_factor, linear_unit_name, linear_unit_conv_factor);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_create_conversion_eckert_iii {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_create_conversion_eckert_iii");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_eckert_iii(PJ_CONTEXT *ctx, double center_long, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static FunctionDescriptor proj_create_conversion_eckert_iii$descriptor() {
        return proj_create_conversion_eckert_iii.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_eckert_iii(PJ_CONTEXT *ctx, double center_long, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MethodHandle proj_create_conversion_eckert_iii$handle() {
        return proj_create_conversion_eckert_iii.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_eckert_iii(PJ_CONTEXT *ctx, double center_long, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MemorySegment proj_create_conversion_eckert_iii$address() {
        return proj_create_conversion_eckert_iii.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ *proj_create_conversion_eckert_iii(PJ_CONTEXT *ctx, double center_long, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MemorySegment proj_create_conversion_eckert_iii(MemorySegment ctx, double center_long, double false_easting, double false_northing, MemorySegment ang_unit_name, double ang_unit_conv_factor, MemorySegment linear_unit_name, double linear_unit_conv_factor) {
        var mh$ = proj_create_conversion_eckert_iii.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_create_conversion_eckert_iii", ctx, center_long, false_easting, false_northing, ang_unit_name, ang_unit_conv_factor, linear_unit_name, linear_unit_conv_factor);
            }
            return (MemorySegment)mh$.invokeExact(ctx, center_long, false_easting, false_northing, ang_unit_name, ang_unit_conv_factor, linear_unit_name, linear_unit_conv_factor);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_create_conversion_eckert_iv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_create_conversion_eckert_iv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_eckert_iv(PJ_CONTEXT *ctx, double center_long, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static FunctionDescriptor proj_create_conversion_eckert_iv$descriptor() {
        return proj_create_conversion_eckert_iv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_eckert_iv(PJ_CONTEXT *ctx, double center_long, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MethodHandle proj_create_conversion_eckert_iv$handle() {
        return proj_create_conversion_eckert_iv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_eckert_iv(PJ_CONTEXT *ctx, double center_long, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MemorySegment proj_create_conversion_eckert_iv$address() {
        return proj_create_conversion_eckert_iv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ *proj_create_conversion_eckert_iv(PJ_CONTEXT *ctx, double center_long, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MemorySegment proj_create_conversion_eckert_iv(MemorySegment ctx, double center_long, double false_easting, double false_northing, MemorySegment ang_unit_name, double ang_unit_conv_factor, MemorySegment linear_unit_name, double linear_unit_conv_factor) {
        var mh$ = proj_create_conversion_eckert_iv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_create_conversion_eckert_iv", ctx, center_long, false_easting, false_northing, ang_unit_name, ang_unit_conv_factor, linear_unit_name, linear_unit_conv_factor);
            }
            return (MemorySegment)mh$.invokeExact(ctx, center_long, false_easting, false_northing, ang_unit_name, ang_unit_conv_factor, linear_unit_name, linear_unit_conv_factor);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_create_conversion_eckert_v {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_create_conversion_eckert_v");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_eckert_v(PJ_CONTEXT *ctx, double center_long, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static FunctionDescriptor proj_create_conversion_eckert_v$descriptor() {
        return proj_create_conversion_eckert_v.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_eckert_v(PJ_CONTEXT *ctx, double center_long, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MethodHandle proj_create_conversion_eckert_v$handle() {
        return proj_create_conversion_eckert_v.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_eckert_v(PJ_CONTEXT *ctx, double center_long, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MemorySegment proj_create_conversion_eckert_v$address() {
        return proj_create_conversion_eckert_v.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ *proj_create_conversion_eckert_v(PJ_CONTEXT *ctx, double center_long, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MemorySegment proj_create_conversion_eckert_v(MemorySegment ctx, double center_long, double false_easting, double false_northing, MemorySegment ang_unit_name, double ang_unit_conv_factor, MemorySegment linear_unit_name, double linear_unit_conv_factor) {
        var mh$ = proj_create_conversion_eckert_v.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_create_conversion_eckert_v", ctx, center_long, false_easting, false_northing, ang_unit_name, ang_unit_conv_factor, linear_unit_name, linear_unit_conv_factor);
            }
            return (MemorySegment)mh$.invokeExact(ctx, center_long, false_easting, false_northing, ang_unit_name, ang_unit_conv_factor, linear_unit_name, linear_unit_conv_factor);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_create_conversion_eckert_vi {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_create_conversion_eckert_vi");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_eckert_vi(PJ_CONTEXT *ctx, double center_long, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static FunctionDescriptor proj_create_conversion_eckert_vi$descriptor() {
        return proj_create_conversion_eckert_vi.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_eckert_vi(PJ_CONTEXT *ctx, double center_long, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MethodHandle proj_create_conversion_eckert_vi$handle() {
        return proj_create_conversion_eckert_vi.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_eckert_vi(PJ_CONTEXT *ctx, double center_long, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MemorySegment proj_create_conversion_eckert_vi$address() {
        return proj_create_conversion_eckert_vi.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ *proj_create_conversion_eckert_vi(PJ_CONTEXT *ctx, double center_long, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MemorySegment proj_create_conversion_eckert_vi(MemorySegment ctx, double center_long, double false_easting, double false_northing, MemorySegment ang_unit_name, double ang_unit_conv_factor, MemorySegment linear_unit_name, double linear_unit_conv_factor) {
        var mh$ = proj_create_conversion_eckert_vi.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_create_conversion_eckert_vi", ctx, center_long, false_easting, false_northing, ang_unit_name, ang_unit_conv_factor, linear_unit_name, linear_unit_conv_factor);
            }
            return (MemorySegment)mh$.invokeExact(ctx, center_long, false_easting, false_northing, ang_unit_name, ang_unit_conv_factor, linear_unit_name, linear_unit_conv_factor);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_create_conversion_equidistant_cylindrical {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_create_conversion_equidistant_cylindrical");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_equidistant_cylindrical(PJ_CONTEXT *ctx, double latitude_first_parallel, double longitude_nat_origin, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static FunctionDescriptor proj_create_conversion_equidistant_cylindrical$descriptor() {
        return proj_create_conversion_equidistant_cylindrical.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_equidistant_cylindrical(PJ_CONTEXT *ctx, double latitude_first_parallel, double longitude_nat_origin, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MethodHandle proj_create_conversion_equidistant_cylindrical$handle() {
        return proj_create_conversion_equidistant_cylindrical.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_equidistant_cylindrical(PJ_CONTEXT *ctx, double latitude_first_parallel, double longitude_nat_origin, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MemorySegment proj_create_conversion_equidistant_cylindrical$address() {
        return proj_create_conversion_equidistant_cylindrical.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ *proj_create_conversion_equidistant_cylindrical(PJ_CONTEXT *ctx, double latitude_first_parallel, double longitude_nat_origin, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MemorySegment proj_create_conversion_equidistant_cylindrical(MemorySegment ctx, double latitude_first_parallel, double longitude_nat_origin, double false_easting, double false_northing, MemorySegment ang_unit_name, double ang_unit_conv_factor, MemorySegment linear_unit_name, double linear_unit_conv_factor) {
        var mh$ = proj_create_conversion_equidistant_cylindrical.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_create_conversion_equidistant_cylindrical", ctx, latitude_first_parallel, longitude_nat_origin, false_easting, false_northing, ang_unit_name, ang_unit_conv_factor, linear_unit_name, linear_unit_conv_factor);
            }
            return (MemorySegment)mh$.invokeExact(ctx, latitude_first_parallel, longitude_nat_origin, false_easting, false_northing, ang_unit_name, ang_unit_conv_factor, linear_unit_name, linear_unit_conv_factor);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_create_conversion_equidistant_cylindrical_spherical {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_create_conversion_equidistant_cylindrical_spherical");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_equidistant_cylindrical_spherical(PJ_CONTEXT *ctx, double latitude_first_parallel, double longitude_nat_origin, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static FunctionDescriptor proj_create_conversion_equidistant_cylindrical_spherical$descriptor() {
        return proj_create_conversion_equidistant_cylindrical_spherical.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_equidistant_cylindrical_spherical(PJ_CONTEXT *ctx, double latitude_first_parallel, double longitude_nat_origin, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MethodHandle proj_create_conversion_equidistant_cylindrical_spherical$handle() {
        return proj_create_conversion_equidistant_cylindrical_spherical.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_equidistant_cylindrical_spherical(PJ_CONTEXT *ctx, double latitude_first_parallel, double longitude_nat_origin, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MemorySegment proj_create_conversion_equidistant_cylindrical_spherical$address() {
        return proj_create_conversion_equidistant_cylindrical_spherical.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ *proj_create_conversion_equidistant_cylindrical_spherical(PJ_CONTEXT *ctx, double latitude_first_parallel, double longitude_nat_origin, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MemorySegment proj_create_conversion_equidistant_cylindrical_spherical(MemorySegment ctx, double latitude_first_parallel, double longitude_nat_origin, double false_easting, double false_northing, MemorySegment ang_unit_name, double ang_unit_conv_factor, MemorySegment linear_unit_name, double linear_unit_conv_factor) {
        var mh$ = proj_create_conversion_equidistant_cylindrical_spherical.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_create_conversion_equidistant_cylindrical_spherical", ctx, latitude_first_parallel, longitude_nat_origin, false_easting, false_northing, ang_unit_name, ang_unit_conv_factor, linear_unit_name, linear_unit_conv_factor);
            }
            return (MemorySegment)mh$.invokeExact(ctx, latitude_first_parallel, longitude_nat_origin, false_easting, false_northing, ang_unit_name, ang_unit_conv_factor, linear_unit_name, linear_unit_conv_factor);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_create_conversion_gall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_create_conversion_gall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_gall(PJ_CONTEXT *ctx, double center_long, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static FunctionDescriptor proj_create_conversion_gall$descriptor() {
        return proj_create_conversion_gall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_gall(PJ_CONTEXT *ctx, double center_long, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MethodHandle proj_create_conversion_gall$handle() {
        return proj_create_conversion_gall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_gall(PJ_CONTEXT *ctx, double center_long, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MemorySegment proj_create_conversion_gall$address() {
        return proj_create_conversion_gall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ *proj_create_conversion_gall(PJ_CONTEXT *ctx, double center_long, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MemorySegment proj_create_conversion_gall(MemorySegment ctx, double center_long, double false_easting, double false_northing, MemorySegment ang_unit_name, double ang_unit_conv_factor, MemorySegment linear_unit_name, double linear_unit_conv_factor) {
        var mh$ = proj_create_conversion_gall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_create_conversion_gall", ctx, center_long, false_easting, false_northing, ang_unit_name, ang_unit_conv_factor, linear_unit_name, linear_unit_conv_factor);
            }
            return (MemorySegment)mh$.invokeExact(ctx, center_long, false_easting, false_northing, ang_unit_name, ang_unit_conv_factor, linear_unit_name, linear_unit_conv_factor);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_create_conversion_goode_homolosine {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_create_conversion_goode_homolosine");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_goode_homolosine(PJ_CONTEXT *ctx, double center_long, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static FunctionDescriptor proj_create_conversion_goode_homolosine$descriptor() {
        return proj_create_conversion_goode_homolosine.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_goode_homolosine(PJ_CONTEXT *ctx, double center_long, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MethodHandle proj_create_conversion_goode_homolosine$handle() {
        return proj_create_conversion_goode_homolosine.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_goode_homolosine(PJ_CONTEXT *ctx, double center_long, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MemorySegment proj_create_conversion_goode_homolosine$address() {
        return proj_create_conversion_goode_homolosine.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ *proj_create_conversion_goode_homolosine(PJ_CONTEXT *ctx, double center_long, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MemorySegment proj_create_conversion_goode_homolosine(MemorySegment ctx, double center_long, double false_easting, double false_northing, MemorySegment ang_unit_name, double ang_unit_conv_factor, MemorySegment linear_unit_name, double linear_unit_conv_factor) {
        var mh$ = proj_create_conversion_goode_homolosine.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_create_conversion_goode_homolosine", ctx, center_long, false_easting, false_northing, ang_unit_name, ang_unit_conv_factor, linear_unit_name, linear_unit_conv_factor);
            }
            return (MemorySegment)mh$.invokeExact(ctx, center_long, false_easting, false_northing, ang_unit_name, ang_unit_conv_factor, linear_unit_name, linear_unit_conv_factor);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_create_conversion_interrupted_goode_homolosine {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_create_conversion_interrupted_goode_homolosine");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_interrupted_goode_homolosine(PJ_CONTEXT *ctx, double center_long, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static FunctionDescriptor proj_create_conversion_interrupted_goode_homolosine$descriptor() {
        return proj_create_conversion_interrupted_goode_homolosine.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_interrupted_goode_homolosine(PJ_CONTEXT *ctx, double center_long, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MethodHandle proj_create_conversion_interrupted_goode_homolosine$handle() {
        return proj_create_conversion_interrupted_goode_homolosine.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_interrupted_goode_homolosine(PJ_CONTEXT *ctx, double center_long, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MemorySegment proj_create_conversion_interrupted_goode_homolosine$address() {
        return proj_create_conversion_interrupted_goode_homolosine.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ *proj_create_conversion_interrupted_goode_homolosine(PJ_CONTEXT *ctx, double center_long, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MemorySegment proj_create_conversion_interrupted_goode_homolosine(MemorySegment ctx, double center_long, double false_easting, double false_northing, MemorySegment ang_unit_name, double ang_unit_conv_factor, MemorySegment linear_unit_name, double linear_unit_conv_factor) {
        var mh$ = proj_create_conversion_interrupted_goode_homolosine.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_create_conversion_interrupted_goode_homolosine", ctx, center_long, false_easting, false_northing, ang_unit_name, ang_unit_conv_factor, linear_unit_name, linear_unit_conv_factor);
            }
            return (MemorySegment)mh$.invokeExact(ctx, center_long, false_easting, false_northing, ang_unit_name, ang_unit_conv_factor, linear_unit_name, linear_unit_conv_factor);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_create_conversion_geostationary_satellite_sweep_x {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_create_conversion_geostationary_satellite_sweep_x");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_geostationary_satellite_sweep_x(PJ_CONTEXT *ctx, double center_long, double height, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static FunctionDescriptor proj_create_conversion_geostationary_satellite_sweep_x$descriptor() {
        return proj_create_conversion_geostationary_satellite_sweep_x.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_geostationary_satellite_sweep_x(PJ_CONTEXT *ctx, double center_long, double height, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MethodHandle proj_create_conversion_geostationary_satellite_sweep_x$handle() {
        return proj_create_conversion_geostationary_satellite_sweep_x.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_geostationary_satellite_sweep_x(PJ_CONTEXT *ctx, double center_long, double height, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MemorySegment proj_create_conversion_geostationary_satellite_sweep_x$address() {
        return proj_create_conversion_geostationary_satellite_sweep_x.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ *proj_create_conversion_geostationary_satellite_sweep_x(PJ_CONTEXT *ctx, double center_long, double height, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MemorySegment proj_create_conversion_geostationary_satellite_sweep_x(MemorySegment ctx, double center_long, double height, double false_easting, double false_northing, MemorySegment ang_unit_name, double ang_unit_conv_factor, MemorySegment linear_unit_name, double linear_unit_conv_factor) {
        var mh$ = proj_create_conversion_geostationary_satellite_sweep_x.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_create_conversion_geostationary_satellite_sweep_x", ctx, center_long, height, false_easting, false_northing, ang_unit_name, ang_unit_conv_factor, linear_unit_name, linear_unit_conv_factor);
            }
            return (MemorySegment)mh$.invokeExact(ctx, center_long, height, false_easting, false_northing, ang_unit_name, ang_unit_conv_factor, linear_unit_name, linear_unit_conv_factor);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_create_conversion_geostationary_satellite_sweep_y {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_create_conversion_geostationary_satellite_sweep_y");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_geostationary_satellite_sweep_y(PJ_CONTEXT *ctx, double center_long, double height, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static FunctionDescriptor proj_create_conversion_geostationary_satellite_sweep_y$descriptor() {
        return proj_create_conversion_geostationary_satellite_sweep_y.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_geostationary_satellite_sweep_y(PJ_CONTEXT *ctx, double center_long, double height, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MethodHandle proj_create_conversion_geostationary_satellite_sweep_y$handle() {
        return proj_create_conversion_geostationary_satellite_sweep_y.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_geostationary_satellite_sweep_y(PJ_CONTEXT *ctx, double center_long, double height, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MemorySegment proj_create_conversion_geostationary_satellite_sweep_y$address() {
        return proj_create_conversion_geostationary_satellite_sweep_y.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ *proj_create_conversion_geostationary_satellite_sweep_y(PJ_CONTEXT *ctx, double center_long, double height, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MemorySegment proj_create_conversion_geostationary_satellite_sweep_y(MemorySegment ctx, double center_long, double height, double false_easting, double false_northing, MemorySegment ang_unit_name, double ang_unit_conv_factor, MemorySegment linear_unit_name, double linear_unit_conv_factor) {
        var mh$ = proj_create_conversion_geostationary_satellite_sweep_y.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_create_conversion_geostationary_satellite_sweep_y", ctx, center_long, height, false_easting, false_northing, ang_unit_name, ang_unit_conv_factor, linear_unit_name, linear_unit_conv_factor);
            }
            return (MemorySegment)mh$.invokeExact(ctx, center_long, height, false_easting, false_northing, ang_unit_name, ang_unit_conv_factor, linear_unit_name, linear_unit_conv_factor);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_create_conversion_gnomonic {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_create_conversion_gnomonic");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_gnomonic(PJ_CONTEXT *ctx, double center_lat, double center_long, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static FunctionDescriptor proj_create_conversion_gnomonic$descriptor() {
        return proj_create_conversion_gnomonic.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_gnomonic(PJ_CONTEXT *ctx, double center_lat, double center_long, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MethodHandle proj_create_conversion_gnomonic$handle() {
        return proj_create_conversion_gnomonic.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_gnomonic(PJ_CONTEXT *ctx, double center_lat, double center_long, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MemorySegment proj_create_conversion_gnomonic$address() {
        return proj_create_conversion_gnomonic.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ *proj_create_conversion_gnomonic(PJ_CONTEXT *ctx, double center_lat, double center_long, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MemorySegment proj_create_conversion_gnomonic(MemorySegment ctx, double center_lat, double center_long, double false_easting, double false_northing, MemorySegment ang_unit_name, double ang_unit_conv_factor, MemorySegment linear_unit_name, double linear_unit_conv_factor) {
        var mh$ = proj_create_conversion_gnomonic.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_create_conversion_gnomonic", ctx, center_lat, center_long, false_easting, false_northing, ang_unit_name, ang_unit_conv_factor, linear_unit_name, linear_unit_conv_factor);
            }
            return (MemorySegment)mh$.invokeExact(ctx, center_lat, center_long, false_easting, false_northing, ang_unit_name, ang_unit_conv_factor, linear_unit_name, linear_unit_conv_factor);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_create_conversion_hotine_oblique_mercator_variant_a {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_create_conversion_hotine_oblique_mercator_variant_a");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_hotine_oblique_mercator_variant_a(PJ_CONTEXT *ctx, double latitude_projection_centre, double longitude_projection_centre, double azimuth_initial_line, double angle_from_rectified_to_skrew_grid, double scale, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static FunctionDescriptor proj_create_conversion_hotine_oblique_mercator_variant_a$descriptor() {
        return proj_create_conversion_hotine_oblique_mercator_variant_a.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_hotine_oblique_mercator_variant_a(PJ_CONTEXT *ctx, double latitude_projection_centre, double longitude_projection_centre, double azimuth_initial_line, double angle_from_rectified_to_skrew_grid, double scale, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MethodHandle proj_create_conversion_hotine_oblique_mercator_variant_a$handle() {
        return proj_create_conversion_hotine_oblique_mercator_variant_a.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_hotine_oblique_mercator_variant_a(PJ_CONTEXT *ctx, double latitude_projection_centre, double longitude_projection_centre, double azimuth_initial_line, double angle_from_rectified_to_skrew_grid, double scale, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MemorySegment proj_create_conversion_hotine_oblique_mercator_variant_a$address() {
        return proj_create_conversion_hotine_oblique_mercator_variant_a.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ *proj_create_conversion_hotine_oblique_mercator_variant_a(PJ_CONTEXT *ctx, double latitude_projection_centre, double longitude_projection_centre, double azimuth_initial_line, double angle_from_rectified_to_skrew_grid, double scale, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MemorySegment proj_create_conversion_hotine_oblique_mercator_variant_a(MemorySegment ctx, double latitude_projection_centre, double longitude_projection_centre, double azimuth_initial_line, double angle_from_rectified_to_skrew_grid, double scale, double false_easting, double false_northing, MemorySegment ang_unit_name, double ang_unit_conv_factor, MemorySegment linear_unit_name, double linear_unit_conv_factor) {
        var mh$ = proj_create_conversion_hotine_oblique_mercator_variant_a.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_create_conversion_hotine_oblique_mercator_variant_a", ctx, latitude_projection_centre, longitude_projection_centre, azimuth_initial_line, angle_from_rectified_to_skrew_grid, scale, false_easting, false_northing, ang_unit_name, ang_unit_conv_factor, linear_unit_name, linear_unit_conv_factor);
            }
            return (MemorySegment)mh$.invokeExact(ctx, latitude_projection_centre, longitude_projection_centre, azimuth_initial_line, angle_from_rectified_to_skrew_grid, scale, false_easting, false_northing, ang_unit_name, ang_unit_conv_factor, linear_unit_name, linear_unit_conv_factor);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_create_conversion_hotine_oblique_mercator_variant_b {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_create_conversion_hotine_oblique_mercator_variant_b");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_hotine_oblique_mercator_variant_b(PJ_CONTEXT *ctx, double latitude_projection_centre, double longitude_projection_centre, double azimuth_initial_line, double angle_from_rectified_to_skrew_grid, double scale, double easting_projection_centre, double northing_projection_centre, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static FunctionDescriptor proj_create_conversion_hotine_oblique_mercator_variant_b$descriptor() {
        return proj_create_conversion_hotine_oblique_mercator_variant_b.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_hotine_oblique_mercator_variant_b(PJ_CONTEXT *ctx, double latitude_projection_centre, double longitude_projection_centre, double azimuth_initial_line, double angle_from_rectified_to_skrew_grid, double scale, double easting_projection_centre, double northing_projection_centre, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MethodHandle proj_create_conversion_hotine_oblique_mercator_variant_b$handle() {
        return proj_create_conversion_hotine_oblique_mercator_variant_b.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_hotine_oblique_mercator_variant_b(PJ_CONTEXT *ctx, double latitude_projection_centre, double longitude_projection_centre, double azimuth_initial_line, double angle_from_rectified_to_skrew_grid, double scale, double easting_projection_centre, double northing_projection_centre, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MemorySegment proj_create_conversion_hotine_oblique_mercator_variant_b$address() {
        return proj_create_conversion_hotine_oblique_mercator_variant_b.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ *proj_create_conversion_hotine_oblique_mercator_variant_b(PJ_CONTEXT *ctx, double latitude_projection_centre, double longitude_projection_centre, double azimuth_initial_line, double angle_from_rectified_to_skrew_grid, double scale, double easting_projection_centre, double northing_projection_centre, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MemorySegment proj_create_conversion_hotine_oblique_mercator_variant_b(MemorySegment ctx, double latitude_projection_centre, double longitude_projection_centre, double azimuth_initial_line, double angle_from_rectified_to_skrew_grid, double scale, double easting_projection_centre, double northing_projection_centre, MemorySegment ang_unit_name, double ang_unit_conv_factor, MemorySegment linear_unit_name, double linear_unit_conv_factor) {
        var mh$ = proj_create_conversion_hotine_oblique_mercator_variant_b.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_create_conversion_hotine_oblique_mercator_variant_b", ctx, latitude_projection_centre, longitude_projection_centre, azimuth_initial_line, angle_from_rectified_to_skrew_grid, scale, easting_projection_centre, northing_projection_centre, ang_unit_name, ang_unit_conv_factor, linear_unit_name, linear_unit_conv_factor);
            }
            return (MemorySegment)mh$.invokeExact(ctx, latitude_projection_centre, longitude_projection_centre, azimuth_initial_line, angle_from_rectified_to_skrew_grid, scale, easting_projection_centre, northing_projection_centre, ang_unit_name, ang_unit_conv_factor, linear_unit_name, linear_unit_conv_factor);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_create_conversion_hotine_oblique_mercator_two_point_natural_origin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_create_conversion_hotine_oblique_mercator_two_point_natural_origin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_hotine_oblique_mercator_two_point_natural_origin(PJ_CONTEXT *ctx, double latitude_projection_centre, double latitude_point1, double longitude_point1, double latitude_point2, double longitude_point2, double scale, double easting_projection_centre, double northing_projection_centre, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static FunctionDescriptor proj_create_conversion_hotine_oblique_mercator_two_point_natural_origin$descriptor() {
        return proj_create_conversion_hotine_oblique_mercator_two_point_natural_origin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_hotine_oblique_mercator_two_point_natural_origin(PJ_CONTEXT *ctx, double latitude_projection_centre, double latitude_point1, double longitude_point1, double latitude_point2, double longitude_point2, double scale, double easting_projection_centre, double northing_projection_centre, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MethodHandle proj_create_conversion_hotine_oblique_mercator_two_point_natural_origin$handle() {
        return proj_create_conversion_hotine_oblique_mercator_two_point_natural_origin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_hotine_oblique_mercator_two_point_natural_origin(PJ_CONTEXT *ctx, double latitude_projection_centre, double latitude_point1, double longitude_point1, double latitude_point2, double longitude_point2, double scale, double easting_projection_centre, double northing_projection_centre, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MemorySegment proj_create_conversion_hotine_oblique_mercator_two_point_natural_origin$address() {
        return proj_create_conversion_hotine_oblique_mercator_two_point_natural_origin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ *proj_create_conversion_hotine_oblique_mercator_two_point_natural_origin(PJ_CONTEXT *ctx, double latitude_projection_centre, double latitude_point1, double longitude_point1, double latitude_point2, double longitude_point2, double scale, double easting_projection_centre, double northing_projection_centre, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MemorySegment proj_create_conversion_hotine_oblique_mercator_two_point_natural_origin(MemorySegment ctx, double latitude_projection_centre, double latitude_point1, double longitude_point1, double latitude_point2, double longitude_point2, double scale, double easting_projection_centre, double northing_projection_centre, MemorySegment ang_unit_name, double ang_unit_conv_factor, MemorySegment linear_unit_name, double linear_unit_conv_factor) {
        var mh$ = proj_create_conversion_hotine_oblique_mercator_two_point_natural_origin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_create_conversion_hotine_oblique_mercator_two_point_natural_origin", ctx, latitude_projection_centre, latitude_point1, longitude_point1, latitude_point2, longitude_point2, scale, easting_projection_centre, northing_projection_centre, ang_unit_name, ang_unit_conv_factor, linear_unit_name, linear_unit_conv_factor);
            }
            return (MemorySegment)mh$.invokeExact(ctx, latitude_projection_centre, latitude_point1, longitude_point1, latitude_point2, longitude_point2, scale, easting_projection_centre, northing_projection_centre, ang_unit_name, ang_unit_conv_factor, linear_unit_name, linear_unit_conv_factor);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_create_conversion_laborde_oblique_mercator {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_create_conversion_laborde_oblique_mercator");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_laborde_oblique_mercator(PJ_CONTEXT *ctx, double latitude_projection_centre, double longitude_projection_centre, double azimuth_initial_line, double scale, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static FunctionDescriptor proj_create_conversion_laborde_oblique_mercator$descriptor() {
        return proj_create_conversion_laborde_oblique_mercator.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_laborde_oblique_mercator(PJ_CONTEXT *ctx, double latitude_projection_centre, double longitude_projection_centre, double azimuth_initial_line, double scale, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MethodHandle proj_create_conversion_laborde_oblique_mercator$handle() {
        return proj_create_conversion_laborde_oblique_mercator.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_laborde_oblique_mercator(PJ_CONTEXT *ctx, double latitude_projection_centre, double longitude_projection_centre, double azimuth_initial_line, double scale, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MemorySegment proj_create_conversion_laborde_oblique_mercator$address() {
        return proj_create_conversion_laborde_oblique_mercator.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ *proj_create_conversion_laborde_oblique_mercator(PJ_CONTEXT *ctx, double latitude_projection_centre, double longitude_projection_centre, double azimuth_initial_line, double scale, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MemorySegment proj_create_conversion_laborde_oblique_mercator(MemorySegment ctx, double latitude_projection_centre, double longitude_projection_centre, double azimuth_initial_line, double scale, double false_easting, double false_northing, MemorySegment ang_unit_name, double ang_unit_conv_factor, MemorySegment linear_unit_name, double linear_unit_conv_factor) {
        var mh$ = proj_create_conversion_laborde_oblique_mercator.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_create_conversion_laborde_oblique_mercator", ctx, latitude_projection_centre, longitude_projection_centre, azimuth_initial_line, scale, false_easting, false_northing, ang_unit_name, ang_unit_conv_factor, linear_unit_name, linear_unit_conv_factor);
            }
            return (MemorySegment)mh$.invokeExact(ctx, latitude_projection_centre, longitude_projection_centre, azimuth_initial_line, scale, false_easting, false_northing, ang_unit_name, ang_unit_conv_factor, linear_unit_name, linear_unit_conv_factor);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_create_conversion_international_map_world_polyconic {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_create_conversion_international_map_world_polyconic");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_international_map_world_polyconic(PJ_CONTEXT *ctx, double center_long, double latitude_first_parallel, double latitude_second_parallel, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static FunctionDescriptor proj_create_conversion_international_map_world_polyconic$descriptor() {
        return proj_create_conversion_international_map_world_polyconic.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_international_map_world_polyconic(PJ_CONTEXT *ctx, double center_long, double latitude_first_parallel, double latitude_second_parallel, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MethodHandle proj_create_conversion_international_map_world_polyconic$handle() {
        return proj_create_conversion_international_map_world_polyconic.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_international_map_world_polyconic(PJ_CONTEXT *ctx, double center_long, double latitude_first_parallel, double latitude_second_parallel, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MemorySegment proj_create_conversion_international_map_world_polyconic$address() {
        return proj_create_conversion_international_map_world_polyconic.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ *proj_create_conversion_international_map_world_polyconic(PJ_CONTEXT *ctx, double center_long, double latitude_first_parallel, double latitude_second_parallel, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MemorySegment proj_create_conversion_international_map_world_polyconic(MemorySegment ctx, double center_long, double latitude_first_parallel, double latitude_second_parallel, double false_easting, double false_northing, MemorySegment ang_unit_name, double ang_unit_conv_factor, MemorySegment linear_unit_name, double linear_unit_conv_factor) {
        var mh$ = proj_create_conversion_international_map_world_polyconic.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_create_conversion_international_map_world_polyconic", ctx, center_long, latitude_first_parallel, latitude_second_parallel, false_easting, false_northing, ang_unit_name, ang_unit_conv_factor, linear_unit_name, linear_unit_conv_factor);
            }
            return (MemorySegment)mh$.invokeExact(ctx, center_long, latitude_first_parallel, latitude_second_parallel, false_easting, false_northing, ang_unit_name, ang_unit_conv_factor, linear_unit_name, linear_unit_conv_factor);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_create_conversion_krovak_north_oriented {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_create_conversion_krovak_north_oriented");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_krovak_north_oriented(PJ_CONTEXT *ctx, double latitude_projection_centre, double longitude_of_origin, double colatitude_cone_axis, double latitude_pseudo_standard_parallel, double scale_factor_pseudo_standard_parallel, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static FunctionDescriptor proj_create_conversion_krovak_north_oriented$descriptor() {
        return proj_create_conversion_krovak_north_oriented.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_krovak_north_oriented(PJ_CONTEXT *ctx, double latitude_projection_centre, double longitude_of_origin, double colatitude_cone_axis, double latitude_pseudo_standard_parallel, double scale_factor_pseudo_standard_parallel, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MethodHandle proj_create_conversion_krovak_north_oriented$handle() {
        return proj_create_conversion_krovak_north_oriented.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_krovak_north_oriented(PJ_CONTEXT *ctx, double latitude_projection_centre, double longitude_of_origin, double colatitude_cone_axis, double latitude_pseudo_standard_parallel, double scale_factor_pseudo_standard_parallel, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MemorySegment proj_create_conversion_krovak_north_oriented$address() {
        return proj_create_conversion_krovak_north_oriented.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ *proj_create_conversion_krovak_north_oriented(PJ_CONTEXT *ctx, double latitude_projection_centre, double longitude_of_origin, double colatitude_cone_axis, double latitude_pseudo_standard_parallel, double scale_factor_pseudo_standard_parallel, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MemorySegment proj_create_conversion_krovak_north_oriented(MemorySegment ctx, double latitude_projection_centre, double longitude_of_origin, double colatitude_cone_axis, double latitude_pseudo_standard_parallel, double scale_factor_pseudo_standard_parallel, double false_easting, double false_northing, MemorySegment ang_unit_name, double ang_unit_conv_factor, MemorySegment linear_unit_name, double linear_unit_conv_factor) {
        var mh$ = proj_create_conversion_krovak_north_oriented.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_create_conversion_krovak_north_oriented", ctx, latitude_projection_centre, longitude_of_origin, colatitude_cone_axis, latitude_pseudo_standard_parallel, scale_factor_pseudo_standard_parallel, false_easting, false_northing, ang_unit_name, ang_unit_conv_factor, linear_unit_name, linear_unit_conv_factor);
            }
            return (MemorySegment)mh$.invokeExact(ctx, latitude_projection_centre, longitude_of_origin, colatitude_cone_axis, latitude_pseudo_standard_parallel, scale_factor_pseudo_standard_parallel, false_easting, false_northing, ang_unit_name, ang_unit_conv_factor, linear_unit_name, linear_unit_conv_factor);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_create_conversion_krovak {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_create_conversion_krovak");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_krovak(PJ_CONTEXT *ctx, double latitude_projection_centre, double longitude_of_origin, double colatitude_cone_axis, double latitude_pseudo_standard_parallel, double scale_factor_pseudo_standard_parallel, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static FunctionDescriptor proj_create_conversion_krovak$descriptor() {
        return proj_create_conversion_krovak.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_krovak(PJ_CONTEXT *ctx, double latitude_projection_centre, double longitude_of_origin, double colatitude_cone_axis, double latitude_pseudo_standard_parallel, double scale_factor_pseudo_standard_parallel, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MethodHandle proj_create_conversion_krovak$handle() {
        return proj_create_conversion_krovak.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_krovak(PJ_CONTEXT *ctx, double latitude_projection_centre, double longitude_of_origin, double colatitude_cone_axis, double latitude_pseudo_standard_parallel, double scale_factor_pseudo_standard_parallel, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MemorySegment proj_create_conversion_krovak$address() {
        return proj_create_conversion_krovak.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ *proj_create_conversion_krovak(PJ_CONTEXT *ctx, double latitude_projection_centre, double longitude_of_origin, double colatitude_cone_axis, double latitude_pseudo_standard_parallel, double scale_factor_pseudo_standard_parallel, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MemorySegment proj_create_conversion_krovak(MemorySegment ctx, double latitude_projection_centre, double longitude_of_origin, double colatitude_cone_axis, double latitude_pseudo_standard_parallel, double scale_factor_pseudo_standard_parallel, double false_easting, double false_northing, MemorySegment ang_unit_name, double ang_unit_conv_factor, MemorySegment linear_unit_name, double linear_unit_conv_factor) {
        var mh$ = proj_create_conversion_krovak.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_create_conversion_krovak", ctx, latitude_projection_centre, longitude_of_origin, colatitude_cone_axis, latitude_pseudo_standard_parallel, scale_factor_pseudo_standard_parallel, false_easting, false_northing, ang_unit_name, ang_unit_conv_factor, linear_unit_name, linear_unit_conv_factor);
            }
            return (MemorySegment)mh$.invokeExact(ctx, latitude_projection_centre, longitude_of_origin, colatitude_cone_axis, latitude_pseudo_standard_parallel, scale_factor_pseudo_standard_parallel, false_easting, false_northing, ang_unit_name, ang_unit_conv_factor, linear_unit_name, linear_unit_conv_factor);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_create_conversion_lambert_azimuthal_equal_area {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_create_conversion_lambert_azimuthal_equal_area");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_lambert_azimuthal_equal_area(PJ_CONTEXT *ctx, double latitude_nat_origin, double longitude_nat_origin, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static FunctionDescriptor proj_create_conversion_lambert_azimuthal_equal_area$descriptor() {
        return proj_create_conversion_lambert_azimuthal_equal_area.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_lambert_azimuthal_equal_area(PJ_CONTEXT *ctx, double latitude_nat_origin, double longitude_nat_origin, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MethodHandle proj_create_conversion_lambert_azimuthal_equal_area$handle() {
        return proj_create_conversion_lambert_azimuthal_equal_area.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_lambert_azimuthal_equal_area(PJ_CONTEXT *ctx, double latitude_nat_origin, double longitude_nat_origin, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MemorySegment proj_create_conversion_lambert_azimuthal_equal_area$address() {
        return proj_create_conversion_lambert_azimuthal_equal_area.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ *proj_create_conversion_lambert_azimuthal_equal_area(PJ_CONTEXT *ctx, double latitude_nat_origin, double longitude_nat_origin, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MemorySegment proj_create_conversion_lambert_azimuthal_equal_area(MemorySegment ctx, double latitude_nat_origin, double longitude_nat_origin, double false_easting, double false_northing, MemorySegment ang_unit_name, double ang_unit_conv_factor, MemorySegment linear_unit_name, double linear_unit_conv_factor) {
        var mh$ = proj_create_conversion_lambert_azimuthal_equal_area.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_create_conversion_lambert_azimuthal_equal_area", ctx, latitude_nat_origin, longitude_nat_origin, false_easting, false_northing, ang_unit_name, ang_unit_conv_factor, linear_unit_name, linear_unit_conv_factor);
            }
            return (MemorySegment)mh$.invokeExact(ctx, latitude_nat_origin, longitude_nat_origin, false_easting, false_northing, ang_unit_name, ang_unit_conv_factor, linear_unit_name, linear_unit_conv_factor);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_create_conversion_miller_cylindrical {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_create_conversion_miller_cylindrical");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_miller_cylindrical(PJ_CONTEXT *ctx, double center_long, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static FunctionDescriptor proj_create_conversion_miller_cylindrical$descriptor() {
        return proj_create_conversion_miller_cylindrical.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_miller_cylindrical(PJ_CONTEXT *ctx, double center_long, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MethodHandle proj_create_conversion_miller_cylindrical$handle() {
        return proj_create_conversion_miller_cylindrical.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_miller_cylindrical(PJ_CONTEXT *ctx, double center_long, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MemorySegment proj_create_conversion_miller_cylindrical$address() {
        return proj_create_conversion_miller_cylindrical.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ *proj_create_conversion_miller_cylindrical(PJ_CONTEXT *ctx, double center_long, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MemorySegment proj_create_conversion_miller_cylindrical(MemorySegment ctx, double center_long, double false_easting, double false_northing, MemorySegment ang_unit_name, double ang_unit_conv_factor, MemorySegment linear_unit_name, double linear_unit_conv_factor) {
        var mh$ = proj_create_conversion_miller_cylindrical.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_create_conversion_miller_cylindrical", ctx, center_long, false_easting, false_northing, ang_unit_name, ang_unit_conv_factor, linear_unit_name, linear_unit_conv_factor);
            }
            return (MemorySegment)mh$.invokeExact(ctx, center_long, false_easting, false_northing, ang_unit_name, ang_unit_conv_factor, linear_unit_name, linear_unit_conv_factor);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_create_conversion_mercator_variant_a {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_create_conversion_mercator_variant_a");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_mercator_variant_a(PJ_CONTEXT *ctx, double center_lat, double center_long, double scale, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static FunctionDescriptor proj_create_conversion_mercator_variant_a$descriptor() {
        return proj_create_conversion_mercator_variant_a.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_mercator_variant_a(PJ_CONTEXT *ctx, double center_lat, double center_long, double scale, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MethodHandle proj_create_conversion_mercator_variant_a$handle() {
        return proj_create_conversion_mercator_variant_a.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_mercator_variant_a(PJ_CONTEXT *ctx, double center_lat, double center_long, double scale, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MemorySegment proj_create_conversion_mercator_variant_a$address() {
        return proj_create_conversion_mercator_variant_a.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ *proj_create_conversion_mercator_variant_a(PJ_CONTEXT *ctx, double center_lat, double center_long, double scale, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MemorySegment proj_create_conversion_mercator_variant_a(MemorySegment ctx, double center_lat, double center_long, double scale, double false_easting, double false_northing, MemorySegment ang_unit_name, double ang_unit_conv_factor, MemorySegment linear_unit_name, double linear_unit_conv_factor) {
        var mh$ = proj_create_conversion_mercator_variant_a.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_create_conversion_mercator_variant_a", ctx, center_lat, center_long, scale, false_easting, false_northing, ang_unit_name, ang_unit_conv_factor, linear_unit_name, linear_unit_conv_factor);
            }
            return (MemorySegment)mh$.invokeExact(ctx, center_lat, center_long, scale, false_easting, false_northing, ang_unit_name, ang_unit_conv_factor, linear_unit_name, linear_unit_conv_factor);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_create_conversion_mercator_variant_b {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_create_conversion_mercator_variant_b");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_mercator_variant_b(PJ_CONTEXT *ctx, double latitude_first_parallel, double center_long, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static FunctionDescriptor proj_create_conversion_mercator_variant_b$descriptor() {
        return proj_create_conversion_mercator_variant_b.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_mercator_variant_b(PJ_CONTEXT *ctx, double latitude_first_parallel, double center_long, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MethodHandle proj_create_conversion_mercator_variant_b$handle() {
        return proj_create_conversion_mercator_variant_b.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_mercator_variant_b(PJ_CONTEXT *ctx, double latitude_first_parallel, double center_long, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MemorySegment proj_create_conversion_mercator_variant_b$address() {
        return proj_create_conversion_mercator_variant_b.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ *proj_create_conversion_mercator_variant_b(PJ_CONTEXT *ctx, double latitude_first_parallel, double center_long, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MemorySegment proj_create_conversion_mercator_variant_b(MemorySegment ctx, double latitude_first_parallel, double center_long, double false_easting, double false_northing, MemorySegment ang_unit_name, double ang_unit_conv_factor, MemorySegment linear_unit_name, double linear_unit_conv_factor) {
        var mh$ = proj_create_conversion_mercator_variant_b.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_create_conversion_mercator_variant_b", ctx, latitude_first_parallel, center_long, false_easting, false_northing, ang_unit_name, ang_unit_conv_factor, linear_unit_name, linear_unit_conv_factor);
            }
            return (MemorySegment)mh$.invokeExact(ctx, latitude_first_parallel, center_long, false_easting, false_northing, ang_unit_name, ang_unit_conv_factor, linear_unit_name, linear_unit_conv_factor);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_create_conversion_popular_visualisation_pseudo_mercator {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_create_conversion_popular_visualisation_pseudo_mercator");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_popular_visualisation_pseudo_mercator(PJ_CONTEXT *ctx, double center_lat, double center_long, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static FunctionDescriptor proj_create_conversion_popular_visualisation_pseudo_mercator$descriptor() {
        return proj_create_conversion_popular_visualisation_pseudo_mercator.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_popular_visualisation_pseudo_mercator(PJ_CONTEXT *ctx, double center_lat, double center_long, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MethodHandle proj_create_conversion_popular_visualisation_pseudo_mercator$handle() {
        return proj_create_conversion_popular_visualisation_pseudo_mercator.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_popular_visualisation_pseudo_mercator(PJ_CONTEXT *ctx, double center_lat, double center_long, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MemorySegment proj_create_conversion_popular_visualisation_pseudo_mercator$address() {
        return proj_create_conversion_popular_visualisation_pseudo_mercator.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ *proj_create_conversion_popular_visualisation_pseudo_mercator(PJ_CONTEXT *ctx, double center_lat, double center_long, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MemorySegment proj_create_conversion_popular_visualisation_pseudo_mercator(MemorySegment ctx, double center_lat, double center_long, double false_easting, double false_northing, MemorySegment ang_unit_name, double ang_unit_conv_factor, MemorySegment linear_unit_name, double linear_unit_conv_factor) {
        var mh$ = proj_create_conversion_popular_visualisation_pseudo_mercator.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_create_conversion_popular_visualisation_pseudo_mercator", ctx, center_lat, center_long, false_easting, false_northing, ang_unit_name, ang_unit_conv_factor, linear_unit_name, linear_unit_conv_factor);
            }
            return (MemorySegment)mh$.invokeExact(ctx, center_lat, center_long, false_easting, false_northing, ang_unit_name, ang_unit_conv_factor, linear_unit_name, linear_unit_conv_factor);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_create_conversion_mollweide {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_create_conversion_mollweide");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_mollweide(PJ_CONTEXT *ctx, double center_long, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static FunctionDescriptor proj_create_conversion_mollweide$descriptor() {
        return proj_create_conversion_mollweide.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_mollweide(PJ_CONTEXT *ctx, double center_long, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MethodHandle proj_create_conversion_mollweide$handle() {
        return proj_create_conversion_mollweide.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_mollweide(PJ_CONTEXT *ctx, double center_long, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MemorySegment proj_create_conversion_mollweide$address() {
        return proj_create_conversion_mollweide.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ *proj_create_conversion_mollweide(PJ_CONTEXT *ctx, double center_long, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MemorySegment proj_create_conversion_mollweide(MemorySegment ctx, double center_long, double false_easting, double false_northing, MemorySegment ang_unit_name, double ang_unit_conv_factor, MemorySegment linear_unit_name, double linear_unit_conv_factor) {
        var mh$ = proj_create_conversion_mollweide.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_create_conversion_mollweide", ctx, center_long, false_easting, false_northing, ang_unit_name, ang_unit_conv_factor, linear_unit_name, linear_unit_conv_factor);
            }
            return (MemorySegment)mh$.invokeExact(ctx, center_long, false_easting, false_northing, ang_unit_name, ang_unit_conv_factor, linear_unit_name, linear_unit_conv_factor);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_create_conversion_new_zealand_mapping_grid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_create_conversion_new_zealand_mapping_grid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_new_zealand_mapping_grid(PJ_CONTEXT *ctx, double center_lat, double center_long, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static FunctionDescriptor proj_create_conversion_new_zealand_mapping_grid$descriptor() {
        return proj_create_conversion_new_zealand_mapping_grid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_new_zealand_mapping_grid(PJ_CONTEXT *ctx, double center_lat, double center_long, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MethodHandle proj_create_conversion_new_zealand_mapping_grid$handle() {
        return proj_create_conversion_new_zealand_mapping_grid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_new_zealand_mapping_grid(PJ_CONTEXT *ctx, double center_lat, double center_long, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MemorySegment proj_create_conversion_new_zealand_mapping_grid$address() {
        return proj_create_conversion_new_zealand_mapping_grid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ *proj_create_conversion_new_zealand_mapping_grid(PJ_CONTEXT *ctx, double center_lat, double center_long, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MemorySegment proj_create_conversion_new_zealand_mapping_grid(MemorySegment ctx, double center_lat, double center_long, double false_easting, double false_northing, MemorySegment ang_unit_name, double ang_unit_conv_factor, MemorySegment linear_unit_name, double linear_unit_conv_factor) {
        var mh$ = proj_create_conversion_new_zealand_mapping_grid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_create_conversion_new_zealand_mapping_grid", ctx, center_lat, center_long, false_easting, false_northing, ang_unit_name, ang_unit_conv_factor, linear_unit_name, linear_unit_conv_factor);
            }
            return (MemorySegment)mh$.invokeExact(ctx, center_lat, center_long, false_easting, false_northing, ang_unit_name, ang_unit_conv_factor, linear_unit_name, linear_unit_conv_factor);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_create_conversion_oblique_stereographic {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_create_conversion_oblique_stereographic");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_oblique_stereographic(PJ_CONTEXT *ctx, double center_lat, double center_long, double scale, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static FunctionDescriptor proj_create_conversion_oblique_stereographic$descriptor() {
        return proj_create_conversion_oblique_stereographic.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_oblique_stereographic(PJ_CONTEXT *ctx, double center_lat, double center_long, double scale, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MethodHandle proj_create_conversion_oblique_stereographic$handle() {
        return proj_create_conversion_oblique_stereographic.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_oblique_stereographic(PJ_CONTEXT *ctx, double center_lat, double center_long, double scale, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MemorySegment proj_create_conversion_oblique_stereographic$address() {
        return proj_create_conversion_oblique_stereographic.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ *proj_create_conversion_oblique_stereographic(PJ_CONTEXT *ctx, double center_lat, double center_long, double scale, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MemorySegment proj_create_conversion_oblique_stereographic(MemorySegment ctx, double center_lat, double center_long, double scale, double false_easting, double false_northing, MemorySegment ang_unit_name, double ang_unit_conv_factor, MemorySegment linear_unit_name, double linear_unit_conv_factor) {
        var mh$ = proj_create_conversion_oblique_stereographic.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_create_conversion_oblique_stereographic", ctx, center_lat, center_long, scale, false_easting, false_northing, ang_unit_name, ang_unit_conv_factor, linear_unit_name, linear_unit_conv_factor);
            }
            return (MemorySegment)mh$.invokeExact(ctx, center_lat, center_long, scale, false_easting, false_northing, ang_unit_name, ang_unit_conv_factor, linear_unit_name, linear_unit_conv_factor);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_create_conversion_orthographic {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_create_conversion_orthographic");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_orthographic(PJ_CONTEXT *ctx, double center_lat, double center_long, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static FunctionDescriptor proj_create_conversion_orthographic$descriptor() {
        return proj_create_conversion_orthographic.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_orthographic(PJ_CONTEXT *ctx, double center_lat, double center_long, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MethodHandle proj_create_conversion_orthographic$handle() {
        return proj_create_conversion_orthographic.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_orthographic(PJ_CONTEXT *ctx, double center_lat, double center_long, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MemorySegment proj_create_conversion_orthographic$address() {
        return proj_create_conversion_orthographic.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ *proj_create_conversion_orthographic(PJ_CONTEXT *ctx, double center_lat, double center_long, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MemorySegment proj_create_conversion_orthographic(MemorySegment ctx, double center_lat, double center_long, double false_easting, double false_northing, MemorySegment ang_unit_name, double ang_unit_conv_factor, MemorySegment linear_unit_name, double linear_unit_conv_factor) {
        var mh$ = proj_create_conversion_orthographic.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_create_conversion_orthographic", ctx, center_lat, center_long, false_easting, false_northing, ang_unit_name, ang_unit_conv_factor, linear_unit_name, linear_unit_conv_factor);
            }
            return (MemorySegment)mh$.invokeExact(ctx, center_lat, center_long, false_easting, false_northing, ang_unit_name, ang_unit_conv_factor, linear_unit_name, linear_unit_conv_factor);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_create_conversion_local_orthographic {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_create_conversion_local_orthographic");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_local_orthographic(PJ_CONTEXT *ctx, double center_lat, double center_long, double azimuth, double scale, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static FunctionDescriptor proj_create_conversion_local_orthographic$descriptor() {
        return proj_create_conversion_local_orthographic.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_local_orthographic(PJ_CONTEXT *ctx, double center_lat, double center_long, double azimuth, double scale, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MethodHandle proj_create_conversion_local_orthographic$handle() {
        return proj_create_conversion_local_orthographic.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_local_orthographic(PJ_CONTEXT *ctx, double center_lat, double center_long, double azimuth, double scale, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MemorySegment proj_create_conversion_local_orthographic$address() {
        return proj_create_conversion_local_orthographic.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ *proj_create_conversion_local_orthographic(PJ_CONTEXT *ctx, double center_lat, double center_long, double azimuth, double scale, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MemorySegment proj_create_conversion_local_orthographic(MemorySegment ctx, double center_lat, double center_long, double azimuth, double scale, double false_easting, double false_northing, MemorySegment ang_unit_name, double ang_unit_conv_factor, MemorySegment linear_unit_name, double linear_unit_conv_factor) {
        var mh$ = proj_create_conversion_local_orthographic.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_create_conversion_local_orthographic", ctx, center_lat, center_long, azimuth, scale, false_easting, false_northing, ang_unit_name, ang_unit_conv_factor, linear_unit_name, linear_unit_conv_factor);
            }
            return (MemorySegment)mh$.invokeExact(ctx, center_lat, center_long, azimuth, scale, false_easting, false_northing, ang_unit_name, ang_unit_conv_factor, linear_unit_name, linear_unit_conv_factor);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_create_conversion_american_polyconic {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_create_conversion_american_polyconic");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_american_polyconic(PJ_CONTEXT *ctx, double center_lat, double center_long, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static FunctionDescriptor proj_create_conversion_american_polyconic$descriptor() {
        return proj_create_conversion_american_polyconic.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_american_polyconic(PJ_CONTEXT *ctx, double center_lat, double center_long, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MethodHandle proj_create_conversion_american_polyconic$handle() {
        return proj_create_conversion_american_polyconic.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_american_polyconic(PJ_CONTEXT *ctx, double center_lat, double center_long, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MemorySegment proj_create_conversion_american_polyconic$address() {
        return proj_create_conversion_american_polyconic.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ *proj_create_conversion_american_polyconic(PJ_CONTEXT *ctx, double center_lat, double center_long, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MemorySegment proj_create_conversion_american_polyconic(MemorySegment ctx, double center_lat, double center_long, double false_easting, double false_northing, MemorySegment ang_unit_name, double ang_unit_conv_factor, MemorySegment linear_unit_name, double linear_unit_conv_factor) {
        var mh$ = proj_create_conversion_american_polyconic.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_create_conversion_american_polyconic", ctx, center_lat, center_long, false_easting, false_northing, ang_unit_name, ang_unit_conv_factor, linear_unit_name, linear_unit_conv_factor);
            }
            return (MemorySegment)mh$.invokeExact(ctx, center_lat, center_long, false_easting, false_northing, ang_unit_name, ang_unit_conv_factor, linear_unit_name, linear_unit_conv_factor);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_create_conversion_polar_stereographic_variant_a {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_create_conversion_polar_stereographic_variant_a");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_polar_stereographic_variant_a(PJ_CONTEXT *ctx, double center_lat, double center_long, double scale, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static FunctionDescriptor proj_create_conversion_polar_stereographic_variant_a$descriptor() {
        return proj_create_conversion_polar_stereographic_variant_a.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_polar_stereographic_variant_a(PJ_CONTEXT *ctx, double center_lat, double center_long, double scale, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MethodHandle proj_create_conversion_polar_stereographic_variant_a$handle() {
        return proj_create_conversion_polar_stereographic_variant_a.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_polar_stereographic_variant_a(PJ_CONTEXT *ctx, double center_lat, double center_long, double scale, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MemorySegment proj_create_conversion_polar_stereographic_variant_a$address() {
        return proj_create_conversion_polar_stereographic_variant_a.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ *proj_create_conversion_polar_stereographic_variant_a(PJ_CONTEXT *ctx, double center_lat, double center_long, double scale, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MemorySegment proj_create_conversion_polar_stereographic_variant_a(MemorySegment ctx, double center_lat, double center_long, double scale, double false_easting, double false_northing, MemorySegment ang_unit_name, double ang_unit_conv_factor, MemorySegment linear_unit_name, double linear_unit_conv_factor) {
        var mh$ = proj_create_conversion_polar_stereographic_variant_a.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_create_conversion_polar_stereographic_variant_a", ctx, center_lat, center_long, scale, false_easting, false_northing, ang_unit_name, ang_unit_conv_factor, linear_unit_name, linear_unit_conv_factor);
            }
            return (MemorySegment)mh$.invokeExact(ctx, center_lat, center_long, scale, false_easting, false_northing, ang_unit_name, ang_unit_conv_factor, linear_unit_name, linear_unit_conv_factor);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_create_conversion_polar_stereographic_variant_b {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_create_conversion_polar_stereographic_variant_b");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_polar_stereographic_variant_b(PJ_CONTEXT *ctx, double latitude_standard_parallel, double longitude_of_origin, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static FunctionDescriptor proj_create_conversion_polar_stereographic_variant_b$descriptor() {
        return proj_create_conversion_polar_stereographic_variant_b.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_polar_stereographic_variant_b(PJ_CONTEXT *ctx, double latitude_standard_parallel, double longitude_of_origin, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MethodHandle proj_create_conversion_polar_stereographic_variant_b$handle() {
        return proj_create_conversion_polar_stereographic_variant_b.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_polar_stereographic_variant_b(PJ_CONTEXT *ctx, double latitude_standard_parallel, double longitude_of_origin, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MemorySegment proj_create_conversion_polar_stereographic_variant_b$address() {
        return proj_create_conversion_polar_stereographic_variant_b.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ *proj_create_conversion_polar_stereographic_variant_b(PJ_CONTEXT *ctx, double latitude_standard_parallel, double longitude_of_origin, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MemorySegment proj_create_conversion_polar_stereographic_variant_b(MemorySegment ctx, double latitude_standard_parallel, double longitude_of_origin, double false_easting, double false_northing, MemorySegment ang_unit_name, double ang_unit_conv_factor, MemorySegment linear_unit_name, double linear_unit_conv_factor) {
        var mh$ = proj_create_conversion_polar_stereographic_variant_b.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_create_conversion_polar_stereographic_variant_b", ctx, latitude_standard_parallel, longitude_of_origin, false_easting, false_northing, ang_unit_name, ang_unit_conv_factor, linear_unit_name, linear_unit_conv_factor);
            }
            return (MemorySegment)mh$.invokeExact(ctx, latitude_standard_parallel, longitude_of_origin, false_easting, false_northing, ang_unit_name, ang_unit_conv_factor, linear_unit_name, linear_unit_conv_factor);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_create_conversion_robinson {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_create_conversion_robinson");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_robinson(PJ_CONTEXT *ctx, double center_long, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static FunctionDescriptor proj_create_conversion_robinson$descriptor() {
        return proj_create_conversion_robinson.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_robinson(PJ_CONTEXT *ctx, double center_long, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MethodHandle proj_create_conversion_robinson$handle() {
        return proj_create_conversion_robinson.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_robinson(PJ_CONTEXT *ctx, double center_long, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MemorySegment proj_create_conversion_robinson$address() {
        return proj_create_conversion_robinson.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ *proj_create_conversion_robinson(PJ_CONTEXT *ctx, double center_long, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MemorySegment proj_create_conversion_robinson(MemorySegment ctx, double center_long, double false_easting, double false_northing, MemorySegment ang_unit_name, double ang_unit_conv_factor, MemorySegment linear_unit_name, double linear_unit_conv_factor) {
        var mh$ = proj_create_conversion_robinson.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_create_conversion_robinson", ctx, center_long, false_easting, false_northing, ang_unit_name, ang_unit_conv_factor, linear_unit_name, linear_unit_conv_factor);
            }
            return (MemorySegment)mh$.invokeExact(ctx, center_long, false_easting, false_northing, ang_unit_name, ang_unit_conv_factor, linear_unit_name, linear_unit_conv_factor);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_create_conversion_sinusoidal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_create_conversion_sinusoidal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_sinusoidal(PJ_CONTEXT *ctx, double center_long, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static FunctionDescriptor proj_create_conversion_sinusoidal$descriptor() {
        return proj_create_conversion_sinusoidal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_sinusoidal(PJ_CONTEXT *ctx, double center_long, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MethodHandle proj_create_conversion_sinusoidal$handle() {
        return proj_create_conversion_sinusoidal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_sinusoidal(PJ_CONTEXT *ctx, double center_long, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MemorySegment proj_create_conversion_sinusoidal$address() {
        return proj_create_conversion_sinusoidal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ *proj_create_conversion_sinusoidal(PJ_CONTEXT *ctx, double center_long, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MemorySegment proj_create_conversion_sinusoidal(MemorySegment ctx, double center_long, double false_easting, double false_northing, MemorySegment ang_unit_name, double ang_unit_conv_factor, MemorySegment linear_unit_name, double linear_unit_conv_factor) {
        var mh$ = proj_create_conversion_sinusoidal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_create_conversion_sinusoidal", ctx, center_long, false_easting, false_northing, ang_unit_name, ang_unit_conv_factor, linear_unit_name, linear_unit_conv_factor);
            }
            return (MemorySegment)mh$.invokeExact(ctx, center_long, false_easting, false_northing, ang_unit_name, ang_unit_conv_factor, linear_unit_name, linear_unit_conv_factor);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_create_conversion_stereographic {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_create_conversion_stereographic");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_stereographic(PJ_CONTEXT *ctx, double center_lat, double center_long, double scale, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static FunctionDescriptor proj_create_conversion_stereographic$descriptor() {
        return proj_create_conversion_stereographic.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_stereographic(PJ_CONTEXT *ctx, double center_lat, double center_long, double scale, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MethodHandle proj_create_conversion_stereographic$handle() {
        return proj_create_conversion_stereographic.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_stereographic(PJ_CONTEXT *ctx, double center_lat, double center_long, double scale, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MemorySegment proj_create_conversion_stereographic$address() {
        return proj_create_conversion_stereographic.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ *proj_create_conversion_stereographic(PJ_CONTEXT *ctx, double center_lat, double center_long, double scale, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MemorySegment proj_create_conversion_stereographic(MemorySegment ctx, double center_lat, double center_long, double scale, double false_easting, double false_northing, MemorySegment ang_unit_name, double ang_unit_conv_factor, MemorySegment linear_unit_name, double linear_unit_conv_factor) {
        var mh$ = proj_create_conversion_stereographic.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_create_conversion_stereographic", ctx, center_lat, center_long, scale, false_easting, false_northing, ang_unit_name, ang_unit_conv_factor, linear_unit_name, linear_unit_conv_factor);
            }
            return (MemorySegment)mh$.invokeExact(ctx, center_lat, center_long, scale, false_easting, false_northing, ang_unit_name, ang_unit_conv_factor, linear_unit_name, linear_unit_conv_factor);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_create_conversion_van_der_grinten {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_create_conversion_van_der_grinten");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_van_der_grinten(PJ_CONTEXT *ctx, double center_long, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static FunctionDescriptor proj_create_conversion_van_der_grinten$descriptor() {
        return proj_create_conversion_van_der_grinten.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_van_der_grinten(PJ_CONTEXT *ctx, double center_long, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MethodHandle proj_create_conversion_van_der_grinten$handle() {
        return proj_create_conversion_van_der_grinten.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_van_der_grinten(PJ_CONTEXT *ctx, double center_long, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MemorySegment proj_create_conversion_van_der_grinten$address() {
        return proj_create_conversion_van_der_grinten.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ *proj_create_conversion_van_der_grinten(PJ_CONTEXT *ctx, double center_long, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MemorySegment proj_create_conversion_van_der_grinten(MemorySegment ctx, double center_long, double false_easting, double false_northing, MemorySegment ang_unit_name, double ang_unit_conv_factor, MemorySegment linear_unit_name, double linear_unit_conv_factor) {
        var mh$ = proj_create_conversion_van_der_grinten.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_create_conversion_van_der_grinten", ctx, center_long, false_easting, false_northing, ang_unit_name, ang_unit_conv_factor, linear_unit_name, linear_unit_conv_factor);
            }
            return (MemorySegment)mh$.invokeExact(ctx, center_long, false_easting, false_northing, ang_unit_name, ang_unit_conv_factor, linear_unit_name, linear_unit_conv_factor);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_create_conversion_wagner_i {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_create_conversion_wagner_i");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_wagner_i(PJ_CONTEXT *ctx, double center_long, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static FunctionDescriptor proj_create_conversion_wagner_i$descriptor() {
        return proj_create_conversion_wagner_i.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_wagner_i(PJ_CONTEXT *ctx, double center_long, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MethodHandle proj_create_conversion_wagner_i$handle() {
        return proj_create_conversion_wagner_i.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_wagner_i(PJ_CONTEXT *ctx, double center_long, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MemorySegment proj_create_conversion_wagner_i$address() {
        return proj_create_conversion_wagner_i.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ *proj_create_conversion_wagner_i(PJ_CONTEXT *ctx, double center_long, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MemorySegment proj_create_conversion_wagner_i(MemorySegment ctx, double center_long, double false_easting, double false_northing, MemorySegment ang_unit_name, double ang_unit_conv_factor, MemorySegment linear_unit_name, double linear_unit_conv_factor) {
        var mh$ = proj_create_conversion_wagner_i.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_create_conversion_wagner_i", ctx, center_long, false_easting, false_northing, ang_unit_name, ang_unit_conv_factor, linear_unit_name, linear_unit_conv_factor);
            }
            return (MemorySegment)mh$.invokeExact(ctx, center_long, false_easting, false_northing, ang_unit_name, ang_unit_conv_factor, linear_unit_name, linear_unit_conv_factor);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_create_conversion_wagner_ii {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_create_conversion_wagner_ii");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_wagner_ii(PJ_CONTEXT *ctx, double center_long, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static FunctionDescriptor proj_create_conversion_wagner_ii$descriptor() {
        return proj_create_conversion_wagner_ii.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_wagner_ii(PJ_CONTEXT *ctx, double center_long, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MethodHandle proj_create_conversion_wagner_ii$handle() {
        return proj_create_conversion_wagner_ii.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_wagner_ii(PJ_CONTEXT *ctx, double center_long, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MemorySegment proj_create_conversion_wagner_ii$address() {
        return proj_create_conversion_wagner_ii.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ *proj_create_conversion_wagner_ii(PJ_CONTEXT *ctx, double center_long, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MemorySegment proj_create_conversion_wagner_ii(MemorySegment ctx, double center_long, double false_easting, double false_northing, MemorySegment ang_unit_name, double ang_unit_conv_factor, MemorySegment linear_unit_name, double linear_unit_conv_factor) {
        var mh$ = proj_create_conversion_wagner_ii.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_create_conversion_wagner_ii", ctx, center_long, false_easting, false_northing, ang_unit_name, ang_unit_conv_factor, linear_unit_name, linear_unit_conv_factor);
            }
            return (MemorySegment)mh$.invokeExact(ctx, center_long, false_easting, false_northing, ang_unit_name, ang_unit_conv_factor, linear_unit_name, linear_unit_conv_factor);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_create_conversion_wagner_iii {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_create_conversion_wagner_iii");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_wagner_iii(PJ_CONTEXT *ctx, double latitude_true_scale, double center_long, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static FunctionDescriptor proj_create_conversion_wagner_iii$descriptor() {
        return proj_create_conversion_wagner_iii.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_wagner_iii(PJ_CONTEXT *ctx, double latitude_true_scale, double center_long, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MethodHandle proj_create_conversion_wagner_iii$handle() {
        return proj_create_conversion_wagner_iii.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_wagner_iii(PJ_CONTEXT *ctx, double latitude_true_scale, double center_long, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MemorySegment proj_create_conversion_wagner_iii$address() {
        return proj_create_conversion_wagner_iii.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ *proj_create_conversion_wagner_iii(PJ_CONTEXT *ctx, double latitude_true_scale, double center_long, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MemorySegment proj_create_conversion_wagner_iii(MemorySegment ctx, double latitude_true_scale, double center_long, double false_easting, double false_northing, MemorySegment ang_unit_name, double ang_unit_conv_factor, MemorySegment linear_unit_name, double linear_unit_conv_factor) {
        var mh$ = proj_create_conversion_wagner_iii.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_create_conversion_wagner_iii", ctx, latitude_true_scale, center_long, false_easting, false_northing, ang_unit_name, ang_unit_conv_factor, linear_unit_name, linear_unit_conv_factor);
            }
            return (MemorySegment)mh$.invokeExact(ctx, latitude_true_scale, center_long, false_easting, false_northing, ang_unit_name, ang_unit_conv_factor, linear_unit_name, linear_unit_conv_factor);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_create_conversion_wagner_iv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_create_conversion_wagner_iv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_wagner_iv(PJ_CONTEXT *ctx, double center_long, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static FunctionDescriptor proj_create_conversion_wagner_iv$descriptor() {
        return proj_create_conversion_wagner_iv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_wagner_iv(PJ_CONTEXT *ctx, double center_long, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MethodHandle proj_create_conversion_wagner_iv$handle() {
        return proj_create_conversion_wagner_iv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_wagner_iv(PJ_CONTEXT *ctx, double center_long, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MemorySegment proj_create_conversion_wagner_iv$address() {
        return proj_create_conversion_wagner_iv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ *proj_create_conversion_wagner_iv(PJ_CONTEXT *ctx, double center_long, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MemorySegment proj_create_conversion_wagner_iv(MemorySegment ctx, double center_long, double false_easting, double false_northing, MemorySegment ang_unit_name, double ang_unit_conv_factor, MemorySegment linear_unit_name, double linear_unit_conv_factor) {
        var mh$ = proj_create_conversion_wagner_iv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_create_conversion_wagner_iv", ctx, center_long, false_easting, false_northing, ang_unit_name, ang_unit_conv_factor, linear_unit_name, linear_unit_conv_factor);
            }
            return (MemorySegment)mh$.invokeExact(ctx, center_long, false_easting, false_northing, ang_unit_name, ang_unit_conv_factor, linear_unit_name, linear_unit_conv_factor);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_create_conversion_wagner_v {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_create_conversion_wagner_v");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_wagner_v(PJ_CONTEXT *ctx, double center_long, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static FunctionDescriptor proj_create_conversion_wagner_v$descriptor() {
        return proj_create_conversion_wagner_v.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_wagner_v(PJ_CONTEXT *ctx, double center_long, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MethodHandle proj_create_conversion_wagner_v$handle() {
        return proj_create_conversion_wagner_v.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_wagner_v(PJ_CONTEXT *ctx, double center_long, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MemorySegment proj_create_conversion_wagner_v$address() {
        return proj_create_conversion_wagner_v.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ *proj_create_conversion_wagner_v(PJ_CONTEXT *ctx, double center_long, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MemorySegment proj_create_conversion_wagner_v(MemorySegment ctx, double center_long, double false_easting, double false_northing, MemorySegment ang_unit_name, double ang_unit_conv_factor, MemorySegment linear_unit_name, double linear_unit_conv_factor) {
        var mh$ = proj_create_conversion_wagner_v.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_create_conversion_wagner_v", ctx, center_long, false_easting, false_northing, ang_unit_name, ang_unit_conv_factor, linear_unit_name, linear_unit_conv_factor);
            }
            return (MemorySegment)mh$.invokeExact(ctx, center_long, false_easting, false_northing, ang_unit_name, ang_unit_conv_factor, linear_unit_name, linear_unit_conv_factor);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_create_conversion_wagner_vi {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_create_conversion_wagner_vi");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_wagner_vi(PJ_CONTEXT *ctx, double center_long, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static FunctionDescriptor proj_create_conversion_wagner_vi$descriptor() {
        return proj_create_conversion_wagner_vi.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_wagner_vi(PJ_CONTEXT *ctx, double center_long, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MethodHandle proj_create_conversion_wagner_vi$handle() {
        return proj_create_conversion_wagner_vi.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_wagner_vi(PJ_CONTEXT *ctx, double center_long, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MemorySegment proj_create_conversion_wagner_vi$address() {
        return proj_create_conversion_wagner_vi.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ *proj_create_conversion_wagner_vi(PJ_CONTEXT *ctx, double center_long, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MemorySegment proj_create_conversion_wagner_vi(MemorySegment ctx, double center_long, double false_easting, double false_northing, MemorySegment ang_unit_name, double ang_unit_conv_factor, MemorySegment linear_unit_name, double linear_unit_conv_factor) {
        var mh$ = proj_create_conversion_wagner_vi.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_create_conversion_wagner_vi", ctx, center_long, false_easting, false_northing, ang_unit_name, ang_unit_conv_factor, linear_unit_name, linear_unit_conv_factor);
            }
            return (MemorySegment)mh$.invokeExact(ctx, center_long, false_easting, false_northing, ang_unit_name, ang_unit_conv_factor, linear_unit_name, linear_unit_conv_factor);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_create_conversion_wagner_vii {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_create_conversion_wagner_vii");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_wagner_vii(PJ_CONTEXT *ctx, double center_long, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static FunctionDescriptor proj_create_conversion_wagner_vii$descriptor() {
        return proj_create_conversion_wagner_vii.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_wagner_vii(PJ_CONTEXT *ctx, double center_long, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MethodHandle proj_create_conversion_wagner_vii$handle() {
        return proj_create_conversion_wagner_vii.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_wagner_vii(PJ_CONTEXT *ctx, double center_long, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MemorySegment proj_create_conversion_wagner_vii$address() {
        return proj_create_conversion_wagner_vii.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ *proj_create_conversion_wagner_vii(PJ_CONTEXT *ctx, double center_long, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MemorySegment proj_create_conversion_wagner_vii(MemorySegment ctx, double center_long, double false_easting, double false_northing, MemorySegment ang_unit_name, double ang_unit_conv_factor, MemorySegment linear_unit_name, double linear_unit_conv_factor) {
        var mh$ = proj_create_conversion_wagner_vii.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_create_conversion_wagner_vii", ctx, center_long, false_easting, false_northing, ang_unit_name, ang_unit_conv_factor, linear_unit_name, linear_unit_conv_factor);
            }
            return (MemorySegment)mh$.invokeExact(ctx, center_long, false_easting, false_northing, ang_unit_name, ang_unit_conv_factor, linear_unit_name, linear_unit_conv_factor);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_create_conversion_quadrilateralized_spherical_cube {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_create_conversion_quadrilateralized_spherical_cube");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_quadrilateralized_spherical_cube(PJ_CONTEXT *ctx, double center_lat, double center_long, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static FunctionDescriptor proj_create_conversion_quadrilateralized_spherical_cube$descriptor() {
        return proj_create_conversion_quadrilateralized_spherical_cube.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_quadrilateralized_spherical_cube(PJ_CONTEXT *ctx, double center_lat, double center_long, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MethodHandle proj_create_conversion_quadrilateralized_spherical_cube$handle() {
        return proj_create_conversion_quadrilateralized_spherical_cube.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_quadrilateralized_spherical_cube(PJ_CONTEXT *ctx, double center_lat, double center_long, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MemorySegment proj_create_conversion_quadrilateralized_spherical_cube$address() {
        return proj_create_conversion_quadrilateralized_spherical_cube.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ *proj_create_conversion_quadrilateralized_spherical_cube(PJ_CONTEXT *ctx, double center_lat, double center_long, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MemorySegment proj_create_conversion_quadrilateralized_spherical_cube(MemorySegment ctx, double center_lat, double center_long, double false_easting, double false_northing, MemorySegment ang_unit_name, double ang_unit_conv_factor, MemorySegment linear_unit_name, double linear_unit_conv_factor) {
        var mh$ = proj_create_conversion_quadrilateralized_spherical_cube.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_create_conversion_quadrilateralized_spherical_cube", ctx, center_lat, center_long, false_easting, false_northing, ang_unit_name, ang_unit_conv_factor, linear_unit_name, linear_unit_conv_factor);
            }
            return (MemorySegment)mh$.invokeExact(ctx, center_lat, center_long, false_easting, false_northing, ang_unit_name, ang_unit_conv_factor, linear_unit_name, linear_unit_conv_factor);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_create_conversion_spherical_cross_track_height {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_create_conversion_spherical_cross_track_height");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_spherical_cross_track_height(PJ_CONTEXT *ctx, double peg_point_lat, double peg_point_long, double peg_point_heading, double peg_point_height, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static FunctionDescriptor proj_create_conversion_spherical_cross_track_height$descriptor() {
        return proj_create_conversion_spherical_cross_track_height.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_spherical_cross_track_height(PJ_CONTEXT *ctx, double peg_point_lat, double peg_point_long, double peg_point_heading, double peg_point_height, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MethodHandle proj_create_conversion_spherical_cross_track_height$handle() {
        return proj_create_conversion_spherical_cross_track_height.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_spherical_cross_track_height(PJ_CONTEXT *ctx, double peg_point_lat, double peg_point_long, double peg_point_heading, double peg_point_height, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MemorySegment proj_create_conversion_spherical_cross_track_height$address() {
        return proj_create_conversion_spherical_cross_track_height.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ *proj_create_conversion_spherical_cross_track_height(PJ_CONTEXT *ctx, double peg_point_lat, double peg_point_long, double peg_point_heading, double peg_point_height, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MemorySegment proj_create_conversion_spherical_cross_track_height(MemorySegment ctx, double peg_point_lat, double peg_point_long, double peg_point_heading, double peg_point_height, MemorySegment ang_unit_name, double ang_unit_conv_factor, MemorySegment linear_unit_name, double linear_unit_conv_factor) {
        var mh$ = proj_create_conversion_spherical_cross_track_height.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_create_conversion_spherical_cross_track_height", ctx, peg_point_lat, peg_point_long, peg_point_heading, peg_point_height, ang_unit_name, ang_unit_conv_factor, linear_unit_name, linear_unit_conv_factor);
            }
            return (MemorySegment)mh$.invokeExact(ctx, peg_point_lat, peg_point_long, peg_point_heading, peg_point_height, ang_unit_name, ang_unit_conv_factor, linear_unit_name, linear_unit_conv_factor);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_create_conversion_equal_earth {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_create_conversion_equal_earth");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_equal_earth(PJ_CONTEXT *ctx, double center_long, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static FunctionDescriptor proj_create_conversion_equal_earth$descriptor() {
        return proj_create_conversion_equal_earth.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_equal_earth(PJ_CONTEXT *ctx, double center_long, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MethodHandle proj_create_conversion_equal_earth$handle() {
        return proj_create_conversion_equal_earth.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_equal_earth(PJ_CONTEXT *ctx, double center_long, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MemorySegment proj_create_conversion_equal_earth$address() {
        return proj_create_conversion_equal_earth.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ *proj_create_conversion_equal_earth(PJ_CONTEXT *ctx, double center_long, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MemorySegment proj_create_conversion_equal_earth(MemorySegment ctx, double center_long, double false_easting, double false_northing, MemorySegment ang_unit_name, double ang_unit_conv_factor, MemorySegment linear_unit_name, double linear_unit_conv_factor) {
        var mh$ = proj_create_conversion_equal_earth.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_create_conversion_equal_earth", ctx, center_long, false_easting, false_northing, ang_unit_name, ang_unit_conv_factor, linear_unit_name, linear_unit_conv_factor);
            }
            return (MemorySegment)mh$.invokeExact(ctx, center_long, false_easting, false_northing, ang_unit_name, ang_unit_conv_factor, linear_unit_name, linear_unit_conv_factor);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_create_conversion_vertical_perspective {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_create_conversion_vertical_perspective");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_vertical_perspective(PJ_CONTEXT *ctx, double topo_origin_lat, double topo_origin_long, double topo_origin_height, double view_point_height, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static FunctionDescriptor proj_create_conversion_vertical_perspective$descriptor() {
        return proj_create_conversion_vertical_perspective.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_vertical_perspective(PJ_CONTEXT *ctx, double topo_origin_lat, double topo_origin_long, double topo_origin_height, double view_point_height, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MethodHandle proj_create_conversion_vertical_perspective$handle() {
        return proj_create_conversion_vertical_perspective.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_vertical_perspective(PJ_CONTEXT *ctx, double topo_origin_lat, double topo_origin_long, double topo_origin_height, double view_point_height, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MemorySegment proj_create_conversion_vertical_perspective$address() {
        return proj_create_conversion_vertical_perspective.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ *proj_create_conversion_vertical_perspective(PJ_CONTEXT *ctx, double topo_origin_lat, double topo_origin_long, double topo_origin_height, double view_point_height, double false_easting, double false_northing, const char *ang_unit_name, double ang_unit_conv_factor, const char *linear_unit_name, double linear_unit_conv_factor)
     * }
     */
    public static MemorySegment proj_create_conversion_vertical_perspective(MemorySegment ctx, double topo_origin_lat, double topo_origin_long, double topo_origin_height, double view_point_height, double false_easting, double false_northing, MemorySegment ang_unit_name, double ang_unit_conv_factor, MemorySegment linear_unit_name, double linear_unit_conv_factor) {
        var mh$ = proj_create_conversion_vertical_perspective.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_create_conversion_vertical_perspective", ctx, topo_origin_lat, topo_origin_long, topo_origin_height, view_point_height, false_easting, false_northing, ang_unit_name, ang_unit_conv_factor, linear_unit_name, linear_unit_conv_factor);
            }
            return (MemorySegment)mh$.invokeExact(ctx, topo_origin_lat, topo_origin_long, topo_origin_height, view_point_height, false_easting, false_northing, ang_unit_name, ang_unit_conv_factor, linear_unit_name, linear_unit_conv_factor);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_create_conversion_pole_rotation_grib_convention {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_create_conversion_pole_rotation_grib_convention");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_pole_rotation_grib_convention(PJ_CONTEXT *ctx, double south_pole_lat_in_unrotated_crs, double south_pole_long_in_unrotated_crs, double axis_rotation, const char *ang_unit_name, double ang_unit_conv_factor)
     * }
     */
    public static FunctionDescriptor proj_create_conversion_pole_rotation_grib_convention$descriptor() {
        return proj_create_conversion_pole_rotation_grib_convention.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_pole_rotation_grib_convention(PJ_CONTEXT *ctx, double south_pole_lat_in_unrotated_crs, double south_pole_long_in_unrotated_crs, double axis_rotation, const char *ang_unit_name, double ang_unit_conv_factor)
     * }
     */
    public static MethodHandle proj_create_conversion_pole_rotation_grib_convention$handle() {
        return proj_create_conversion_pole_rotation_grib_convention.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_pole_rotation_grib_convention(PJ_CONTEXT *ctx, double south_pole_lat_in_unrotated_crs, double south_pole_long_in_unrotated_crs, double axis_rotation, const char *ang_unit_name, double ang_unit_conv_factor)
     * }
     */
    public static MemorySegment proj_create_conversion_pole_rotation_grib_convention$address() {
        return proj_create_conversion_pole_rotation_grib_convention.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ *proj_create_conversion_pole_rotation_grib_convention(PJ_CONTEXT *ctx, double south_pole_lat_in_unrotated_crs, double south_pole_long_in_unrotated_crs, double axis_rotation, const char *ang_unit_name, double ang_unit_conv_factor)
     * }
     */
    public static MemorySegment proj_create_conversion_pole_rotation_grib_convention(MemorySegment ctx, double south_pole_lat_in_unrotated_crs, double south_pole_long_in_unrotated_crs, double axis_rotation, MemorySegment ang_unit_name, double ang_unit_conv_factor) {
        var mh$ = proj_create_conversion_pole_rotation_grib_convention.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_create_conversion_pole_rotation_grib_convention", ctx, south_pole_lat_in_unrotated_crs, south_pole_long_in_unrotated_crs, axis_rotation, ang_unit_name, ang_unit_conv_factor);
            }
            return (MemorySegment)mh$.invokeExact(ctx, south_pole_lat_in_unrotated_crs, south_pole_long_in_unrotated_crs, axis_rotation, ang_unit_name, ang_unit_conv_factor);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_create_conversion_pole_rotation_netcdf_cf_convention {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("proj_create_conversion_pole_rotation_netcdf_cf_convention");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_pole_rotation_netcdf_cf_convention(PJ_CONTEXT *ctx, double grid_north_pole_latitude, double grid_north_pole_longitude, double north_pole_grid_longitude, const char *ang_unit_name, double ang_unit_conv_factor)
     * }
     */
    public static FunctionDescriptor proj_create_conversion_pole_rotation_netcdf_cf_convention$descriptor() {
        return proj_create_conversion_pole_rotation_netcdf_cf_convention.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_pole_rotation_netcdf_cf_convention(PJ_CONTEXT *ctx, double grid_north_pole_latitude, double grid_north_pole_longitude, double north_pole_grid_longitude, const char *ang_unit_name, double ang_unit_conv_factor)
     * }
     */
    public static MethodHandle proj_create_conversion_pole_rotation_netcdf_cf_convention$handle() {
        return proj_create_conversion_pole_rotation_netcdf_cf_convention.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ *proj_create_conversion_pole_rotation_netcdf_cf_convention(PJ_CONTEXT *ctx, double grid_north_pole_latitude, double grid_north_pole_longitude, double north_pole_grid_longitude, const char *ang_unit_name, double ang_unit_conv_factor)
     * }
     */
    public static MemorySegment proj_create_conversion_pole_rotation_netcdf_cf_convention$address() {
        return proj_create_conversion_pole_rotation_netcdf_cf_convention.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ *proj_create_conversion_pole_rotation_netcdf_cf_convention(PJ_CONTEXT *ctx, double grid_north_pole_latitude, double grid_north_pole_longitude, double north_pole_grid_longitude, const char *ang_unit_name, double ang_unit_conv_factor)
     * }
     */
    public static MemorySegment proj_create_conversion_pole_rotation_netcdf_cf_convention(MemorySegment ctx, double grid_north_pole_latitude, double grid_north_pole_longitude, double north_pole_grid_longitude, MemorySegment ang_unit_name, double ang_unit_conv_factor) {
        var mh$ = proj_create_conversion_pole_rotation_netcdf_cf_convention.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_create_conversion_pole_rotation_netcdf_cf_convention", ctx, grid_north_pole_latitude, grid_north_pole_longitude, north_pole_grid_longitude, ang_unit_name, ang_unit_conv_factor);
            }
            return (MemorySegment)mh$.invokeExact(ctx, grid_north_pole_latitude, grid_north_pole_longitude, north_pole_grid_longitude, ang_unit_name, ang_unit_conv_factor);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final MemorySegment NULL = MemorySegment.ofAddress(0L);
    /**
     * {@snippet lang=c :
     * #define NULL (void*) 0
     * }
     */
    public static MemorySegment NULL() {
        return NULL;
    }
    private static final int PROJ_VERSION_NUMBER = (int)90602L;
    /**
     * {@snippet lang=c :
     * #define PROJ_VERSION_NUMBER 90602
     * }
     */
    public static int PROJ_VERSION_NUMBER() {
        return PROJ_VERSION_NUMBER;
    }
    private static final int PROJ_ERR_INVALID_OP_WRONG_SYNTAX = (int)1025L;
    /**
     * {@snippet lang=c :
     * #define PROJ_ERR_INVALID_OP_WRONG_SYNTAX 1025
     * }
     */
    public static int PROJ_ERR_INVALID_OP_WRONG_SYNTAX() {
        return PROJ_ERR_INVALID_OP_WRONG_SYNTAX;
    }
    private static final int PROJ_ERR_INVALID_OP_MISSING_ARG = (int)1026L;
    /**
     * {@snippet lang=c :
     * #define PROJ_ERR_INVALID_OP_MISSING_ARG 1026
     * }
     */
    public static int PROJ_ERR_INVALID_OP_MISSING_ARG() {
        return PROJ_ERR_INVALID_OP_MISSING_ARG;
    }
    private static final int PROJ_ERR_INVALID_OP_ILLEGAL_ARG_VALUE = (int)1027L;
    /**
     * {@snippet lang=c :
     * #define PROJ_ERR_INVALID_OP_ILLEGAL_ARG_VALUE 1027
     * }
     */
    public static int PROJ_ERR_INVALID_OP_ILLEGAL_ARG_VALUE() {
        return PROJ_ERR_INVALID_OP_ILLEGAL_ARG_VALUE;
    }
    private static final int PROJ_ERR_INVALID_OP_MUTUALLY_EXCLUSIVE_ARGS = (int)1028L;
    /**
     * {@snippet lang=c :
     * #define PROJ_ERR_INVALID_OP_MUTUALLY_EXCLUSIVE_ARGS 1028
     * }
     */
    public static int PROJ_ERR_INVALID_OP_MUTUALLY_EXCLUSIVE_ARGS() {
        return PROJ_ERR_INVALID_OP_MUTUALLY_EXCLUSIVE_ARGS;
    }
    private static final int PROJ_ERR_INVALID_OP_FILE_NOT_FOUND_OR_INVALID = (int)1029L;
    /**
     * {@snippet lang=c :
     * #define PROJ_ERR_INVALID_OP_FILE_NOT_FOUND_OR_INVALID 1029
     * }
     */
    public static int PROJ_ERR_INVALID_OP_FILE_NOT_FOUND_OR_INVALID() {
        return PROJ_ERR_INVALID_OP_FILE_NOT_FOUND_OR_INVALID;
    }
    private static final int PROJ_ERR_COORD_TRANSFM_INVALID_COORD = (int)2049L;
    /**
     * {@snippet lang=c :
     * #define PROJ_ERR_COORD_TRANSFM_INVALID_COORD 2049
     * }
     */
    public static int PROJ_ERR_COORD_TRANSFM_INVALID_COORD() {
        return PROJ_ERR_COORD_TRANSFM_INVALID_COORD;
    }
    private static final int PROJ_ERR_COORD_TRANSFM_OUTSIDE_PROJECTION_DOMAIN = (int)2050L;
    /**
     * {@snippet lang=c :
     * #define PROJ_ERR_COORD_TRANSFM_OUTSIDE_PROJECTION_DOMAIN 2050
     * }
     */
    public static int PROJ_ERR_COORD_TRANSFM_OUTSIDE_PROJECTION_DOMAIN() {
        return PROJ_ERR_COORD_TRANSFM_OUTSIDE_PROJECTION_DOMAIN;
    }
    private static final int PROJ_ERR_COORD_TRANSFM_NO_OPERATION = (int)2051L;
    /**
     * {@snippet lang=c :
     * #define PROJ_ERR_COORD_TRANSFM_NO_OPERATION 2051
     * }
     */
    public static int PROJ_ERR_COORD_TRANSFM_NO_OPERATION() {
        return PROJ_ERR_COORD_TRANSFM_NO_OPERATION;
    }
    private static final int PROJ_ERR_COORD_TRANSFM_OUTSIDE_GRID = (int)2052L;
    /**
     * {@snippet lang=c :
     * #define PROJ_ERR_COORD_TRANSFM_OUTSIDE_GRID 2052
     * }
     */
    public static int PROJ_ERR_COORD_TRANSFM_OUTSIDE_GRID() {
        return PROJ_ERR_COORD_TRANSFM_OUTSIDE_GRID;
    }
    private static final int PROJ_ERR_COORD_TRANSFM_GRID_AT_NODATA = (int)2053L;
    /**
     * {@snippet lang=c :
     * #define PROJ_ERR_COORD_TRANSFM_GRID_AT_NODATA 2053
     * }
     */
    public static int PROJ_ERR_COORD_TRANSFM_GRID_AT_NODATA() {
        return PROJ_ERR_COORD_TRANSFM_GRID_AT_NODATA;
    }
    private static final int PROJ_ERR_COORD_TRANSFM_NO_CONVERGENCE = (int)2054L;
    /**
     * {@snippet lang=c :
     * #define PROJ_ERR_COORD_TRANSFM_NO_CONVERGENCE 2054
     * }
     */
    public static int PROJ_ERR_COORD_TRANSFM_NO_CONVERGENCE() {
        return PROJ_ERR_COORD_TRANSFM_NO_CONVERGENCE;
    }
    private static final int PROJ_ERR_COORD_TRANSFM_MISSING_TIME = (int)2055L;
    /**
     * {@snippet lang=c :
     * #define PROJ_ERR_COORD_TRANSFM_MISSING_TIME 2055
     * }
     */
    public static int PROJ_ERR_COORD_TRANSFM_MISSING_TIME() {
        return PROJ_ERR_COORD_TRANSFM_MISSING_TIME;
    }
    private static final int PROJ_ERR_OTHER_API_MISUSE = (int)4097L;
    /**
     * {@snippet lang=c :
     * #define PROJ_ERR_OTHER_API_MISUSE 4097
     * }
     */
    public static int PROJ_ERR_OTHER_API_MISUSE() {
        return PROJ_ERR_OTHER_API_MISUSE;
    }
    private static final int PROJ_ERR_OTHER_NO_INVERSE_OP = (int)4098L;
    /**
     * {@snippet lang=c :
     * #define PROJ_ERR_OTHER_NO_INVERSE_OP 4098
     * }
     */
    public static int PROJ_ERR_OTHER_NO_INVERSE_OP() {
        return PROJ_ERR_OTHER_NO_INVERSE_OP;
    }
    private static final int PROJ_ERR_OTHER_NETWORK_ERROR = (int)4099L;
    /**
     * {@snippet lang=c :
     * #define PROJ_ERR_OTHER_NETWORK_ERROR 4099
     * }
     */
    public static int PROJ_ERR_OTHER_NETWORK_ERROR() {
        return PROJ_ERR_OTHER_NETWORK_ERROR;
    }
}

